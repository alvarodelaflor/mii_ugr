(function(win) {
    var whiteSpaceRe = /^\s*|\s*$/g, undef, isRegExpBroken = "$1" === "B".replace(/A(.)|B/, "$1");
    var tinymce = {
        majorVersion: "@@tinymce_major_version@@",
        minorVersion: "@@tinymce_minor_version@@",
        releaseDate: "@@tinymce_release_date@@",
        _init: function() {
            var t = this, d = document, na = navigator, ua = na.userAgent, i, nl, n, base, p, v;
            t.isOpera = win.opera && opera.buildNumber;
            t.isWebKit = /WebKit/.test(ua);
            t.isIE = !t.isWebKit && !t.isOpera && /MSIE/gi.test(ua) && /Explorer/gi.test(na.appName);
            t.isIE6 = t.isIE && /MSIE [56]/.test(ua);
            t.isIE7 = t.isIE && /MSIE [7]/.test(ua);
            t.isIE8 = t.isIE && /MSIE [8]/.test(ua);
            t.isIE9 = t.isIE && /MSIE [9]/.test(ua);
            t.isGecko = !t.isWebKit && /Gecko/.test(ua);
            t.isMac = ua.indexOf("Mac") != -1;
            t.isAir = /adobeair/i.test(ua);
            t.isIDevice = /(iPad|iPhone)/.test(ua);
            t.isIOS5 = t.isIDevice && ua.match(/AppleWebKit\/(\d*)/)[1] >= 534;
            if (win.tinyMCEPreInit) {
                t.suffix = tinyMCEPreInit.suffix;
                t.baseURL = tinyMCEPreInit.base;
                t.query = tinyMCEPreInit.query;
                return;
            }
            t.suffix = "";
            nl = d.getElementsByTagName("base");
            for (i = 0; i < nl.length; i++) {
                v = nl[i].href;
                if (v) {
                    if (/^https?:\/\/[^\/]+$/.test(v)) v += "/";
                    base = v ? v.match(/.*\//)[0] : "";
                }
            }
            function getBase(n) {
                if (n.src && /tiny_mce(|_gzip|_jquery|_prototype|_full)(_dev|_src)?.js/.test(n.src)) {
                    if (/_(src|dev)\.js/g.test(n.src)) t.suffix = "_src";
                    if ((p = n.src.indexOf("?")) != -1) t.query = n.src.substring(p + 1);
                    t.baseURL = n.src.substring(0, n.src.lastIndexOf("/"));
                    if (base && t.baseURL.indexOf("://") == -1 && 0 !== t.baseURL.indexOf("/")) t.baseURL = base + t.baseURL;
                    return t.baseURL;
                }
                return null;
            }
            nl = d.getElementsByTagName("script");
            for (i = 0; i < nl.length; i++) if (getBase(nl[i])) return;
            n = d.getElementsByTagName("head")[0];
            if (n) {
                nl = n.getElementsByTagName("script");
                for (i = 0; i < nl.length; i++) if (getBase(nl[i])) return;
            }
            return;
        },
        is: function(o, t) {
            if (!t) return o !== undef;
            if ("array" == t && o.hasOwnProperty && o instanceof Array) return true;
            return typeof o == t;
        },
        makeMap: function(items, delim, map) {
            var i;
            items = items || [];
            delim = delim || ",";
            if ("string" == typeof items) items = items.split(delim);
            map = map || {};
            i = items.length;
            while (i--) map[items[i]] = {};
            return map;
        },
        each: function(o, cb, s) {
            var n, l;
            if (!o) return 0;
            s = s || o;
            if (o.length !== undef) {
                for (n = 0, l = o.length; n < l; n++) if (false === cb.call(s, o[n], n, o)) return 0;
            } else for (n in o) if (o.hasOwnProperty(n)) if (false === cb.call(s, o[n], n, o)) return 0;
            return 1;
        },
        trim: function(s) {
            return (s ? "" + s : "").replace(whiteSpaceRe, "");
        },
        create: function(s, p, root) {
            var t = this, sp, ns, cn, scn, c, de = 0;
            s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
            cn = s[3].match(/(^|\.)(\w+)$/i)[2];
            ns = t.createNS(s[3].replace(/\.\w+$/, ""), root);
            if (ns[cn]) return;
            if ("static" == s[2]) {
                ns[cn] = p;
                if (this.onCreate) this.onCreate(s[2], s[3], ns[cn]);
                return;
            }
            if (!p[cn]) {
                p[cn] = function() {};
                de = 1;
            }
            ns[cn] = p[cn];
            t.extend(ns[cn].prototype, p);
            if (s[5]) {
                sp = t.resolve(s[5]).prototype;
                scn = s[5].match(/\.(\w+)$/i)[1];
                c = ns[cn];
                if (de) ns[cn] = function() {
                    return sp[scn].apply(this, arguments);
                }; else ns[cn] = function() {
                    this.parent = sp[scn];
                    return c.apply(this, arguments);
                };
                ns[cn].prototype[cn] = ns[cn];
                t.each(sp, function(f, n) {
                    ns[cn].prototype[n] = sp[n];
                });
                t.each(p, function(f, n) {
                    if (sp[n]) ns[cn].prototype[n] = function() {
                        this.parent = sp[n];
                        return f.apply(this, arguments);
                    }; else if (n != cn) ns[cn].prototype[n] = f;
                });
            }
            t.each(p["static"], function(f, n) {
                ns[cn][n] = f;
            });
            if (this.onCreate) this.onCreate(s[2], s[3], ns[cn].prototype);
        },
        walk: function(o, f, n, s) {
            s = s || this;
            if (o) {
                if (n) o = o[n];
                tinymce.each(o, function(o, i) {
                    if (false === f.call(s, o, i, n)) return false;
                    tinymce.walk(o, f, n, s);
                });
            }
        },
        createNS: function(n, o) {
            var i, v;
            o = o || win;
            n = n.split(".");
            for (i = 0; i < n.length; i++) {
                v = n[i];
                if (!o[v]) o[v] = {};
                o = o[v];
            }
            return o;
        },
        resolve: function(n, o) {
            var i, l;
            o = o || win;
            n = n.split(".");
            for (i = 0, l = n.length; i < l; i++) {
                o = o[n[i]];
                if (!o) break;
            }
            return o;
        },
        addUnload: function(f, s) {
            var t = this, unload;
            unload = function() {
                var li = t.unloads, o, n;
                if (li) {
                    for (n in li) {
                        o = li[n];
                        if (o && o.func) o.func.call(o.scope, 1);
                    }
                    if (win.detachEvent) {
                        win.detachEvent("onbeforeunload", fakeUnload);
                        win.detachEvent("onunload", unload);
                    } else if (win.removeEventListener) win.removeEventListener("unload", unload, false);
                    t.unloads = o = li = w = unload = 0;
                    if (win.CollectGarbage) CollectGarbage();
                }
            };
            function fakeUnload() {
                var d = document;
                function stop() {
                    d.detachEvent("onstop", stop);
                    if (unload) unload();
                    d = 0;
                }
                if ("interactive" == d.readyState) {
                    if (d) d.attachEvent("onstop", stop);
                    win.setTimeout(function() {
                        if (d) d.detachEvent("onstop", stop);
                    }, 0);
                }
            }
            f = {
                func: f,
                scope: s || this
            };
            if (!t.unloads) {
                if (win.attachEvent) {
                    win.attachEvent("onunload", unload);
                    win.attachEvent("onbeforeunload", fakeUnload);
                } else if (win.addEventListener) win.addEventListener("unload", unload, false);
                t.unloads = [ f ];
            } else t.unloads.push(f);
            return f;
        },
        removeUnload: function(f) {
            var u = this.unloads, r = null;
            tinymce.each(u, function(o, i) {
                if (o && o.func == f) {
                    u.splice(i, 1);
                    r = f;
                    return false;
                }
            });
            return r;
        },
        explode: function(s, d) {
            if (!s || tinymce.is(s, "array")) return s;
            return tinymce.map(s.split(d || ","), tinymce.trim);
        },
        _addVer: function(u) {
            var v;
            if (!this.query) return u;
            v = (u.indexOf("?") == -1 ? "?" : "&") + this.query;
            if (u.indexOf("#") == -1) return u + v;
            return u.replace("#", v + "#");
        },
        _replace: function(find, replace, str) {
            if (isRegExpBroken) return str.replace(find, function() {
                var val = replace, args = arguments, i;
                for (i = 0; i < args.length - 2; i++) if (args[i] === undef) val = val.replace(new RegExp("\\$" + i, "g"), ""); else val = val.replace(new RegExp("\\$" + i, "g"), args[i]);
                return val;
            });
            return str.replace(find, replace);
        }
    };
    tinymce._init();
    win.tinymce = win.tinyMCE = tinymce;
})(window);

(function($, tinymce) {
    var is = tinymce.is, attrRegExp = /^(href|src|style)$/i, undef;
    if (!$) return alert("Some of the Javascript files required for Wikispaces did not load. Please reload this page and try again. If this problem continues, make sure an anti-virus program, firewall, or web filter is not blocking Wikispaces Javascript files.");
    tinymce.$ = $;
    tinymce.adapter = {
        patchEditor: function(editor) {
            var fn = $.fn;
            function css(name, value) {
                var self = this;
                if (value) self.removeAttr("data-mce-style");
                return fn.css.apply(self, arguments);
            }
            function attr(name, value) {
                var self = this;
                if (attrRegExp.test(name)) if (value !== undef) {
                    self.each(function(i, node) {
                        editor.dom.setAttrib(node, name, value);
                    });
                    return self;
                } else return self.attr("data-mce-" + name);
                return fn.attr.apply(self, arguments);
            }
            function patch(jq) {
                if (jq.css !== css) {
                    jq.css = css;
                    jq.attr = attr;
                    jq.tinymce = editor;
                    jq.pushStack = function() {
                        return patch(fn.pushStack.apply(this, arguments));
                    };
                }
                return jq;
            }
            editor.$ = function(selector, scope) {
                var doc = editor.getDoc();
                return patch($(selector || doc, doc || scope));
            };
        }
    };
    tinymce.extend = $.extend;
    tinymce.extend(tinymce, {
        map: $.map,
        grep: function(a, f) {
            return $.grep(a, f || function() {
                return 1;
            });
        },
        inArray: function(a, v) {
            return $.inArray(v, a || []);
        }
    });
    var patches = {
        "tinymce.dom.DOMUtils": {
            select: function(pattern, scope) {
                var t = this;
                return $.find(pattern, t.get(scope) || t.get(t.settings.root_element) || t.doc, []);
            },
            is: function(n, patt) {
                if (1 !== n.nodeType && "*" === patt) return false;
                return $(this.get(n)).is(patt);
            }
        }
    };
    tinymce.onCreate = function(ty, c, p) {
        tinymce.extend(p, patches[c]);
    };
})(window.jQuery, tinymce);

tinymce.create("tinymce.util.Dispatcher", {
    scope: null,
    listeners: null,
    inDispatch: false,
    Dispatcher: function(scope) {
        this.scope = scope || this;
        this.listeners = [];
    },
    add: function(callback, scope) {
        this.listeners.push({
            cb: callback,
            scope: scope || this.scope
        });
        return callback;
    },
    addToTop: function(callback, scope) {
        var self = this, listener = {
            cb: callback,
            scope: scope || self.scope
        };
        if (self.inDispatch) self.listeners = [ listener ].concat(self.listeners); else self.listeners.unshift(listener);
        return callback;
    },
    remove: function(callback) {
        var listeners = this.listeners, output = null;
        tinymce.each(listeners, function(listener, i) {
            if (callback == listener.cb) {
                output = listener;
                listeners.splice(i, 1);
                return false;
            }
        });
        return output;
    },
    dispatch: function() {
        var self = this, returnValue, args = arguments, i, listeners = self.listeners, listener;
        self.inDispatch = true;
        for (i = 0; i < listeners.length; i++) {
            listener = listeners[i];
            returnValue = listener.cb.apply(listener.scope, args.length > 0 ? args : [ listener.scope ]);
            if (false === returnValue) break;
        }
        self.inDispatch = false;
        return returnValue;
    }
});

(function() {
    var each = tinymce.each;
    tinymce.create("tinymce.util.URI", {
        URI: function(u, s) {
            var t = this, o, a, b, base_url;
            u = tinymce.trim(u);
            s = t.settings = s || {};
            if (/^([\w\-]+):([^\/]{2})/i.test(u) || /^\s*#/.test(u)) {
                t.source = u;
                return;
            }
            if (0 === u.indexOf("/") && 0 !== u.indexOf("//")) u = (s.base_uri ? s.base_uri.protocol || "http" : "http") + "://mce_host" + u;
            if (!/^[\w\-]*:?\/\//.test(u)) {
                base_url = s.base_uri ? s.base_uri.path : new tinymce.util.URI(location.href).directory;
                u = (s.base_uri && s.base_uri.protocol || "http") + "://mce_host" + t.toAbsPath(base_url, u);
            }
            u = u.replace(/@@/g, "(mce_at)");
            u = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(u);
            each([ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor" ], function(v, i) {
                var s = u[i];
                if (s) s = s.replace(/\(mce_at\)/g, "@@");
                t[v] = s;
            });
            b = s.base_uri;
            if (b) {
                if (!t.protocol) t.protocol = b.protocol;
                if (!t.userInfo) t.userInfo = b.userInfo;
                if (!t.port && "mce_host" === t.host) t.port = b.port;
                if (!t.host || "mce_host" === t.host) t.host = b.host;
                t.source = "";
            }
        },
        setPath: function(p) {
            var t = this;
            p = /^(.*?)\/?(\w+)?$/.exec(p);
            t.path = p[0];
            t.directory = p[1];
            t.file = p[2];
            t.source = "";
            t.getURI();
        },
        toRelative: function(u) {
            var t = this, o;
            if ("./" === u) return u;
            u = new tinymce.util.URI(u, {
                base_uri: t
            });
            if ("mce_host" != u.host && t.host != u.host && u.host || t.port != u.port || t.protocol != u.protocol) return u.getURI();
            var tu = t.getURI(), uu = u.getURI();
            if (tu == uu || "/" == tu.charAt(tu.length - 1) && tu.substr(0, tu.length - 1) == uu) return tu;
            o = t.toRelPath(t.path, u.path);
            if (u.query) o += "?" + u.query;
            if (u.anchor) o += "#" + u.anchor;
            return o;
        },
        toAbsolute: function(u, nh) {
            u = new tinymce.util.URI(u, {
                base_uri: this
            });
            return u.getURI(this.host == u.host && this.protocol == u.protocol ? nh : 0);
        },
        toRelPath: function(base, path) {
            var items, bp = 0, out = "", i, l;
            base = base.substring(0, base.lastIndexOf("/"));
            base = base.split("/");
            items = path.split("/");
            if (base.length >= items.length) for (i = 0, l = base.length; i < l; i++) if (i >= items.length || base[i] != items[i]) {
                bp = i + 1;
                break;
            }
            if (base.length < items.length) for (i = 0, l = items.length; i < l; i++) if (i >= base.length || base[i] != items[i]) {
                bp = i + 1;
                break;
            }
            if (1 === bp) return path;
            for (i = 0, l = base.length - (bp - 1); i < l; i++) out += "../";
            for (i = bp - 1, l = items.length; i < l; i++) if (i != bp - 1) out += "/" + items[i]; else out += items[i];
            return out;
        },
        toAbsPath: function(base, path) {
            var i, nb = 0, o = [], tr, outPath;
            tr = /\/$/.test(path) ? "/" : "";
            base = base.split("/");
            path = path.split("/");
            each(base, function(k) {
                if (k) o.push(k);
            });
            base = o;
            for (i = path.length - 1, o = []; i >= 0; i--) {
                if (0 === path[i].length || "." === path[i]) continue;
                if (".." === path[i]) {
                    nb++;
                    continue;
                }
                if (nb > 0) {
                    nb--;
                    continue;
                }
                o.push(path[i]);
            }
            i = base.length - nb;
            if (i <= 0) outPath = o.reverse().join("/"); else outPath = base.slice(0, i).join("/") + "/" + o.reverse().join("/");
            if (0 !== outPath.indexOf("/")) outPath = "/" + outPath;
            if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) outPath += tr;
            return outPath;
        },
        getURI: function(nh) {
            var s, t = this;
            if (!t.source || nh) {
                s = "";
                if (!nh) {
                    if (t.protocol) s += t.protocol + "://";
                    if (t.userInfo) s += t.userInfo + "@";
                    if (t.host) s += t.host;
                    if (t.port) s += ":" + t.port;
                }
                if (t.path) s += t.path;
                if (t.query) s += "?" + t.query;
                if (t.anchor) s += "#" + t.anchor;
                t.source = s;
            }
            return t.source;
        }
    });
})();

(function() {
    var each = tinymce.each;
    tinymce.create("static tinymce.util.Cookie", {
        getHash: function(n) {
            var v = this.get(n), h;
            if (v) each(v.split("&"), function(v) {
                v = v.split("=");
                h = h || {};
                h[unescape(v[0])] = unescape(v[1]);
            });
            return h;
        },
        setHash: function(n, v, e, p, d, s) {
            var o = "";
            each(v, function(v, k) {
                o += (!o ? "" : "&") + escape(k) + "=" + escape(v);
            });
            this.set(n, o, e, p, d, s);
        },
        get: function(n) {
            var c = document.cookie, e, p = n + "=", b;
            if (!c) return;
            b = c.indexOf("; " + p);
            if (b == -1) {
                b = c.indexOf(p);
                if (0 !== b) return null;
            } else b += 2;
            e = c.indexOf(";", b);
            if (e == -1) e = c.length;
            return unescape(c.substring(b + p.length, e));
        },
        set: function(n, v, e, p, d, s) {
            document.cookie = n + "=" + escape(v) + (e ? "; expires=" + e.toGMTString() : "") + (p ? "; path=" + escape(p) : "") + (d ? "; domain=" + d : "") + (s ? "; secure" : "");
        },
        remove: function(name, path, domain) {
            var date = new Date();
            date.setTime(date.getTime() - 1e3);
            this.set(name, "", date, path, domain);
        }
    });
})();

(function() {
    function serialize(o, quote) {
        var i, v, t, name;
        quote = quote || '"';
        if (null == o) return "null";
        t = typeof o;
        if ("string" == t) {
            v = "\bb	t\nn\ff\rr\"\"''\\\\";
            return quote + o.replace(/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g, function(a, b) {
                if ('"' === quote && "'" === a) return a;
                i = v.indexOf(b);
                if (i + 1) return "\\" + v.charAt(i + 1);
                a = b.charCodeAt().toString(16);
                return "\\u" + "0000".substring(a.length) + a;
            }) + quote;
        }
        if ("object" == t) {
            if (o.hasOwnProperty && "[object Array]" === Object.prototype.toString.call(o)) {
                for (i = 0, v = "["; i < o.length; i++) v += (i > 0 ? "," : "") + serialize(o[i], quote);
                return v + "]";
            }
            v = "{";
            for (name in o) if (o.hasOwnProperty(name)) v += "function" != typeof o[name] ? (v.length > 1 ? "," + quote : quote) + name + quote + ":" + serialize(o[name], quote) : "";
            return v + "}";
        }
        return "" + o;
    }
    tinymce.util.JSON = {
        serialize: serialize,
        parse: function(s) {
            try {
                return eval("(" + s + ")");
            } catch (ex) {}
        }
    };
})();

tinymce.create("static tinymce.util.XHR", {
    send: function(o) {
        var x, t, w = window, c = 0;
        function ready() {
            if (!o.async || 4 == x.readyState || c++ > 1e4) {
                if (o.success && c < 1e4 && 200 == x.status) o.success.call(o.success_scope, "" + x.responseText, x, o); else if (o.error) o.error.call(o.error_scope, c > 1e4 ? "TIMED_OUT" : "GENERAL", x, o);
                x = null;
            } else w.setTimeout(ready, 10);
        }
        o.scope = o.scope || this;
        o.success_scope = o.success_scope || o.scope;
        o.error_scope = o.error_scope || o.scope;
        o.async = false === o.async ? false : true;
        o.data = o.data || "";
        function get(s) {
            x = 0;
            try {
                x = new ActiveXObject(s);
            } catch (ex) {}
            return x;
        }
        x = w.XMLHttpRequest ? new XMLHttpRequest() : get("Microsoft.XMLHTTP") || get("Msxml2.XMLHTTP");
        if (x) {
            if (x.overrideMimeType) x.overrideMimeType(o.content_type);
            x.open(o.type || (o.data ? "POST" : "GET"), o.url, o.async);
            if (o.content_type) x.setRequestHeader("Content-Type", o.content_type);
            x.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            x.send(o.data);
            if (!o.async) return ready();
            t = w.setTimeout(ready, 10);
        }
    }
});

(function() {
    var extend = tinymce.extend, JSON = tinymce.util.JSON, XHR = tinymce.util.XHR;
    tinymce.create("tinymce.util.JSONRequest", {
        JSONRequest: function(s) {
            this.settings = extend({}, s);
            this.count = 0;
        },
        send: function(o) {
            var ecb = o.error, scb = o.success;
            o = extend(this.settings, o);
            o.success = function(c, x) {
                c = JSON.parse(c);
                if ("undefined" == typeof c) c = {
                    error: "JSON Parse error."
                };
                if (c.error) ecb.call(o.error_scope || o.scope, c.error, x); else scb.call(o.success_scope || o.scope, c.result);
            };
            o.error = function(ty, x) {
                if (ecb) ecb.call(o.error_scope || o.scope, ty, x);
            };
            o.data = JSON.serialize({
                id: o.id || "c" + this.count++,
                method: o.method,
                params: o.params
            });
            o.content_type = "application/json";
            XHR.send(o);
        },
        "static": {
            sendRPC: function(o) {
                return new tinymce.util.JSONRequest().send(o);
            }
        }
    });
})();

(function(tinymce) {
    tinymce.VK = {
        BACKSPACE: 8,
        DELETE: 46,
        DOWN: 40,
        ENTER: 13,
        LEFT: 37,
        RIGHT: 39,
        SPACEBAR: 32,
        TAB: 9,
        UP: 38,
        modifierPressed: function(e) {
            return e.shiftKey || e.ctrlKey || e.altKey;
        },
        metaKeyPressed: function(e) {
            return tinymce.isMac ? e.metaKey : e.ctrlKey && !e.altKey;
        }
    };
})(tinymce);

tinymce.util.Quirks = function(editor) {
    var VK = tinymce.VK, BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, settings = editor.settings, parser = editor.parser, serializer = editor.serializer;
    function setEditorCommandState(cmd, state) {
        try {
            editor.getDoc().execCommand(cmd, false, state);
        } catch (ex) {}
    }
    function getDocumentMode() {
        var documentMode = editor.getDoc().documentMode;
        return documentMode ? documentMode : 6;
    }
    function cleanupStylesWhenDeleting() {
        function removeMergedFormatSpans(isDelete) {
            var rng, blockElm, node, clonedSpan;
            rng = selection.getRng();
            blockElm = dom.getParent(rng.startContainer, dom.isBlock);
            if (isDelete) blockElm = dom.getNext(blockElm, dom.isBlock);
            if (blockElm) {
                node = blockElm.firstChild;
                while (node && 3 == node.nodeType && 0 === node.nodeValue.length) node = node.nextSibling;
                if (node && "SPAN" === node.nodeName) clonedSpan = node.cloneNode(false);
            }
            editor.getDoc().execCommand(isDelete ? "ForwardDelete" : "Delete", false, null);
            blockElm = dom.getParent(rng.startContainer, dom.isBlock);
            tinymce.each(dom.select("span.Apple-style-span,font.Apple-style-span", blockElm), function(span) {
                var bm = selection.getBookmark();
                if (clonedSpan) dom.replace(clonedSpan.cloneNode(false), span, true); else dom.remove(span, true);
                selection.moveToBookmark(bm);
            });
        }
        editor.onKeyDown.add(function(editor, e) {
            var isDelete;
            isDelete = e.keyCode == DELETE;
            if (!e.isDefaultPrevented() && (isDelete || e.keyCode == BACKSPACE) && !VK.modifierPressed(e)) {
                e.preventDefault();
                removeMergedFormatSpans(isDelete);
            }
        });
        editor.addCommand("Delete", function() {
            removeMergedFormatSpans();
        });
    }
    function emptyEditorWhenDeleting() {
        function serializeRng(rng) {
            var body = dom.create("body");
            var contents = rng.cloneContents();
            body.appendChild(contents);
            return selection.serializer.serialize(body, {
                format: "html"
            });
        }
        function allContentsSelected(rng) {
            var selection = serializeRng(rng);
            var allRng = dom.createRng();
            allRng.selectNode(editor.getBody());
            var allSelection = serializeRng(allRng);
            return selection === allSelection;
        }
        editor.onKeyDown.add(function(editor, e) {
            var keyCode = e.keyCode, isCollapsed;
            if (!e.isDefaultPrevented() && (keyCode == DELETE || keyCode == BACKSPACE)) {
                isCollapsed = editor.selection.isCollapsed();
                if (isCollapsed && !dom.isEmpty(editor.getBody())) return;
                if (tinymce.isIE && !isCollapsed) return;
                if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) return;
                editor.setContent("");
                editor.selection.setCursorLocation(editor.getBody(), 0);
                editor.nodeChanged();
            }
        });
    }
    function selectAll() {
        editor.onKeyDown.add(function(editor, e) {
            if (65 == e.keyCode && VK.metaKeyPressed(e)) {
                e.preventDefault();
                editor.execCommand("SelectAll");
            }
        });
    }
    function inputMethodFocus() {
        if (!editor.settings.content_editable) {
            dom.bind(editor.getDoc(), "focusin", function(e) {
                selection.setRng(selection.getRng());
            });
            dom.bind(editor.getDoc(), "mousedown", function(e) {
                if (e.target == editor.getDoc().documentElement) {
                    editor.getWin().focus();
                    selection.setRng(selection.getRng());
                }
            });
        }
    }
    function removeHrOnBackspace() {
        editor.onKeyDown.add(function(editor, e) {
            if (!e.isDefaultPrevented() && e.keyCode === BACKSPACE) if (selection.isCollapsed() && 0 === selection.getRng(true).startOffset) {
                var node = selection.getNode();
                var previousSibling = node.previousSibling;
                if (previousSibling && previousSibling.nodeName && "hr" === previousSibling.nodeName.toLowerCase()) {
                    dom.remove(previousSibling);
                    tinymce.dom.Event.cancel(e);
                }
            }
        });
    }
    function focusBody() {
        if (!Range.prototype.getClientRects) editor.onMouseDown.add(function(editor, e) {
            if ("HTML" === e.target.nodeName) {
                var body = editor.getBody();
                body.blur();
                setTimeout(function() {
                    body.focus();
                }, 0);
            }
        });
    }
    function selectControlElements() {
        editor.onClick.add(function(editor, e) {
            e = e.target;
            if (/^(IMG|HR)$/.test(e.nodeName)) selection.getSel().setBaseAndExtent(e, 0, e, 1);
            if ("A" == e.nodeName && dom.hasClass(e, "mceItemAnchor")) selection.select(e);
            editor.nodeChanged();
        });
    }
    function removeStylesWhenDeletingAccrossBlockElements() {
        function getAttributeApplyFunction() {
            var template = dom.getAttribs(selection.getStart().cloneNode(false));
            return function() {
                var target = selection.getStart();
                if (target !== editor.getBody()) {
                    dom.setAttrib(target, "style", null);
                    tinymce.each(template, function(attr) {
                        target.setAttributeNode(attr.cloneNode(true));
                    });
                }
            };
        }
        function isSelectionAcrossElements() {
            return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) != dom.getParent(selection.getEnd(), dom.isBlock);
        }
        function blockEvent(editor, e) {
            e.preventDefault();
            return false;
        }
        editor.onKeyPress.add(function(editor, e) {
            var applyAttributes;
            if ((8 == e.keyCode || 46 == e.keyCode) && isSelectionAcrossElements()) {
                applyAttributes = getAttributeApplyFunction();
                editor.getDoc().execCommand("delete", false, null);
                applyAttributes();
                e.preventDefault();
                return false;
            }
        });
        dom.bind(editor.getDoc(), "cut", function(e) {
            var applyAttributes;
            if (isSelectionAcrossElements()) {
                applyAttributes = getAttributeApplyFunction();
                editor.onKeyUp.addToTop(blockEvent);
                setTimeout(function() {
                    applyAttributes();
                    editor.onKeyUp.remove(blockEvent);
                }, 0);
            }
        });
    }
    function selectionChangeNodeChanged() {
        var lastRng, selectionTimer;
        dom.bind(editor.getDoc(), "selectionchange", function() {
            if (selectionTimer) {
                clearTimeout(selectionTimer);
                selectionTimer = 0;
            }
            selectionTimer = window.setTimeout(function() {
                var rng = selection.getRng();
                if (!lastRng || !tinymce.dom.RangeUtils.compareRanges(rng, lastRng)) {
                    editor.nodeChanged();
                    lastRng = rng;
                }
            }, 50);
        });
    }
    function ensureBodyHasRoleApplication() {
        document.body.setAttribute("role", "application");
    }
    function disableBackspaceIntoATable() {
        editor.onKeyDown.add(function(editor, e) {
            if (!e.isDefaultPrevented() && e.keyCode === BACKSPACE) if (selection.isCollapsed() && 0 === selection.getRng(true).startOffset) {
                var previousSibling = selection.getNode().previousSibling;
                if (previousSibling && previousSibling.nodeName && "table" === previousSibling.nodeName.toLowerCase()) return tinymce.dom.Event.cancel(e);
            }
        });
    }
    function addNewLinesBeforeBrInPre() {
        if (getDocumentMode() > 7) return;
        setEditorCommandState("RespectVisibilityInDesign", true);
        editor.contentStyles.push(".mceHideBrInPre pre br {display: none}");
        dom.addClass(editor.getBody(), "mceHideBrInPre");
        parser.addNodeFilter("pre", function(nodes, name) {
            var i = nodes.length, brNodes, j, brElm, sibling;
            while (i--) {
                brNodes = nodes[i].getAll("br");
                j = brNodes.length;
                while (j--) {
                    brElm = brNodes[j];
                    sibling = brElm.prev;
                    if (sibling && 3 === sibling.type && "\n" != sibling.value.charAt(sibling.value - 1)) sibling.value += "\n"; else brElm.parent.insert(new tinymce.html.Node("#text", 3), brElm, true).value = "\n";
                }
            }
        });
        serializer.addNodeFilter("pre", function(nodes, name) {
            var i = nodes.length, brNodes, j, brElm, sibling;
            while (i--) {
                brNodes = nodes[i].getAll("br");
                j = brNodes.length;
                while (j--) {
                    brElm = brNodes[j];
                    sibling = brElm.prev;
                    if (sibling && 3 == sibling.type) sibling.value = sibling.value.replace(/\r?\n$/, "");
                }
            }
        });
    }
    function removePreSerializedStylesWhenSelectingControls() {
        dom.bind(editor.getBody(), "mouseup", function(e) {
            var value, node = selection.getNode();
            if ("IMG" == node.nodeName) {
                if (value = dom.getStyle(node, "width")) {
                    dom.setAttrib(node, "width", value.replace(/[^0-9%]+/g, ""));
                    dom.setStyle(node, "width", "");
                }
                if (value = dom.getStyle(node, "height")) {
                    dom.setAttrib(node, "height", value.replace(/[^0-9%]+/g, ""));
                    dom.setStyle(node, "height", "");
                }
            }
        });
    }
    function keepInlineElementOnDeleteBackspace() {
        editor.onKeyDown.add(function(editor, e) {
            var isDelete, rng, container, offset, brElm, sibling, collapsed;
            isDelete = e.keyCode == DELETE;
            if (!e.isDefaultPrevented() && (isDelete || e.keyCode == BACKSPACE) && !VK.modifierPressed(e)) {
                rng = selection.getRng();
                container = rng.startContainer;
                offset = rng.startOffset;
                collapsed = rng.collapsed;
                if (3 == container.nodeType && container.nodeValue.length > 0 && (0 === offset && !collapsed || collapsed && offset === (isDelete ? 0 : 1))) {
                    nonEmptyElements = editor.schema.getNonEmptyElements();
                    e.preventDefault();
                    brElm = dom.create("br", {
                        id: "__tmp"
                    });
                    container.parentNode.insertBefore(brElm, container);
                    editor.getDoc().execCommand(isDelete ? "ForwardDelete" : "Delete", false, null);
                    container = selection.getRng().startContainer;
                    sibling = container.previousSibling;
                    if (sibling && 1 == sibling.nodeType && !dom.isBlock(sibling) && dom.isEmpty(sibling) && !nonEmptyElements[sibling.nodeName.toLowerCase()]) dom.remove(sibling);
                    dom.remove("__tmp");
                }
            }
        });
    }
    function removeBlockQuoteOnBackSpace() {
        editor.onKeyDown.add(function(editor, e) {
            var rng, container, offset, root, parent;
            if (e.isDefaultPrevented() || e.keyCode != VK.BACKSPACE) return;
            rng = selection.getRng();
            container = rng.startContainer;
            offset = rng.startOffset;
            root = dom.getRoot();
            parent = container;
            if (!rng.collapsed || 0 !== offset) return;
            while (parent && parent.parentNode && parent.parentNode.firstChild == parent && parent.parentNode != root) parent = parent.parentNode;
            if ("BLOCKQUOTE" === parent.tagName) {
                editor.formatter.toggle("blockquote", null, parent);
                rng = dom.createRng();
                rng.setStart(container, 0);
                rng.setEnd(container, 0);
                selection.setRng(rng);
            }
        });
    }
    function setGeckoEditingOptions() {
        function setOpts() {
            editor._refreshContentEditable();
            setEditorCommandState("StyleWithCSS", false);
            setEditorCommandState("enableInlineTableEditing", false);
            if (!settings.object_resizing) setEditorCommandState("enableObjectResizing", false);
        }
        if (!settings.readonly) {
            editor.onBeforeExecCommand.add(setOpts);
            editor.onMouseDown.add(setOpts);
        }
    }
    function addBrAfterLastLinks() {
        function fixLinks(editor, o) {
            tinymce.each(dom.select("a"), function(node) {
                var parentNode = node.parentNode, root = dom.getRoot();
                if (parentNode.lastChild === node) {
                    while (parentNode && !dom.isBlock(parentNode)) {
                        if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) return;
                        parentNode = parentNode.parentNode;
                    }
                    dom.add(parentNode, "br", {
                        "data-mce-bogus": 1
                    });
                }
            });
        }
        editor.onExecCommand.add(function(editor, cmd) {
            if ("CreateLink" === cmd) fixLinks(editor);
        });
        editor.onSetContent.add(selection.onSetContent.add(fixLinks));
    }
    function setDefaultBlockType() {
        if (settings.forced_root_block) editor.onInit.add(function() {
            setEditorCommandState("DefaultParagraphSeparator", settings.forced_root_block);
        });
    }
    function removeGhostSelection() {
        function repaint(sender, args) {
            if (!sender || !args.initial) editor.execCommand("mceRepaint");
        }
        editor.onUndo.add(repaint);
        editor.onRedo.add(repaint);
        editor.onSetContent.add(repaint);
    }
    function deleteControlItemOnBackSpace() {
        editor.onKeyDown.add(function(editor, e) {
            var rng;
            if (!e.isDefaultPrevented() && e.keyCode == BACKSPACE) {
                rng = editor.getDoc().selection.createRange();
                if (rng && rng.item) {
                    e.preventDefault();
                    editor.undoManager.beforeChange();
                    dom.remove(rng.item(0));
                    editor.undoManager.add();
                }
            }
        });
    }
    function renderEmptyBlocksFix() {
        var emptyBlocksCSS;
        if (getDocumentMode() >= 10) {
            emptyBlocksCSS = "";
            tinymce.each("p div h1 h2 h3 h4 h5 h6".split(" "), function(name, i) {
                emptyBlocksCSS += (i > 0 ? "," : "") + name + ":empty";
            });
            editor.contentStyles.push(emptyBlocksCSS + "{padding-right: 1px !important}");
        }
    }
    function fakeImageResize() {
        var selectedElmX, selectedElmY, selectedElm, selectedElmGhost, selectedHandle, startX, startY, startW, startH, ratio, resizeHandles, width, height, rootDocument = document, editableDoc = editor.getDoc();
        if (!settings.object_resizing || false === settings.webkit_fake_resize) return;
        setEditorCommandState("enableObjectResizing", false);
        resizeHandles = {
            n: [ .5, 0, 0, -1 ],
            e: [ 1, .5, 1, 0 ],
            s: [ .5, 1, 0, 1 ],
            w: [ 0, .5, -1, 0 ],
            nw: [ 0, 0, -1, -1 ],
            ne: [ 1, 0, 1, -1 ],
            se: [ 1, 1, 1, 1 ],
            sw: [ 0, 1, -1, 1 ]
        };
        function resizeElement(e) {
            var deltaX, deltaY;
            deltaX = e.screenX - startX;
            deltaY = e.screenY - startY;
            width = deltaX * selectedHandle[2] + startW;
            height = deltaY * selectedHandle[3] + startH;
            width = width < 5 ? 5 : width;
            height = height < 5 ? 5 : height;
            if (VK.modifierPressed(e) || "IMG" == selectedElm.nodeName && 0 !== selectedHandle[2] * selectedHandle[3]) {
                width = Math.round(height / ratio);
                height = Math.round(width * ratio);
            }
            dom.setStyles(selectedElmGhost, {
                width: width,
                height: height
            });
            if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) dom.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width));
            if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) dom.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height));
        }
        function endResize() {
            function setSizeProp(name, value) {
                if (value) if (selectedElm.style[name] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name)) dom.setStyle(selectedElm, name, value); else dom.setAttrib(selectedElm, name, value);
            }
            setSizeProp("width", width);
            setSizeProp("height", height);
            dom.unbind(editableDoc, "mousemove", resizeElement);
            dom.unbind(editableDoc, "mouseup", endResize);
            if (rootDocument != editableDoc) {
                dom.unbind(rootDocument, "mousemove", resizeElement);
                dom.unbind(rootDocument, "mouseup", endResize);
            }
            dom.remove(selectedElmGhost);
            showResizeRect(selectedElm);
        }
        function showResizeRect(targetElm) {
            var position, targetWidth, targetHeight;
            hideResizeRect();
            position = dom.getPos(targetElm);
            selectedElmX = position.x;
            selectedElmY = position.y;
            targetWidth = targetElm.offsetWidth;
            targetHeight = targetElm.offsetHeight;
            if (selectedElm != targetElm) {
                selectedElm = targetElm;
                width = height = 0;
            }
            tinymce.each(resizeHandles, function(handle, name) {
                var handleElm;
                handleElm = dom.get("mceResizeHandle" + name);
                if (!handleElm) {
                    handleElm = dom.add(editableDoc.documentElement, "div", {
                        id: "mceResizeHandle" + name,
                        "class": "mceResizeHandle",
                        style: "cursor:" + name + "-resize; margin:0; padding:0"
                    });
                    dom.bind(handleElm, "mousedown", function(e) {
                        e.preventDefault();
                        endResize();
                        startX = e.screenX;
                        startY = e.screenY;
                        startW = selectedElm.clientWidth;
                        startH = selectedElm.clientHeight;
                        ratio = startH / startW;
                        selectedHandle = handle;
                        selectedElmGhost = selectedElm.cloneNode(true);
                        dom.addClass(selectedElmGhost, "mceClonedResizable");
                        dom.setStyles(selectedElmGhost, {
                            left: selectedElmX,
                            top: selectedElmY,
                            margin: 0
                        });
                        editableDoc.documentElement.appendChild(selectedElmGhost);
                        dom.bind(editableDoc, "mousemove", resizeElement);
                        dom.bind(editableDoc, "mouseup", endResize);
                        if (rootDocument != editableDoc) {
                            dom.bind(rootDocument, "mousemove", resizeElement);
                            dom.bind(rootDocument, "mouseup", endResize);
                        }
                    });
                } else dom.show(handleElm);
                dom.setStyles(handleElm, {
                    left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,
                    top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2
                });
            });
            if (!tinymce.isOpera && "IMG" == selectedElm.nodeName) selectedElm.setAttribute("data-mce-selected", "1");
        }
        function hideResizeRect() {
            if (selectedElm) selectedElm.removeAttribute("data-mce-selected");
            for (var name in resizeHandles) dom.hide("mceResizeHandle" + name);
        }
        editor.contentStyles.push(".mceResizeHandle {" + "position: absolute;" + "border: 1px solid black;" + "background: #FFF;" + "width: 5px;" + "height: 5px;" + "z-index: 10000" + "}" + ".mceResizeHandle:hover {" + "background: #000" + "}" + "img[data-mce-selected] {" + "outline: 1px solid black" + "}" + "img.mceClonedResizable, table.mceClonedResizable {" + "position: absolute;" + "outline: 1px dashed black;" + "opacity: .5;" + "z-index: 10000" + "}");
        function updateResizeRect() {
            var controlElm = dom.getParent(selection.getNode(), "table,img");
            tinymce.each(dom.select("img[data-mce-selected]"), function(img) {
                img.removeAttribute("data-mce-selected");
            });
            if (controlElm) showResizeRect(controlElm); else hideResizeRect();
        }
        editor.onNodeChange.add(updateResizeRect);
        dom.bind(editableDoc, "selectionchange", updateResizeRect);
        editor.serializer.addAttributeFilter("data-mce-selected", function(nodes, name) {
            var i = nodes.length;
            while (i--) nodes[i].attr(name, null);
        });
    }
    function keepNoScriptContents() {
        if (getDocumentMode() < 9) {
            parser.addNodeFilter("noscript", function(nodes) {
                var i = nodes.length, node, textNode;
                while (i--) {
                    node = nodes[i];
                    textNode = node.firstChild;
                    if (textNode) node.attr("data-mce-innertext", textNode.value);
                }
            });
            serializer.addNodeFilter("noscript", function(nodes) {
                var i = nodes.length, node, textNode, value;
                while (i--) {
                    node = nodes[i];
                    textNode = nodes[i].firstChild;
                    if (textNode) textNode.value = tinymce.html.Entities.decode(textNode.value); else {
                        value = node.attributes.map["data-mce-innertext"];
                        if (value) {
                            node.attr("data-mce-innertext", null);
                            textNode = new tinymce.html.Node("#text", 3);
                            textNode.value = value;
                            textNode.raw = true;
                            node.append(textNode);
                        }
                    }
                }
            });
        }
    }
    disableBackspaceIntoATable();
    removeBlockQuoteOnBackSpace();
    emptyEditorWhenDeleting();
    if (tinymce.isWebKit) {
        keepInlineElementOnDeleteBackspace();
        cleanupStylesWhenDeleting();
        inputMethodFocus();
        selectControlElements();
        setDefaultBlockType();
        if (tinymce.isIDevice) selectionChangeNodeChanged(); else {
            fakeImageResize();
            selectAll();
        }
    }
    if (tinymce.isIE) {
        removeHrOnBackspace();
        ensureBodyHasRoleApplication();
        addNewLinesBeforeBrInPre();
        removePreSerializedStylesWhenSelectingControls();
        deleteControlItemOnBackSpace();
        renderEmptyBlocksFix();
        keepNoScriptContents();
    }
    if (tinymce.isGecko) {
        removeHrOnBackspace();
        focusBody();
        removeStylesWhenDeletingAccrossBlockElements();
        setGeckoEditingOptions();
        addBrAfterLastLinks();
        removeGhostSelection();
    }
    if (tinymce.isOpera) fakeImageResize();
};

(function(tinymce) {
    var namedEntities, baseEntities, reverseEntities, attrsCharsRegExp = /[&<>\"\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, rawCharsRegExp = /[<>&\"\']/g, entityRegExp = /&(#x|#)?([\w]+);/g, asciiMap = {
        128: "€",
        130: "‚",
        131: "ƒ",
        132: "„",
        133: "…",
        134: "†",
        135: "‡",
        136: "ˆ",
        137: "‰",
        138: "Š",
        139: "‹",
        140: "Œ",
        142: "Ž",
        145: "‘",
        146: "’",
        147: "“",
        148: "”",
        149: "•",
        150: "–",
        151: "—",
        152: "˜",
        153: "™",
        154: "š",
        155: "›",
        156: "œ",
        158: "ž",
        159: "Ÿ"
    };
    baseEntities = {
        '"': "&quot;",
        "'": "&#39;",
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;"
    };
    reverseEntities = {
        "&lt;": "<",
        "&gt;": ">",
        "&amp;": "&",
        "&quot;": '"',
        "&apos;": "'"
    };
    function nativeDecode(text) {
        var elm;
        elm = document.createElement("div");
        elm.innerHTML = text;
        return elm.textContent || elm.innerText || text;
    }
    function buildEntitiesLookup(items, radix) {
        var i, chr, entity, lookup = {};
        if (items) {
            items = items.split(",");
            radix = radix || 10;
            for (i = 0; i < items.length; i += 2) {
                chr = String.fromCharCode(parseInt(items[i], radix));
                if (!baseEntities[chr]) {
                    entity = "&" + items[i + 1] + ";";
                    lookup[chr] = entity;
                    lookup[entity] = chr;
                }
            }
            return lookup;
        }
    }
    namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy," + "5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute," + "5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34," + "5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil," + "68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde," + "6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute," + "6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml," + "75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc," + "7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash," + "7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta," + "sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu," + "st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi," + "t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota," + "tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau," + "u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip," + "81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym," + "8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr," + "8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod," + "8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup," + "8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4," + "nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob," + "rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0," + "Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm," + "80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger," + "811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
    tinymce.html = tinymce.html || {};
    tinymce.html.Entities = {
        encodeRaw: function(text, attr) {
            return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
                return baseEntities[chr] || chr;
            });
        },
        encodeAllRaw: function(text) {
            return ("" + text).replace(rawCharsRegExp, function(chr) {
                return baseEntities[chr] || chr;
            });
        },
        encodeNumeric: function(text, attr) {
            return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
                if (chr.length > 1) return "&#" + (1024 * (chr.charCodeAt(0) - 55296) + (chr.charCodeAt(1) - 56320) + 65536) + ";";
                return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
            });
        },
        encodeNamed: function(text, attr, entities) {
            entities = entities || namedEntities;
            return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
                return baseEntities[chr] || entities[chr] || chr;
            });
        },
        getEncodeFunc: function(name, entities) {
            var Entities = tinymce.html.Entities;
            entities = buildEntitiesLookup(entities) || namedEntities;
            function encodeNamedAndNumeric(text, attr) {
                return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
                    return baseEntities[chr] || entities[chr] || "&#" + chr.charCodeAt(0) + ";" || chr;
                });
            }
            function encodeCustomNamed(text, attr) {
                return Entities.encodeNamed(text, attr, entities);
            }
            name = tinymce.makeMap(name.replace(/\+/g, ","));
            if (name.named && name.numeric) return encodeNamedAndNumeric;
            if (name.named) {
                if (entities) return encodeCustomNamed;
                return Entities.encodeNamed;
            }
            if (name.numeric) return Entities.encodeNumeric;
            return Entities.encodeRaw;
        },
        decode: function(text) {
            return text.replace(entityRegExp, function(all, numeric, value) {
                if (numeric) {
                    value = parseInt(value, 2 === numeric.length ? 16 : 10);
                    if (value > 65535) {
                        value -= 65536;
                        return String.fromCharCode(55296 + (value >> 10), 56320 + (1023 & value));
                    } else return asciiMap[value] || String.fromCharCode(value);
                }
                return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
            });
        }
    };
})(tinymce);

tinymce.html.Styles = function(settings, schema) {
    var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, styleRegExp = /\s*([^:]+):\s*([^;]+);?/g, trimRightRegExp = /\s+$/, urlColorRegExp = /rgb/, undef, i, encodingLookup = {}, encodingItems;
    settings = settings || {};
    encodingItems = "\\\" \\' \\; \\: ; : ﻿".split(" ");
    for (i = 0; i < encodingItems.length; i++) {
        encodingLookup[encodingItems[i]] = "﻿" + i;
        encodingLookup["﻿" + i] = encodingItems[i];
    }
    function toHex(match, r, g, b) {
        function hex(val) {
            val = parseInt(val).toString(16);
            return val.length > 1 ? val : "0" + val;
        }
        return "#" + hex(r) + hex(g) + hex(b);
    }
    return {
        toHex: function(color) {
            return color.replace(rgbRegExp, toHex);
        },
        parse: function(css) {
            var styles = {}, matches, name, value, isEncoded, urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope || this;
            function compress(prefix, suffix) {
                var top, right, bottom, left;
                top = styles[prefix + "-top" + suffix];
                if (!top) return;
                right = styles[prefix + "-right" + suffix];
                if (top != right) return;
                bottom = styles[prefix + "-bottom" + suffix];
                if (right != bottom) return;
                left = styles[prefix + "-left" + suffix];
                if (bottom != left) return;
                styles[prefix + suffix] = left;
                delete styles[prefix + "-top" + suffix];
                delete styles[prefix + "-right" + suffix];
                delete styles[prefix + "-bottom" + suffix];
                delete styles[prefix + "-left" + suffix];
            }
            function canCompress(key) {
                var value = styles[key], i;
                if (!value || value.indexOf(" ") < 0) return;
                value = value.split(" ");
                i = value.length;
                while (i--) if (value[i] !== value[0]) return false;
                styles[key] = value[0];
                return true;
            }
            function compress2(target, a, b, c) {
                if (!canCompress(a)) return;
                if (!canCompress(b)) return;
                if (!canCompress(c)) return;
                styles[target] = styles[a] + " " + styles[b] + " " + styles[c];
                delete styles[a];
                delete styles[b];
                delete styles[c];
            }
            function encode(str) {
                isEncoded = true;
                return encodingLookup[str];
            }
            function decode(str, keep_slashes) {
                if (isEncoded) str = str.replace(/\uFEFF[0-9]/g, function(str) {
                    return encodingLookup[str];
                });
                if (!keep_slashes) str = str.replace(/\\([\'\";:])/g, "$1");
                return str;
            }
            function processUrl(match, url, url2, url3, str, str2) {
                str = str || str2;
                if (str) {
                    str = decode(str);
                    return "'" + str.replace(/\'/g, "\\'") + "'";
                }
                url = decode(url || url2 || url3);
                if (urlConverter) url = urlConverter.call(urlConverterScope, url, "style");
                return "url('" + url.replace(/\'/g, "\\'") + "')";
            }
            if (css) {
                css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
                    return str.replace(/[;:]/g, encode);
                });
                while (matches = styleRegExp.exec(css)) {
                    name = matches[1].replace(trimRightRegExp, "").toLowerCase();
                    value = matches[2].replace(trimRightRegExp, "");
                    if (name && value.length > 0) {
                        if ("font-weight" === name && "700" === value) value = "bold"; else if ("color" === name || "background-color" === name) value = value.toLowerCase();
                        value = value.replace(rgbRegExp, toHex);
                        value = value.replace(urlOrStrRegExp, processUrl);
                        styles[name] = isEncoded ? decode(value, true) : value;
                    }
                    styleRegExp.lastIndex = matches.index + matches[0].length;
                }
                compress("border", "");
                compress("border", "-width");
                compress("border", "-color");
                compress("border", "-style");
                compress("padding", "");
                compress("margin", "");
                compress2("border", "border-width", "border-style", "border-color");
                if ("medium none" === styles.border) delete styles.border;
            }
            return styles;
        },
        serialize: function(styles, element_name) {
            var css = "", name, value;
            function serializeStyles(name) {
                var styleList, i, l, value;
                styleList = schema.styles[name];
                if (styleList) for (i = 0, l = styleList.length; i < l; i++) {
                    name = styleList[i];
                    value = styles[name];
                    if (value !== undef && value.length > 0) css += (css.length > 0 ? " " : "") + name + ": " + value + ";";
                }
            }
            if (element_name && schema && schema.styles) {
                serializeStyles("*");
                serializeStyles(element_name);
            } else for (name in styles) {
                value = styles[name];
                if (value !== undef && value.length > 0) css += (css.length > 0 ? " " : "") + name + ": " + value + ";";
            }
            return css;
        }
    };
};

(function(tinymce) {
    var mapCache = {}, makeMap = tinymce.makeMap, each = tinymce.each;
    function split(str, delim) {
        return str.split(delim || ",");
    }
    function unpack(lookup, data) {
        var key, elements = {};
        function replace(value) {
            return value.replace(/[A-Z]+/g, function(key) {
                return replace(lookup[key]);
            });
        }
        for (key in lookup) if (lookup.hasOwnProperty(key)) lookup[key] = replace(lookup[key]);
        replace(data).replace(/#/g, "#text").replace(/(\w+)\[([^\]]+)\]\[([^\]]*)\]/g, function(str, name, attributes, children) {
            attributes = split(attributes, "|");
            elements[name] = {
                attributes: makeMap(attributes),
                attributesOrder: attributes,
                children: makeMap(children, "|", {
                    "#comment": {}
                })
            };
        });
        return elements;
    }
    function getHTML5() {
        var html5 = mapCache.html5;
        if (!html5) html5 = mapCache.html5 = unpack({
            A: "id|accesskey|class|dir|draggable|item|hidden|itemprop|role|spellcheck|style|subject|title|onclick|ondblclick|onmousedown|onmouseup|onmouseover|onmousemove|onmouseout|onkeypress|onkeydown|onkeyup",
            B: "#|a|abbr|area|audio|b|bdo|br|button|canvas|cite|code|command|datalist|del|dfn|em|embed|i|iframe|img|input|ins|kbd|keygen|label|link|map|mark|meta|" + "meter|noscript|object|output|progress|q|ruby|samp|script|select|small|span|strong|sub|sup|svg|textarea|time|var|video|wbr",
            C: "#|a|abbr|area|address|article|aside|audio|b|bdo|blockquote|br|button|canvas|cite|code|command|datalist|del|details|dfn|dialog|div|dl|em|embed|fieldset|" + "figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|i|iframe|img|input|ins|kbd|keygen|label|link|map|mark|menu|meta|meter|nav|noscript|ol|object|output|" + "p|pre|progress|q|ruby|samp|script|section|select|small|span|strong|style|sub|sup|svg|table|textarea|time|ul|var|video"
        }, "html[A|manifest][body|head]" + "head[A][base|command|link|meta|noscript|script|style|title]" + "title[A][#]" + "base[A|href|target][]" + "link[A|href|rel|media|type|sizes][]" + "meta[A|http-equiv|name|content|charset][]" + "style[A|type|media|scoped][#]" + "script[A|charset|type|src|defer|async][#]" + "noscript[A][C]" + "body[A][C]" + "section[A][C]" + "nav[A][C]" + "article[A][C]" + "aside[A][C]" + "h1[A][B]" + "h2[A][B]" + "h3[A][B]" + "h4[A][B]" + "h5[A][B]" + "h6[A][B]" + "hgroup[A][h1|h2|h3|h4|h5|h6]" + "header[A][C]" + "footer[A][C]" + "address[A][C]" + "p[A][B]" + "br[A][]" + "pre[A][B]" + "dialog[A][dd|dt]" + "blockquote[A|cite][C]" + "ol[A|start|reversed][li]" + "ul[A][li]" + "li[A|value][C]" + "dl[A][dd|dt]" + "dt[A][B]" + "dd[A][C]" + "a[A|href|target|ping|rel|media|type][B]" + "em[A][B]" + "strong[A][B]" + "small[A][B]" + "cite[A][B]" + "q[A|cite][B]" + "dfn[A][B]" + "abbr[A][B]" + "code[A][B]" + "var[A][B]" + "samp[A][B]" + "kbd[A][B]" + "sub[A][B]" + "sup[A][B]" + "i[A][B]" + "b[A][B]" + "mark[A][B]" + "progress[A|value|max][B]" + "meter[A|value|min|max|low|high|optimum][B]" + "time[A|datetime][B]" + "ruby[A][B|rt|rp]" + "rt[A][B]" + "rp[A][B]" + "bdo[A][B]" + "span[A][B]" + "ins[A|cite|datetime][B]" + "del[A|cite|datetime][B]" + "figure[A][C|legend|figcaption]" + "figcaption[A][C]" + "img[A|alt|src|height|width|usemap|ismap][]" + "iframe[A|name|src|height|width|sandbox|seamless][]" + "embed[A|src|height|width|type][]" + "object[A|data|type|height|width|usemap|name|form|classid][param]" + "param[A|name|value][]" + "details[A|open][C|legend]" + "command[A|type|label|icon|disabled|checked|radiogroup][]" + "menu[A|type|label][C|li]" + "legend[A][C|B]" + "div[A][C]" + "source[A|src|type|media][]" + "audio[A|src|autobuffer|autoplay|loop|controls][source]" + "video[A|src|autobuffer|autoplay|loop|controls|width|height|poster][source]" + "hr[A][]" + "form[A|accept-charset|action|autocomplete|enctype|method|name|novalidate|target][C]" + "fieldset[A|disabled|form|name][C|legend]" + "label[A|form|for][B]" + "input[A|type|accept|alt|autocomplete|checked|disabled|form|formaction|formenctype|formmethod|formnovalidate|formtarget|height|list|max|maxlength|min|" + "multiple|pattern|placeholder|readonly|required|size|src|step|width|files|value|name][]" + "button[A|autofocus|disabled|form|formaction|formenctype|formmethod|formnovalidate|formtarget|name|value|type][B]" + "select[A|autofocus|disabled|form|multiple|name|size][option|optgroup]" + "datalist[A][B|option]" + "optgroup[A|disabled|label][option]" + "option[A|disabled|selected|label|value][]" + "textarea[A|autofocus|disabled|form|maxlength|name|placeholder|readonly|required|rows|cols|wrap][]" + "keygen[A|autofocus|challenge|disabled|form|keytype|name][]" + "output[A|for|form|name][B]" + "canvas[A|width|height][]" + "map[A|name][B|C]" + "area[A|shape|coords|href|alt|target|media|rel|ping|type][]" + "mathml[A][]" + "svg[A][]" + "table[A|border][caption|colgroup|thead|tfoot|tbody|tr]" + "caption[A][C]" + "colgroup[A|span][col]" + "col[A|span][]" + "thead[A][tr]" + "tfoot[A][tr]" + "tbody[A][tr]" + "tr[A][th|td]" + "th[A|headers|rowspan|colspan|scope][B]" + "td[A|headers|rowspan|colspan][C]" + "wbr[A][]");
        return html5;
    }
    function getHTML4() {
        var html4 = mapCache.html4;
        if (!html4) html4 = mapCache.html4 = unpack({
            Z: "H|K|N|O|P",
            Y: "X|form|R|Q",
            ZG: "E|span|width|align|char|charoff|valign",
            X: "p|T|div|U|W|isindex|fieldset|table",
            ZF: "E|align|char|charoff|valign",
            W: "pre|hr|blockquote|address|center|noframes",
            ZE: "abbr|axis|headers|scope|rowspan|colspan|align|char|charoff|valign|nowrap|bgcolor|width|height",
            ZD: "[E][S]",
            U: "ul|ol|dl|menu|dir",
            ZC: "p|Y|div|U|W|table|br|span|bdo|object|applet|img|map|K|N|Q",
            T: "h1|h2|h3|h4|h5|h6",
            ZB: "X|S|Q",
            S: "R|P",
            ZA: "a|G|J|M|O|P",
            R: "a|H|K|N|O",
            Q: "noscript|P",
            P: "ins|del|script",
            O: "input|select|textarea|label|button",
            N: "M|L",
            M: "em|strong|dfn|code|q|samp|kbd|var|cite|abbr|acronym",
            L: "sub|sup",
            K: "J|I",
            J: "tt|i|b|u|s|strike",
            I: "big|small|font|basefont",
            H: "G|F",
            G: "br|span|bdo",
            F: "object|applet|img|map|iframe",
            E: "A|B|C",
            D: "accesskey|tabindex|onfocus|onblur",
            C: "onclick|ondblclick|onmousedown|onmouseup|onmouseover|onmousemove|onmouseout|onkeypress|onkeydown|onkeyup",
            B: "lang|xml:lang|dir",
            A: "id|class|style|title"
        }, "script[id|charset|type|language|src|defer|xml:space][]" + "style[B|id|type|media|title|xml:space][]" + "object[E|declare|classid|codebase|data|type|codetype|archive|standby|width|height|usemap|name|tabindex|align|border|hspace|vspace][#|param|Y]" + "param[id|name|value|valuetype|type][]" + "p[E|align][#|S]" + "a[E|D|charset|type|name|href|hreflang|rel|rev|shape|coords|target][#|Z]" + "br[A|clear][]" + "span[E][#|S]" + "bdo[A|C|B][#|S]" + "applet[A|codebase|archive|code|object|alt|name|width|height|align|hspace|vspace][#|param|Y]" + "h1[E|align][#|S]" + "img[E|src|alt|name|longdesc|width|height|usemap|ismap|align|border|hspace|vspace][]" + "map[B|C|A|name][X|form|Q|area]" + "h2[E|align][#|S]" + "iframe[A|longdesc|name|src|frameborder|marginwidth|marginheight|scrolling|align|width|height][#|Y]" + "h3[E|align][#|S]" + "tt[E][#|S]" + "i[E][#|S]" + "b[E][#|S]" + "u[E][#|S]" + "s[E][#|S]" + "strike[E][#|S]" + "big[E][#|S]" + "small[E][#|S]" + "font[A|B|size|color|face][#|S]" + "basefont[id|size|color|face][]" + "em[E][#|S]" + "strong[E][#|S]" + "dfn[E][#|S]" + "code[E][#|S]" + "q[E|cite][#|S]" + "samp[E][#|S]" + "kbd[E][#|S]" + "var[E][#|S]" + "cite[E][#|S]" + "abbr[E][#|S]" + "acronym[E][#|S]" + "sub[E][#|S]" + "sup[E][#|S]" + "input[E|D|type|name|value|checked|disabled|readonly|size|maxlength|src|alt|usemap|onselect|onchange|accept|align][]" + "select[E|name|size|multiple|disabled|tabindex|onfocus|onblur|onchange][optgroup|option]" + "optgroup[E|disabled|label][option]" + "option[E|selected|disabled|label|value][]" + "textarea[E|D|name|rows|cols|disabled|readonly|onselect|onchange][]" + "label[E|for|accesskey|onfocus|onblur][#|S]" + "button[E|D|name|value|type|disabled][#|p|T|div|U|W|table|G|object|applet|img|map|K|N|Q]" + "h4[E|align][#|S]" + "ins[E|cite|datetime][#|Y]" + "h5[E|align][#|S]" + "del[E|cite|datetime][#|Y]" + "h6[E|align][#|S]" + "div[E|align][#|Y]" + "ul[E|type|compact][li]" + "li[E|type|value][#|Y]" + "ol[E|type|compact|start][li]" + "dl[E|compact][dt|dd]" + "dt[E][#|S]" + "dd[E][#|Y]" + "menu[E|compact][li]" + "dir[E|compact][li]" + "pre[E|width|xml:space][#|ZA]" + "hr[E|align|noshade|size|width][]" + "blockquote[E|cite][#|Y]" + "address[E][#|S|p]" + "center[E][#|Y]" + "noframes[E][#|Y]" + "isindex[A|B|prompt][]" + "fieldset[E][#|legend|Y]" + "legend[E|accesskey|align][#|S]" + "table[E|summary|width|border|frame|rules|cellspacing|cellpadding|align|bgcolor][caption|col|colgroup|thead|tfoot|tbody|tr]" + "caption[E|align][#|S]" + "col[ZG][]" + "colgroup[ZG][col]" + "thead[ZF][tr]" + "tr[ZF|bgcolor][th|td]" + "th[E|ZE][#|Y]" + "form[E|action|method|name|enctype|onsubmit|onreset|accept|accept-charset|target][#|X|R|Q]" + "noscript[E][#|Y]" + "td[E|ZE][#|Y]" + "tfoot[ZF][tr]" + "tbody[ZF][tr]" + "area[E|D|shape|coords|href|nohref|alt|target][]" + "base[id|href|target][]" + "body[E|onload|onunload|background|bgcolor|text|link|vlink|alink][#|Y]");
        return html4;
    }
    tinymce.html.Schema = function(settings) {
        var self = this, elements = {}, children = {}, patternElements = [], validStyles, schemaItems;
        var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, blockElementsMap, nonEmptyElementsMap, customElementsMap = {};
        function createLookupTable(option, default_value, extend) {
            var value = settings[option];
            if (!value) {
                value = mapCache[option];
                if (!value) {
                    value = makeMap(default_value, " ", makeMap(default_value.toUpperCase(), " "));
                    value = tinymce.extend(value, extend);
                    mapCache[option] = value;
                }
            } else value = makeMap(value, ",", makeMap(value.toUpperCase(), " "));
            return value;
        }
        settings = settings || {};
        schemaItems = "html5" == settings.schema ? getHTML5() : getHTML4();
        if (false === settings.verify_html) settings.valid_elements = "*[*]";
        if (settings.valid_styles) {
            validStyles = {};
            each(settings.valid_styles, function(value, key) {
                validStyles[key] = tinymce.explode(value);
            });
        }
        whiteSpaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea");
        selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
        shortEndedElementsMap = createLookupTable("short_ended_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr");
        boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls");
        nonEmptyElementsMap = createLookupTable("non_empty_elements", "td th iframe video audio object", shortEndedElementsMap);
        textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form " + "blockquote center dir fieldset header footer article section hgroup aside nav figure");
        blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot " + "th tr td li ol ul caption dl dt dd noscript menu isindex samp option datalist select optgroup", textBlockElementsMap);
        function patternToRegExp(str) {
            return new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
        }
        function addValidElements(valid_elements) {
            var ei, el, ai, al, yl, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, transElement, key, childKey, value, elementRuleRegExp = /^([#+\-])?([^\[\/]+)(?:\/([^\[]+))?(?:\[([^\]]+)\])?$/, attrRuleRegExp = /^([!\-])?(\w+::\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
            if (valid_elements) {
                valid_elements = split(valid_elements);
                if (elements["@"]) {
                    globalAttributes = elements["@"].attributes;
                    globalAttributesOrder = elements["@"].attributesOrder;
                }
                for (ei = 0, el = valid_elements.length; ei < el; ei++) {
                    matches = elementRuleRegExp.exec(valid_elements[ei]);
                    if (matches) {
                        prefix = matches[1];
                        elementName = matches[2];
                        outputName = matches[3];
                        attrData = matches[4];
                        attributes = {};
                        attributesOrder = [];
                        element = {
                            attributes: attributes,
                            attributesOrder: attributesOrder
                        };
                        if ("#" === prefix) element.paddEmpty = true;
                        if ("-" === prefix) element.removeEmpty = true;
                        if (globalAttributes) {
                            for (key in globalAttributes) attributes[key] = globalAttributes[key];
                            attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
                        }
                        if (attrData) {
                            attrData = split(attrData, "|");
                            for (ai = 0, al = attrData.length; ai < al; ai++) {
                                matches = attrRuleRegExp.exec(attrData[ai]);
                                if (matches) {
                                    attr = {};
                                    attrType = matches[1];
                                    attrName = matches[2].replace(/::/g, ":");
                                    prefix = matches[3];
                                    value = matches[4];
                                    if ("!" === attrType) {
                                        element.attributesRequired = element.attributesRequired || [];
                                        element.attributesRequired.push(attrName);
                                        attr.required = true;
                                    }
                                    if ("-" === attrType) {
                                        delete attributes[attrName];
                                        attributesOrder.splice(tinymce.inArray(attributesOrder, attrName), 1);
                                        continue;
                                    }
                                    if (prefix) {
                                        if ("=" === prefix) {
                                            element.attributesDefault = element.attributesDefault || [];
                                            element.attributesDefault.push({
                                                name: attrName,
                                                value: value
                                            });
                                            attr.defaultValue = value;
                                        }
                                        if (":" === prefix) {
                                            element.attributesForced = element.attributesForced || [];
                                            element.attributesForced.push({
                                                name: attrName,
                                                value: value
                                            });
                                            attr.forcedValue = value;
                                        }
                                        if ("<" === prefix) attr.validValues = makeMap(value, "?");
                                    }
                                    if (hasPatternsRegExp.test(attrName)) {
                                        element.attributePatterns = element.attributePatterns || [];
                                        attr.pattern = patternToRegExp(attrName);
                                        element.attributePatterns.push(attr);
                                    } else {
                                        if (!attributes[attrName]) attributesOrder.push(attrName);
                                        attributes[attrName] = attr;
                                    }
                                }
                            }
                        }
                        if (!globalAttributes && "@" == elementName) {
                            globalAttributes = attributes;
                            globalAttributesOrder = attributesOrder;
                        }
                        if (outputName) {
                            element.outputName = elementName;
                            elements[outputName] = element;
                        }
                        if (hasPatternsRegExp.test(elementName)) {
                            element.pattern = patternToRegExp(elementName);
                            patternElements.push(element);
                        } else elements[elementName] = element;
                    }
                }
            }
        }
        function setValidElements(valid_elements) {
            elements = {};
            patternElements = [];
            addValidElements(valid_elements);
            each(schemaItems, function(element, name) {
                children[name] = element.children;
            });
        }
        function addCustomElements(custom_elements) {
            var customElementRegExp = /^(~)?(.+)$/;
            if (custom_elements) each(split(custom_elements), function(rule) {
                var matches = customElementRegExp.exec(rule), inline = "~" === matches[1], cloneName = inline ? "span" : "div", name = matches[2];
                children[name] = children[cloneName];
                customElementsMap[name] = cloneName;
                if (!inline) blockElementsMap[name] = {};
                each(children, function(element, child) {
                    if (element[cloneName]) element[name] = element[cloneName];
                });
            });
        }
        function addValidChildren(valid_children) {
            var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
            if (valid_children) each(split(valid_children), function(rule) {
                var matches = childRuleRegExp.exec(rule), parent, prefix;
                if (matches) {
                    prefix = matches[1];
                    if (prefix) parent = children[matches[2]]; else parent = children[matches[2]] = {
                        "#comment": {}
                    };
                    parent = children[matches[2]];
                    each(split(matches[3], "|"), function(child) {
                        if ("-" === prefix) delete parent[child]; else parent[child] = {};
                    });
                }
            });
        }
        function getElementRule(name) {
            var element = elements[name], i;
            if (element) return element;
            i = patternElements.length;
            while (i--) {
                element = patternElements[i];
                if (element.pattern.test(name)) return element;
            }
        }
        if (!settings.valid_elements) {
            each(schemaItems, function(element, name) {
                elements[name] = {
                    attributes: element.attributes,
                    attributesOrder: element.attributesOrder
                };
                children[name] = element.children;
            });
            if ("html5" != settings.schema) each(split("strong/b,em/i"), function(item) {
                item = split(item, "/");
                elements[item[1]].outputName = item[0];
            });
            elements.img.attributesDefault = [ {
                name: "alt",
                value: ""
            } ];
            each(split("ol,ul,sub,sup,blockquote,span,font,a,table,tbody,tr,strong,em,b,i"), function(name) {
                if (elements[name]) elements[name].removeEmpty = true;
            });
            each(split("p,h1,h2,h3,h4,h5,h6,th,td,pre,div,address,caption"), function(name) {
                elements[name].paddEmpty = true;
            });
        } else setValidElements(settings.valid_elements);
        addCustomElements(settings.custom_elements);
        addValidChildren(settings.valid_children);
        addValidElements(settings.extended_valid_elements);
        addValidChildren("+ol[ul|ol],+ul[ul|ol]");
        if (settings.invalid_elements) tinymce.each(tinymce.explode(settings.invalid_elements), function(item) {
            if (elements[item]) delete elements[item];
        });
        if (!getElementRule("span")) addValidElements("span[!data-mce-type|*]");
        self.children = children;
        self.styles = validStyles;
        self.getBoolAttrs = function() {
            return boolAttrMap;
        };
        self.getBlockElements = function() {
            return blockElementsMap;
        };
        self.getTextBlockElements = function() {
            return textBlockElementsMap;
        };
        self.getShortEndedElements = function() {
            return shortEndedElementsMap;
        };
        self.getSelfClosingElements = function() {
            return selfClosingElementsMap;
        };
        self.getNonEmptyElements = function() {
            return nonEmptyElementsMap;
        };
        self.getWhiteSpaceElements = function() {
            return whiteSpaceElementsMap;
        };
        self.isValidChild = function(name, child) {
            var parent = children[name];
            return !!(parent && parent[child]);
        };
        self.isValid = function(name, attr) {
            var attrPatterns, i, rule = getElementRule(name);
            if (rule) if (attr) {
                if (rule.attributes[attr]) return true;
                attrPatterns = rule.attributePatterns;
                if (attrPatterns) {
                    i = attrPatterns.length;
                    while (i--) if (attrPatterns[i].pattern.test(name)) return true;
                }
            } else return true;
            return false;
        };
        self.getElementRule = getElementRule;
        self.getCustomElements = function() {
            return customElementsMap;
        };
        self.addValidElements = addValidElements;
        self.setValidElements = setValidElements;
        self.addCustomElements = addCustomElements;
        self.addValidChildren = addValidChildren;
    };
})(tinymce);

(function(tinymce) {
    tinymce.html.SaxParser = function(settings, schema) {
        var self = this, noop = function() {};
        settings = settings || {};
        self.schema = schema = schema || new tinymce.html.Schema();
        if (false !== settings.fix_self_closing) settings.fix_self_closing = true;
        tinymce.each("comment cdata text start end pi doctype".split(" "), function(name) {
            if (name) self[name] = settings[name] || noop;
        });
        self.parse = function(html) {
            var self = this, matches, index = 0, value, endRegExp, stack = [], attrList, i, text, name, isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded, validate, elementRule, isValidElement, attr, attribsValue, invalidPrefixRegExp, validAttributesMap, validAttributePatterns, attributesRequired, attributesDefault, attributesForced, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0, decode = tinymce.html.Entities.decode, fixSelfClosing, isIE;
            function processEndTag(name) {
                var pos, i;
                pos = stack.length;
                while (pos--) if (stack[pos].name === name) break;
                if (pos >= 0) {
                    for (i = stack.length - 1; i >= pos; i--) {
                        name = stack[i];
                        if (name.valid) self.end(name.name);
                    }
                    stack.length = pos;
                }
            }
            function parseAttribute(match, name, value, val2, val3) {
                var attrRule, i;
                name = name.toLowerCase();
                value = name in fillAttrsMap ? name : decode(value || val2 || val3 || "");
                if (validate && !isInternalElement && 0 !== name.indexOf("data-")) {
                    attrRule = validAttributesMap[name];
                    if (!attrRule && validAttributePatterns) {
                        i = validAttributePatterns.length;
                        while (i--) {
                            attrRule = validAttributePatterns[i];
                            if (attrRule.pattern.test(name)) break;
                        }
                        if (i === -1) attrRule = null;
                    }
                    if (!attrRule) return;
                    if (attrRule.validValues && !(value in attrRule.validValues)) return;
                }
                attrList.map[name] = value;
                attrList.push({
                    name: name,
                    value: value
                });
            }
            tokenRegExp = new RegExp("<(?:" + "(?:!--([\\w\\W]*?)-->)|" + "(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|" + "(?:!DOCTYPE([\\w\\W]*?)>)|" + "(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|" + "(?:\\/([^>]+)>)|" + "(?:([A-Za-z0-9\\-\\:]+)((?:\\s+[^\"'>]+(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>]*))*|\\/|\\s+)>)" + ")", "g");
            attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
            specialElements = {
                script: /<\/script[^>]*>/gi,
                style: /<\/style[^>]*>/gi,
                noscript: /<\/noscript[^>]*>/gi
            };
            shortEndedElements = schema.getShortEndedElements();
            selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
            fillAttrsMap = schema.getBoolAttrs();
            validate = settings.validate;
            removeInternalElements = settings.remove_internals;
            fixSelfClosing = settings.fix_self_closing;
            isIE = tinymce.isIE;
            invalidPrefixRegExp = /^:/;
            while (matches = tokenRegExp.exec(html)) {
                if (index < matches.index) self.text(decode(html.substr(index, matches.index - index)));
                if (value = matches[6]) {
                    value = value.toLowerCase();
                    if (isIE && invalidPrefixRegExp.test(value)) value = value.substr(1);
                    processEndTag(value);
                } else if (value = matches[7]) {
                    value = value.toLowerCase();
                    if (isIE && invalidPrefixRegExp.test(value)) value = value.substr(1);
                    isShortEnded = value in shortEndedElements;
                    if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) processEndTag(value);
                    if (!validate || (elementRule = schema.getElementRule(value))) {
                        isValidElement = true;
                        if (validate) {
                            validAttributesMap = elementRule.attributes;
                            validAttributePatterns = elementRule.attributePatterns;
                        }
                        if (attribsValue = matches[8]) {
                            isInternalElement = attribsValue.indexOf("data-mce-type") !== -1;
                            if (isInternalElement && removeInternalElements) isValidElement = false;
                            attrList = [];
                            attrList.map = {};
                            attribsValue.replace(attrRegExp, parseAttribute);
                        } else {
                            attrList = [];
                            attrList.map = {};
                        }
                        if (validate && !isInternalElement) {
                            attributesRequired = elementRule.attributesRequired;
                            attributesDefault = elementRule.attributesDefault;
                            attributesForced = elementRule.attributesForced;
                            if (attributesForced) {
                                i = attributesForced.length;
                                while (i--) {
                                    attr = attributesForced[i];
                                    name = attr.name;
                                    attrValue = attr.value;
                                    if ("{$uid}" === attrValue) attrValue = "mce_" + idCount++;
                                    attrList.map[name] = attrValue;
                                    attrList.push({
                                        name: name,
                                        value: attrValue
                                    });
                                }
                            }
                            if (attributesDefault) {
                                i = attributesDefault.length;
                                while (i--) {
                                    attr = attributesDefault[i];
                                    name = attr.name;
                                    if (!(name in attrList.map)) {
                                        attrValue = attr.value;
                                        if ("{$uid}" === attrValue) attrValue = "mce_" + idCount++;
                                        attrList.map[name] = attrValue;
                                        attrList.push({
                                            name: name,
                                            value: attrValue
                                        });
                                    }
                                }
                            }
                            if (attributesRequired) {
                                i = attributesRequired.length;
                                while (i--) if (attributesRequired[i] in attrList.map) break;
                                if (i === -1) isValidElement = false;
                            }
                            if (attrList.map["data-mce-bogus"]) isValidElement = false;
                        }
                        if (isValidElement) self.start(value, attrList, isShortEnded);
                    } else isValidElement = false;
                    if (endRegExp = specialElements[value]) {
                        endRegExp.lastIndex = index = matches.index + matches[0].length;
                        if (matches = endRegExp.exec(html)) {
                            if (isValidElement) text = html.substr(index, matches.index - index);
                            index = matches.index + matches[0].length;
                        } else {
                            text = html.substr(index);
                            index = html.length;
                        }
                        if (isValidElement && text.length > 0) self.text(text, true);
                        if (isValidElement) self.end(value);
                        tokenRegExp.lastIndex = index;
                        continue;
                    }
                    if (!isShortEnded) if (!attribsValue || attribsValue.indexOf("/") != attribsValue.length - 1) stack.push({
                        name: value,
                        valid: isValidElement
                    }); else if (isValidElement) self.end(value);
                } else if (value = matches[1]) self.comment(value); else if (value = matches[2]) self.cdata(value); else if (value = matches[3]) self.doctype(value); else if (value = matches[4]) self.pi(value, matches[5]);
                index = matches.index + matches[0].length;
            }
            if (index < html.length) self.text(decode(html.substr(index)));
            for (i = stack.length - 1; i >= 0; i--) {
                value = stack[i];
                if (value.valid) self.end(value.name);
            }
        };
    };
})(tinymce);

(function(tinymce) {
    var whiteSpaceRegExp = /^[ \t\r\n]*$/, typeLookup = {
        "#text": 3,
        "#comment": 8,
        "#cdata": 4,
        "#pi": 7,
        "#doctype": 10,
        "#document-fragment": 11
    };
    function walk(node, root_node, prev) {
        var sibling, parent, startName = prev ? "lastChild" : "firstChild", siblingName = prev ? "prev" : "next";
        if (node[startName]) return node[startName];
        if (node !== root_node) {
            sibling = node[siblingName];
            if (sibling) return sibling;
            for (parent = node.parent; parent && parent !== root_node; parent = parent.parent) {
                sibling = parent[siblingName];
                if (sibling) return sibling;
            }
        }
    }
    function Node(name, type) {
        this.name = name;
        this.type = type;
        if (1 === type) {
            this.attributes = [];
            this.attributes.map = {};
        }
    }
    tinymce.extend(Node.prototype, {
        replace: function(node) {
            var self = this;
            if (node.parent) node.remove();
            self.insert(node, self);
            self.remove();
            return self;
        },
        attr: function(name, value) {
            var self = this, attrs, i, undef;
            if ("string" !== typeof name) {
                for (i in name) self.attr(i, name[i]);
                return self;
            }
            if (attrs = self.attributes) if (value !== undef) {
                if (null === value) {
                    if (name in attrs.map) {
                        delete attrs.map[name];
                        i = attrs.length;
                        while (i--) if (attrs[i].name === name) {
                            attrs = attrs.splice(i, 1);
                            return self;
                        }
                    }
                    return self;
                }
                if (name in attrs.map) {
                    i = attrs.length;
                    while (i--) if (attrs[i].name === name) {
                        attrs[i].value = value;
                        break;
                    }
                } else attrs.push({
                    name: name,
                    value: value
                });
                attrs.map[name] = value;
                return self;
            } else return attrs.map[name];
        },
        clone: function() {
            var self = this, clone = new Node(self.name, self.type), i, l, selfAttrs, selfAttr, cloneAttrs;
            if (selfAttrs = self.attributes) {
                cloneAttrs = [];
                cloneAttrs.map = {};
                for (i = 0, l = selfAttrs.length; i < l; i++) {
                    selfAttr = selfAttrs[i];
                    if ("id" !== selfAttr.name) {
                        cloneAttrs[cloneAttrs.length] = {
                            name: selfAttr.name,
                            value: selfAttr.value
                        };
                        cloneAttrs.map[selfAttr.name] = selfAttr.value;
                    }
                }
                clone.attributes = cloneAttrs;
            }
            clone.value = self.value;
            clone.shortEnded = self.shortEnded;
            return clone;
        },
        wrap: function(wrapper) {
            var self = this;
            self.parent.insert(wrapper, self);
            wrapper.append(self);
            return self;
        },
        unwrap: function() {
            var self = this, node, next;
            for (node = self.firstChild; node; ) {
                next = node.next;
                self.insert(node, self, true);
                node = next;
            }
            self.remove();
        },
        remove: function() {
            var self = this, parent = self.parent, next = self.next, prev = self.prev;
            if (parent) {
                if (parent.firstChild === self) {
                    parent.firstChild = next;
                    if (next) next.prev = null;
                } else prev.next = next;
                if (parent.lastChild === self) {
                    parent.lastChild = prev;
                    if (prev) prev.next = null;
                } else next.prev = prev;
                self.parent = self.next = self.prev = null;
            }
            return self;
        },
        append: function(node) {
            var self = this, last;
            if (node.parent) node.remove();
            last = self.lastChild;
            if (last) {
                last.next = node;
                node.prev = last;
                self.lastChild = node;
            } else self.lastChild = self.firstChild = node;
            node.parent = self;
            return node;
        },
        insert: function(node, ref_node, before) {
            var parent;
            if (node.parent) node.remove();
            parent = ref_node.parent || this;
            if (before) {
                if (ref_node === parent.firstChild) parent.firstChild = node; else ref_node.prev.next = node;
                node.prev = ref_node.prev;
                node.next = ref_node;
                ref_node.prev = node;
            } else {
                if (ref_node === parent.lastChild) parent.lastChild = node; else ref_node.next.prev = node;
                node.next = ref_node.next;
                node.prev = ref_node;
                ref_node.next = node;
            }
            node.parent = parent;
            return node;
        },
        getAll: function(name) {
            var self = this, node, collection = [];
            for (node = self.firstChild; node; node = walk(node, self)) if (node.name === name) collection.push(node);
            return collection;
        },
        empty: function() {
            var self = this, nodes, i, node;
            if (self.firstChild) {
                nodes = [];
                for (node = self.firstChild; node; node = walk(node, self)) nodes.push(node);
                i = nodes.length;
                while (i--) {
                    node = nodes[i];
                    node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
                }
            }
            self.firstChild = self.lastChild = null;
            return self;
        },
        isEmpty: function(elements) {
            var self = this, node = self.firstChild, i, name;
            if (node) do {
                if (1 === node.type) {
                    if (node.attributes.map["data-mce-bogus"]) continue;
                    if (elements[node.name]) return false;
                    i = node.attributes.length;
                    while (i--) {
                        name = node.attributes[i].name;
                        if ("name" === name || 0 === name.indexOf("data-")) return false;
                    }
                }
                if (8 === node.type) return false;
                if (3 === node.type && !whiteSpaceRegExp.test(node.value)) return false;
            } while (node = walk(node, self));
            return true;
        },
        walk: function(prev) {
            return walk(this, null, prev);
        }
    });
    tinymce.extend(Node, {
        create: function(name, attrs) {
            var node, attrName;
            node = new Node(name, typeLookup[name] || 1);
            if (attrs) for (attrName in attrs) node.attr(attrName, attrs[attrName]);
            return node;
        }
    });
    tinymce.html.Node = Node;
})(tinymce);

(function(tinymce) {
    var Node = tinymce.html.Node;
    tinymce.html.DomParser = function(settings, schema) {
        var self = this, nodeFilters = {}, attributeFilters = [], matchedNodes = {}, matchedAttributes = {};
        settings = settings || {};
        settings.validate = "validate" in settings ? settings.validate : true;
        settings.root_name = settings.root_name || "body";
        self.schema = schema = schema || new tinymce.html.Schema();
        function fixInvalidChildren(nodes) {
            var ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i, childClone, nonEmptyElements, nonSplitableElements, textBlockElements, sibling, nextNode;
            nonSplitableElements = tinymce.makeMap("tr,td,th,tbody,thead,tfoot,table");
            nonEmptyElements = schema.getNonEmptyElements();
            textBlockElements = schema.getTextBlockElements();
            for (ni = 0; ni < nodes.length; ni++) {
                node = nodes[ni];
                if (!node.parent || node.fixed) continue;
                if (textBlockElements[node.name] && "li" == node.parent.name) {
                    sibling = node.next;
                    while (sibling) {
                        if (textBlockElements[sibling.name]) {
                            sibling.name = "li";
                            sibling.fixed = true;
                            node.parent.insert(sibling, node.parent);
                        } else break;
                        sibling = sibling.next;
                    }
                    node.unwrap(node);
                    continue;
                }
                parents = [ node ];
                for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && !nonSplitableElements[parent.name]; parent = parent.parent) parents.push(parent);
                if (parent && parents.length > 1) {
                    parents.reverse();
                    newParent = currentNode = self.filterNode(parents[0].clone());
                    for (i = 0; i < parents.length - 1; i++) {
                        if (schema.isValidChild(currentNode.name, parents[i].name)) {
                            tempNode = self.filterNode(parents[i].clone());
                            currentNode.append(tempNode);
                        } else tempNode = currentNode;
                        for (childNode = parents[i].firstChild; childNode && childNode != parents[i + 1]; ) {
                            nextNode = childNode.next;
                            tempNode.append(childNode);
                            childNode = nextNode;
                        }
                        currentNode = tempNode;
                    }
                    if (!newParent.isEmpty(nonEmptyElements)) {
                        parent.insert(newParent, parents[0], true);
                        parent.insert(node, newParent);
                    } else parent.insert(node, parents[0], true);
                    parent = parents[0];
                    if (parent.isEmpty(nonEmptyElements) || parent.firstChild === parent.lastChild && "br" === parent.firstChild.name) parent.empty().remove();
                } else if (node.parent) {
                    if ("li" === node.name) {
                        sibling = node.prev;
                        if (sibling && ("ul" === sibling.name || "ul" === sibling.name)) {
                            sibling.append(node);
                            continue;
                        }
                        sibling = node.next;
                        if (sibling && ("ul" === sibling.name || "ul" === sibling.name)) {
                            sibling.insert(node, sibling.firstChild, true);
                            continue;
                        }
                        node.wrap(self.filterNode(new Node("ul", 1)));
                        continue;
                    }
                    if (schema.isValidChild(node.parent.name, "div") && schema.isValidChild("div", node.name)) node.wrap(self.filterNode(new Node("div", 1))); else if ("style" === node.name || "script" === node.name) node.empty().remove(); else node.unwrap();
                }
            }
        }
        self.filterNode = function(node) {
            var i, name, list;
            if (name in nodeFilters) {
                list = matchedNodes[name];
                if (list) list.push(node); else matchedNodes[name] = [ node ];
            }
            i = attributeFilters.length;
            while (i--) {
                name = attributeFilters[i].name;
                if (name in node.attributes.map) {
                    list = matchedAttributes[name];
                    if (list) list.push(node); else matchedAttributes[name] = [ node ];
                }
            }
            return node;
        };
        self.addNodeFilter = function(name, callback) {
            tinymce.each(tinymce.explode(name), function(name) {
                var list = nodeFilters[name];
                if (!list) nodeFilters[name] = list = [];
                list.push(callback);
            });
        };
        self.addAttributeFilter = function(name, callback) {
            tinymce.each(tinymce.explode(name), function(name) {
                var i;
                for (i = 0; i < attributeFilters.length; i++) if (attributeFilters[i].name === name) {
                    attributeFilters[i].callbacks.push(callback);
                    return;
                }
                attributeFilters.push({
                    name: name,
                    callbacks: [ callback ]
                });
            });
        };
        self.parse = function(html, args) {
            var parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate, blockElements, startWhiteSpaceRegExp, invalidChildren = [], isInWhiteSpacePreservedElement, endWhiteSpaceRegExp, allWhiteSpaceRegExp, isAllWhiteSpaceRegExp, whiteSpaceElements, children, nonEmptyElements, rootBlockName;
            args = args || {};
            matchedNodes = {};
            matchedAttributes = {};
            blockElements = tinymce.extend(tinymce.makeMap("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
            nonEmptyElements = schema.getNonEmptyElements();
            children = schema.children;
            validate = settings.validate;
            rootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;
            whiteSpaceElements = schema.getWhiteSpaceElements();
            startWhiteSpaceRegExp = /^[ \t\r\n]+/;
            endWhiteSpaceRegExp = /[ \t\r\n]+$/;
            allWhiteSpaceRegExp = /[ \t\r\n]+/g;
            isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
            function addRootBlocks() {
                var node = rootNode.firstChild, next, rootBlockNode;
                while (node) {
                    next = node.next;
                    if (3 == node.type || 1 == node.type && "p" !== node.name && !blockElements[node.name] && !node.attr("data-mce-type")) if (!rootBlockNode) {
                        rootBlockNode = createNode(rootBlockName, 1);
                        rootNode.insert(rootBlockNode, node);
                        rootBlockNode.append(node);
                    } else rootBlockNode.append(node); else rootBlockNode = null;
                    node = next;
                }
            }
            function createNode(name, type) {
                var node = new Node(name, type), list;
                if (name in nodeFilters) {
                    list = matchedNodes[name];
                    if (list) list.push(node); else matchedNodes[name] = [ node ];
                }
                return node;
            }
            function removeWhitespaceBefore(node) {
                var textNode, textVal, sibling;
                for (textNode = node.prev; textNode && 3 === textNode.type; ) {
                    textVal = textNode.value.replace(endWhiteSpaceRegExp, "");
                    if (textVal.length > 0) {
                        textNode.value = textVal;
                        textNode = textNode.prev;
                    } else {
                        sibling = textNode.prev;
                        textNode.remove();
                        textNode = sibling;
                    }
                }
            }
            function cloneAndExcludeBlocks(input) {
                var name, output = {};
                for (name in input) if ("li" !== name && "p" != name) output[name] = input[name];
                return output;
            }
            parser = new tinymce.html.SaxParser({
                validate: validate,
                self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
                cdata: function(text) {
                    node.append(createNode("#cdata", 4)).value = text;
                },
                text: function(text, raw) {
                    var textNode;
                    if (!isInWhiteSpacePreservedElement) {
                        text = text.replace(allWhiteSpaceRegExp, " ");
                        if (node.lastChild && blockElements[node.lastChild.name]) text = text.replace(startWhiteSpaceRegExp, "");
                    }
                    if (0 !== text.length) {
                        textNode = createNode("#text", 3);
                        textNode.raw = !!raw;
                        node.append(textNode).value = text;
                    }
                },
                comment: function(text) {
                    node.append(createNode("#comment", 8)).value = text;
                },
                pi: function(name, text) {
                    node.append(createNode(name, 7)).value = text;
                    removeWhitespaceBefore(node);
                },
                doctype: function(text) {
                    var newNode;
                    newNode = node.append(createNode("#doctype", 10));
                    newNode.value = text;
                    removeWhitespaceBefore(node);
                },
                start: function(name, attrs, empty) {
                    var newNode, attrFiltersLen, elementRule, textNode, attrName, text, sibling, parent;
                    elementRule = validate ? schema.getElementRule(name) : {};
                    if (elementRule) {
                        newNode = createNode(elementRule.outputName || name, 1);
                        newNode.attributes = attrs;
                        newNode.shortEnded = empty;
                        node.append(newNode);
                        parent = children[node.name];
                        if (parent && children[newNode.name] && !parent[newNode.name]) invalidChildren.push(newNode);
                        attrFiltersLen = attributeFilters.length;
                        while (attrFiltersLen--) {
                            attrName = attributeFilters[attrFiltersLen].name;
                            if (attrName in attrs.map) {
                                list = matchedAttributes[attrName];
                                if (list) list.push(newNode); else matchedAttributes[attrName] = [ newNode ];
                            }
                        }
                        if (blockElements[name]) removeWhitespaceBefore(newNode);
                        if (!empty) node = newNode;
                        if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) isInWhiteSpacePreservedElement = true;
                    }
                },
                end: function(name) {
                    var textNode, elementRule, text, sibling, tempNode;
                    elementRule = validate ? schema.getElementRule(name) : {};
                    if (elementRule) {
                        if (blockElements[name]) if (!isInWhiteSpacePreservedElement) {
                            textNode = node.firstChild;
                            if (textNode && 3 === textNode.type) {
                                text = textNode.value.replace(startWhiteSpaceRegExp, "");
                                if (text.length > 0) {
                                    textNode.value = text;
                                    textNode = textNode.next;
                                } else {
                                    sibling = textNode.next;
                                    textNode.remove();
                                    textNode = sibling;
                                }
                                while (textNode && 3 === textNode.type) {
                                    text = textNode.value;
                                    sibling = textNode.next;
                                    if (0 === text.length || isAllWhiteSpaceRegExp.test(text)) {
                                        textNode.remove();
                                        textNode = sibling;
                                    }
                                    textNode = sibling;
                                }
                            }
                            textNode = node.lastChild;
                            if (textNode && 3 === textNode.type) {
                                text = textNode.value.replace(endWhiteSpaceRegExp, "");
                                if (text.length > 0) {
                                    textNode.value = text;
                                    textNode = textNode.prev;
                                } else {
                                    sibling = textNode.prev;
                                    textNode.remove();
                                    textNode = sibling;
                                }
                                while (textNode && 3 === textNode.type) {
                                    text = textNode.value;
                                    sibling = textNode.prev;
                                    if (0 === text.length || isAllWhiteSpaceRegExp.test(text)) {
                                        textNode.remove();
                                        textNode = sibling;
                                    }
                                    textNode = sibling;
                                }
                            }
                        }
                        if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) isInWhiteSpacePreservedElement = false;
                        if (elementRule.removeEmpty || elementRule.paddEmpty) if (node.isEmpty(nonEmptyElements)) if (elementRule.paddEmpty) node.empty().append(new Node("#text", "3")).value = " "; else if (!node.attributes.map.name && !node.attributes.map.id) {
                            tempNode = node.parent;
                            node.empty().remove();
                            node = tempNode;
                            return;
                        }
                        node = node.parent;
                    }
                }
            }, schema);
            rootNode = node = new Node(args.context || settings.root_name, 11);
            parser.parse(html);
            if (validate && invalidChildren.length) if (!args.context) fixInvalidChildren(invalidChildren); else args.invalid = true;
            if (rootBlockName && "body" == rootNode.name) addRootBlocks();
            if (!args.invalid) {
                for (name in matchedNodes) {
                    list = nodeFilters[name];
                    nodes = matchedNodes[name];
                    fi = nodes.length;
                    while (fi--) if (!nodes[fi].parent) nodes.splice(fi, 1);
                    for (i = 0, l = list.length; i < l; i++) list[i](nodes, name, args);
                }
                for (i = 0, l = attributeFilters.length; i < l; i++) {
                    list = attributeFilters[i];
                    if (list.name in matchedAttributes) {
                        nodes = matchedAttributes[list.name];
                        fi = nodes.length;
                        while (fi--) if (!nodes[fi].parent) nodes.splice(fi, 1);
                        for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) list.callbacks[fi](nodes, list.name, args);
                    }
                }
            }
            return rootNode;
        };
        if (settings.remove_trailing_brs) self.addNodeFilter("br", function(nodes, name) {
            var i, l = nodes.length, node, blockElements = tinymce.extend({}, schema.getBlockElements()), nonEmptyElements = schema.getNonEmptyElements(), parent, lastParent, prev, prevName;
            blockElements.body = 1;
            for (i = 0; i < l; i++) {
                node = nodes[i];
                parent = node.parent;
                if (blockElements[node.parent.name] && node === parent.lastChild) {
                    prev = node.prev;
                    while (prev) {
                        prevName = prev.name;
                        if ("span" !== prevName || "bookmark" !== prev.attr("data-mce-type")) {
                            if ("br" !== prevName) break;
                            if ("br" === prevName) {
                                node = null;
                                break;
                            }
                        }
                        prev = prev.prev;
                    }
                    if (node) {
                        node.remove();
                        if (parent.isEmpty(nonEmptyElements)) {
                            elementRule = schema.getElementRule(parent.name);
                            if (elementRule) if (elementRule.removeEmpty) parent.remove(); else if (elementRule.paddEmpty) parent.empty().append(new tinymce.html.Node("#text", 3)).value = " ";
                        }
                    }
                } else {
                    lastParent = node;
                    while (parent.firstChild === lastParent && parent.lastChild === lastParent) {
                        lastParent = parent;
                        if (blockElements[parent.name]) break;
                        parent = parent.parent;
                    }
                    if (lastParent === parent) {
                        textNode = new tinymce.html.Node("#text", 3);
                        textNode.value = " ";
                        node.replace(textNode);
                    }
                }
            }
        });
        if (!settings.allow_html_in_named_anchor) self.addAttributeFilter("id,name", function(nodes, name) {
            var i = nodes.length, sibling, prevSibling, parent, node;
            while (i--) {
                node = nodes[i];
                if ("a" === node.name && node.firstChild && !node.attr("href")) {
                    parent = node.parent;
                    sibling = node.lastChild;
                    do {
                        prevSibling = sibling.prev;
                        parent.insert(sibling, node);
                        sibling = prevSibling;
                    } while (sibling);
                }
            }
        });
    };
})(tinymce);

tinymce.html.Writer = function(settings) {
    var html = [], indent, indentBefore, indentAfter, encode, htmlOutput;
    settings = settings || {};
    indent = settings.indent;
    indentBefore = tinymce.makeMap(settings.indent_before || "");
    indentAfter = tinymce.makeMap(settings.indent_after || "");
    encode = tinymce.html.Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
    htmlOutput = "html" == settings.element_format;
    return {
        start: function(name, attrs, empty) {
            var i, l, attr, value;
            if (indent && indentBefore[name] && html.length > 0) {
                value = html[html.length - 1];
                if (value.length > 0 && "\n" !== value) html.push("\n");
            }
            html.push("<", name);
            if (attrs) for (i = 0, l = attrs.length; i < l; i++) {
                attr = attrs[i];
                html.push(" ", attr.name, '="', encode(attr.value, true), '"');
            }
            if (!empty || htmlOutput) html[html.length] = ">"; else html[html.length] = " />";
            if (empty && indent && indentAfter[name] && html.length > 0) {
                value = html[html.length - 1];
                if (value.length > 0 && "\n" !== value) html.push("\n");
            }
        },
        end: function(name) {
            var value;
            html.push("</", name, ">");
            if (indent && indentAfter[name] && html.length > 0) {
                value = html[html.length - 1];
                if (value.length > 0 && "\n" !== value) html.push("\n");
            }
        },
        text: function(text, raw) {
            if (text.length > 0) html[html.length] = raw ? text : encode(text);
        },
        cdata: function(text) {
            html.push("<![CDATA[", text, "]]>");
        },
        comment: function(text) {
            html.push("<!--", text, "-->");
        },
        pi: function(name, text) {
            if (text) html.push("<?", name, " ", text, "?>"); else html.push("<?", name, "?>");
            if (indent) html.push("\n");
        },
        doctype: function(text) {
            html.push("<!DOCTYPE", text, ">", indent ? "\n" : "");
        },
        reset: function() {
            html.length = 0;
        },
        getContent: function() {
            return html.join("").replace(/\n$/, "");
        }
    };
};

(function(tinymce) {
    tinymce.html.Serializer = function(settings, schema) {
        var self = this, writer = new tinymce.html.Writer(settings);
        settings = settings || {};
        settings.validate = "validate" in settings ? settings.validate : true;
        self.schema = schema = schema || new tinymce.html.Schema();
        self.writer = writer;
        self.serialize = function(node) {
            var handlers, validate;
            validate = settings.validate;
            handlers = {
                3: function(node, raw) {
                    writer.text(node.value, node.raw);
                },
                8: function(node) {
                    writer.comment(node.value);
                },
                7: function(node) {
                    writer.pi(node.name, node.value);
                },
                10: function(node) {
                    writer.doctype(node.value);
                },
                4: function(node) {
                    writer.cdata(node.value);
                },
                11: function(node) {
                    if (node = node.firstChild) do walk(node); while (node = node.next);
                }
            };
            writer.reset();
            function walk(node) {
                var handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;
                if (!handler) {
                    name = node.name;
                    isEmpty = node.shortEnded;
                    attrs = node.attributes;
                    if (validate && attrs && attrs.length > 1) {
                        sortedAttrs = [];
                        sortedAttrs.map = {};
                        elementRule = schema.getElementRule(node.name);
                        for (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                            attrName = elementRule.attributesOrder[i];
                            if (attrName in attrs.map) {
                                attrValue = attrs.map[attrName];
                                sortedAttrs.map[attrName] = attrValue;
                                sortedAttrs.push({
                                    name: attrName,
                                    value: attrValue
                                });
                            }
                        }
                        for (i = 0, l = attrs.length; i < l; i++) {
                            attrName = attrs[i].name;
                            if (!(attrName in sortedAttrs.map)) {
                                attrValue = attrs.map[attrName];
                                sortedAttrs.map[attrName] = attrValue;
                                sortedAttrs.push({
                                    name: attrName,
                                    value: attrValue
                                });
                            }
                        }
                        attrs = sortedAttrs;
                    }
                    writer.start(node.name, attrs, isEmpty);
                    if (!isEmpty) {
                        if (node = node.firstChild) do walk(node); while (node = node.next);
                        writer.end(name);
                    }
                } else handler(node);
            }
            if (1 == node.type && !settings.inner) walk(node); else handlers[11](node);
            return writer.getContent();
        };
    };
})(tinymce);

tinymce.dom = {};

(function(namespace, expando) {
    var w3cEventModel = !!document.addEventListener;
    function addEvent(target, name, callback, capture) {
        if (target.addEventListener) target.addEventListener(name, callback, capture || false); else if (target.attachEvent) target.attachEvent("on" + name, callback);
    }
    function removeEvent(target, name, callback, capture) {
        if (target.removeEventListener) target.removeEventListener(name, callback, capture || false); else if (target.detachEvent) target.detachEvent("on" + name, callback);
    }
    function fix(original_event, data) {
        var name, event = data || {};
        function returnFalse() {
            return false;
        }
        function returnTrue() {
            return true;
        }
        for (name in original_event) if ("layerX" !== name && "layerY" !== name) event[name] = original_event[name];
        if (!event.target) event.target = event.srcElement || document;
        event.preventDefault = function() {
            event.isDefaultPrevented = returnTrue;
            if (original_event) if (original_event.preventDefault) original_event.preventDefault(); else original_event.returnValue = false;
        };
        event.stopPropagation = function() {
            event.isPropagationStopped = returnTrue;
            if (original_event) if (original_event.stopPropagation) original_event.stopPropagation(); else original_event.cancelBubble = true;
        };
        event.stopImmediatePropagation = function() {
            event.isImmediatePropagationStopped = returnTrue;
            event.stopPropagation();
        };
        if (!event.isDefaultPrevented) {
            event.isDefaultPrevented = returnFalse;
            event.isPropagationStopped = returnFalse;
            event.isImmediatePropagationStopped = returnFalse;
        }
        return event;
    }
    function bindOnReady(win, callback, event_utils) {
        var doc = win.document, event = {
            type: "ready"
        };
        function readyHandler() {
            if (!event_utils.domLoaded) {
                event_utils.domLoaded = true;
                callback(event);
            }
        }
        if (w3cEventModel) addEvent(win, "DOMContentLoaded", readyHandler); else {
            addEvent(doc, "readystatechange", function() {
                if ("complete" === doc.readyState) {
                    removeEvent(doc, "readystatechange", arguments.callee);
                    readyHandler();
                }
            });
            if (doc.documentElement.doScroll && win === win.top) (function() {
                try {
                    doc.documentElement.doScroll("left");
                } catch (ex) {
                    setTimeout(arguments.callee, 0);
                    return;
                }
                readyHandler();
            })();
        }
        addEvent(win, "load", readyHandler);
    }
    function EventUtils(proxy) {
        var self = this, events = {}, count, isFocusBlurBound, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;
        hasMouseEnterLeave = "onmouseenter" in document.documentElement;
        hasFocusIn = "onfocusin" in document.documentElement;
        mouseEnterLeave = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        };
        count = 1;
        self.domLoaded = false;
        self.events = events;
        function executeHandlers(evt, id) {
            var callbackList, i, l, callback;
            callbackList = events[id][evt.type];
            if (callbackList) for (i = 0, l = callbackList.length; i < l; i++) {
                callback = callbackList[i];
                if (callback && false === callback.func.call(callback.scope, evt)) evt.preventDefault();
                if (evt.isImmediatePropagationStopped()) return;
            }
        }
        self.bind = function(target, names, callback, scope) {
            var id, callbackList, i, name, fakeName, nativeHandler, capture, win = window;
            function defaultNativeHandler(evt) {
                executeHandlers(fix(evt || win.event), id);
            }
            if (!target || 3 === target.nodeType || 8 === target.nodeType) return;
            if (!target[expando]) {
                id = count++;
                target[expando] = id;
                events[id] = {};
            } else {
                id = target[expando];
                if (!events[id]) events[id] = {};
            }
            scope = scope || target;
            names = names.split(" ");
            i = names.length;
            while (i--) {
                name = names[i];
                nativeHandler = defaultNativeHandler;
                fakeName = capture = false;
                if ("DOMContentLoaded" === name) name = "ready";
                if ((self.domLoaded || "complete" == target.readyState) && "ready" === name) {
                    self.domLoaded = true;
                    callback.call(scope, fix({
                        type: name
                    }));
                    continue;
                }
                if (!hasMouseEnterLeave) {
                    fakeName = mouseEnterLeave[name];
                    if (fakeName) nativeHandler = function(evt) {
                        var current, related;
                        current = evt.currentTarget;
                        related = evt.relatedTarget;
                        if (related && current.contains) related = current.contains(related); else while (related && related !== current) related = related.parentNode;
                        if (!related) {
                            evt = fix(evt || win.event);
                            evt.type = "mouseout" === evt.type ? "mouseleave" : "mouseenter";
                            evt.target = current;
                            executeHandlers(evt, id);
                        }
                    };
                }
                if (!hasFocusIn && ("focusin" === name || "focusout" === name)) {
                    capture = true;
                    fakeName = "focusin" === name ? "focus" : "blur";
                    nativeHandler = function(evt) {
                        evt = fix(evt || win.event);
                        evt.type = "focus" === evt.type ? "focusin" : "focusout";
                        executeHandlers(evt, id);
                    };
                }
                callbackList = events[id][name];
                if (!callbackList) {
                    events[id][name] = callbackList = [ {
                        func: callback,
                        scope: scope
                    } ];
                    callbackList.fakeName = fakeName;
                    callbackList.capture = capture;
                    callbackList.nativeHandler = nativeHandler;
                    if (!w3cEventModel) callbackList.proxyHandler = proxy(id);
                    if ("ready" === name) bindOnReady(target, nativeHandler, self); else addEvent(target, fakeName || name, w3cEventModel ? nativeHandler : callbackList.proxyHandler, capture);
                } else callbackList.push({
                    func: callback,
                    scope: scope
                });
            }
            target = callbackList = 0;
            return callback;
        };
        self.unbind = function(target, names, callback) {
            var id, callbackList, i, ci, name, eventMap;
            if (!target || 3 === target.nodeType || 8 === target.nodeType) return self;
            id = target[expando];
            if (id) {
                eventMap = events[id];
                if (names) {
                    names = names.split(" ");
                    i = names.length;
                    while (i--) {
                        name = names[i];
                        callbackList = eventMap[name];
                        if (callbackList) {
                            if (callback) {
                                ci = callbackList.length;
                                while (ci--) if (callbackList[ci].func === callback) callbackList.splice(ci, 1);
                            }
                            if (!callback || 0 === callbackList.length) {
                                delete eventMap[name];
                                removeEvent(target, callbackList.fakeName || name, w3cEventModel ? callbackList.nativeHandler : callbackList.proxyHandler, callbackList.capture);
                            }
                        }
                    }
                } else {
                    for (name in eventMap) {
                        callbackList = eventMap[name];
                        removeEvent(target, callbackList.fakeName || name, w3cEventModel ? callbackList.nativeHandler : callbackList.proxyHandler, callbackList.capture);
                    }
                    eventMap = {};
                }
                for (name in eventMap) return self;
                delete events[id];
                try {
                    delete target[expando];
                } catch (ex) {
                    target[expando] = null;
                }
            }
            return self;
        };
        self.fire = function(target, name, args) {
            var id, event;
            if (!target || 3 === target.nodeType || 8 === target.nodeType) return self;
            event = fix(null, args);
            event.type = name;
            do {
                id = target[expando];
                if (id) executeHandlers(event, id);
                target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
            } while (target && !event.isPropagationStopped());
            return self;
        };
        self.clean = function(target) {
            var i, children, unbind = self.unbind;
            if (!target || 3 === target.nodeType || 8 === target.nodeType) return self;
            if (target[expando]) unbind(target);
            if (!target.getElementsByTagName) target = target.document;
            if (target && target.getElementsByTagName) {
                unbind(target);
                children = target.getElementsByTagName("*");
                i = children.length;
                while (i--) {
                    target = children[i];
                    if (target[expando]) unbind(target);
                }
            }
            return self;
        };
        self.callNativeHandler = function(id, evt) {
            if (events) events[id][evt.type].nativeHandler(evt);
        };
        self.destory = function() {
            events = {};
        };
        self.add = function(target, events, func, scope) {
            if ("string" === typeof target) target = document.getElementById(target);
            if (target && target instanceof Array) {
                var i = target.length;
                while (i--) self.add(target[i], events, func, scope);
                return;
            }
            if ("init" === events) events = "ready";
            return self.bind(target, events instanceof Array ? events.join(" ") : events, func, scope);
        };
        self.remove = function(target, events, func, scope) {
            if (!target) return self;
            if ("string" === typeof target) target = document.getElementById(target);
            if (target instanceof Array) {
                var i = target.length;
                while (i--) self.remove(target[i], events, func, scope);
                return self;
            }
            return self.unbind(target, events instanceof Array ? events.join(" ") : events, func);
        };
        self.clear = function(target) {
            if ("string" === typeof target) target = document.getElementById(target);
            return self.clean(target);
        };
        self.cancel = function(e) {
            if (e) {
                self.prevent(e);
                self.stop(e);
            }
            return false;
        };
        self.prevent = function(e) {
            if (!e.preventDefault) e = fix(e);
            e.preventDefault();
            return false;
        };
        self.stop = function(e) {
            if (!e.stopPropagation) e = fix(e);
            e.stopPropagation();
            return false;
        };
    }
    namespace.EventUtils = EventUtils;
    namespace.Event = new EventUtils(function(id) {
        return function(evt) {
            tinymce.dom.Event.callNativeHandler(id, evt);
        };
    });
    namespace.Event.bind(window, "ready", function() {});
    namespace = 0;
})(tinymce.dom, "data-mce-expando");

tinymce.dom.TreeWalker = function(start_node, root_node) {
    var node = start_node;
    function findSibling(node, start_name, sibling_name, shallow) {
        var sibling, parent;
        if (node) {
            if (!shallow && node[start_name]) return node[start_name];
            if (node != root_node) {
                sibling = node[sibling_name];
                if (sibling) return sibling;
                for (parent = node.parentNode; parent && parent != root_node; parent = parent.parentNode) {
                    sibling = parent[sibling_name];
                    if (sibling) return sibling;
                }
            }
        }
    }
    this.current = function() {
        return node;
    };
    this.next = function(shallow) {
        return node = findSibling(node, "firstChild", "nextSibling", shallow);
    };
    this.prev = function(shallow) {
        return node = findSibling(node, "lastChild", "previousSibling", shallow);
    };
};

(function(tinymce) {
    var each = tinymce.each, is = tinymce.is, isWebKit = tinymce.isWebKit, isIE = tinymce.isIE, Entities = tinymce.html.Entities, simpleSelectorRe = /^([a-z0-9],?)+$/i, whiteSpaceRegExp = /^[ \t\r\n]*$/;
    tinymce.create("tinymce.dom.DOMUtils", {
        doc: null,
        root: null,
        files: null,
        pixelStyles: /^(top|left|bottom|right|width|height|borderWidth)$/,
        props: {
            "for": "htmlFor",
            "class": "className",
            className: "className",
            checked: "checked",
            disabled: "disabled",
            maxlength: "maxLength",
            readonly: "readOnly",
            selected: "selected",
            value: "value",
            id: "id",
            name: "name",
            type: "type"
        },
        DOMUtils: function(d, s) {
            var t = this, globalStyle, name, blockElementsMap;
            t.doc = d;
            t.win = window;
            t.files = {};
            t.cssFlicker = false;
            t.counter = 0;
            t.stdMode = !tinymce.isIE || d.documentMode >= 8;
            t.boxModel = !tinymce.isIE || "CSS1Compat" == d.compatMode || t.stdMode;
            t.hasOuterHTML = "outerHTML" in d.createElement("a");
            t.settings = s = tinymce.extend({
                keep_values: false,
                hex_colors: 1
            }, s);
            t.schema = s.schema;
            t.styles = new tinymce.html.Styles({
                url_converter: s.url_converter,
                url_converter_scope: s.url_converter_scope
            }, s.schema);
            if (tinymce.isIE6) try {
                d.execCommand("BackgroundImageCache", false, true);
            } catch (e) {
                t.cssFlicker = true;
            }
            t.fixDoc(d);
            t.events = s.ownEvents ? new tinymce.dom.EventUtils(s.proxy) : tinymce.dom.Event;
            tinymce.addUnload(t.destroy, t);
            blockElementsMap = s.schema ? s.schema.getBlockElements() : {};
            t.isBlock = function(node) {
                var type = node.nodeType;
                if (type) return !!(1 === type && blockElementsMap[node.nodeName]);
                return !!blockElementsMap[node];
            };
        },
        fixDoc: function(doc) {
            var settings = this.settings, name;
            if (isIE && settings.schema) {
                ("abbr article aside audio canvas " + "details figcaption figure footer " + "header hgroup mark menu meter nav " + "output progress section summary " + "time video").replace(/\w+/g, function(name) {
                    doc.createElement(name);
                });
                for (name in settings.schema.getCustomElements()) doc.createElement(name);
            }
        },
        clone: function(node, deep) {
            var self = this, clone, doc;
            if (!isIE || 1 !== node.nodeType || deep) return node.cloneNode(deep);
            doc = self.doc;
            if (!deep) {
                clone = doc.createElement(node.nodeName);
                each(self.getAttribs(node), function(attr) {
                    self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
                });
                return clone;
            }
            return clone.firstChild;
        },
        getRoot: function() {
            var t = this, s = t.settings;
            return s && t.get(s.root_element) || t.doc.body;
        },
        getViewPort: function(w) {
            var d, b;
            w = !w ? this.win : w;
            d = w.document;
            b = this.boxModel ? d.documentElement : d.body;
            return {
                x: w.pageXOffset || b.scrollLeft,
                y: w.pageYOffset || b.scrollTop,
                w: w.innerWidth || b.clientWidth,
                h: w.innerHeight || b.clientHeight
            };
        },
        getRect: function(e) {
            var p, t = this, sr;
            e = t.get(e);
            p = t.getPos(e);
            sr = t.getSize(e);
            return {
                x: p.x,
                y: p.y,
                w: sr.w,
                h: sr.h
            };
        },
        getSize: function(e) {
            var t = this, w, h;
            e = t.get(e);
            w = t.getStyle(e, "width");
            h = t.getStyle(e, "height");
            if (w.indexOf("px") === -1) w = 0;
            if (h.indexOf("px") === -1) h = 0;
            return {
                w: parseInt(w, 10) || e.offsetWidth || e.clientWidth,
                h: parseInt(h, 10) || e.offsetHeight || e.clientHeight
            };
        },
        getParent: function(n, f, r) {
            return this.getParents(n, f, r, false);
        },
        getParents: function(n, f, r, c) {
            var t = this, na, se = t.settings, o = [];
            n = t.get(n);
            c = void 0 === c;
            if (se.strict_root) r = r || t.getRoot();
            if (is(f, "string")) {
                na = f;
                if ("*" === f) f = function(n) {
                    return 1 == n.nodeType;
                }; else f = function(n) {
                    return t.is(n, na);
                };
            }
            while (n) {
                if (n == r || !n.nodeType || 9 === n.nodeType) break;
                if (!f || f(n)) if (c) o.push(n); else return n;
                n = n.parentNode;
            }
            return c ? o : null;
        },
        get: function(e) {
            var n;
            if (e && this.doc && "string" == typeof e) {
                n = e;
                e = this.doc.getElementById(e);
                if (e && e.id !== n) return this.doc.getElementsByName(n)[1];
            }
            return e;
        },
        getNext: function(node, selector) {
            return this._findSib(node, selector, "nextSibling");
        },
        getPrev: function(node, selector) {
            return this._findSib(node, selector, "previousSibling");
        },
        add: function(p, n, a, h, c) {
            var t = this;
            return this.run(p, function(p) {
                var e, k;
                e = is(n, "string") ? t.doc.createElement(n) : n;
                t.setAttribs(e, a);
                if (h) if (h.nodeType) e.appendChild(h); else t.setHTML(e, h);
                return !c ? p.appendChild(e) : e;
            });
        },
        create: function(n, a, h) {
            return this.add(this.doc.createElement(n), n, a, h, 1);
        },
        createHTML: function(n, a, h) {
            var o = "", t = this, k;
            o += "<" + n;
            for (k in a) if (a.hasOwnProperty(k)) o += " " + k + '="' + t.encode(a[k]) + '"';
            if ("undefined" != typeof h) return o + ">" + h + "</" + n + ">";
            return o + " />";
        },
        remove: function(node, keep_children) {
            return this.run(node, function(node) {
                var child, parent = node.parentNode;
                if (!parent) return null;
                if (keep_children) while (child = node.firstChild) if (!tinymce.isIE || 3 !== child.nodeType || child.nodeValue) parent.insertBefore(child, node); else node.removeChild(child);
                return parent.removeChild(node);
            });
        },
        setStyle: function(n, na, v) {
            var t = this;
            return t.run(n, function(e) {
                var s, i;
                s = e.style;
                na = na.replace(/-(\D)/g, function(a, b) {
                    return b.toUpperCase();
                });
                if (t.pixelStyles.test(na) && (tinymce.is(v, "number") || /^[\-0-9\.]+$/.test(v))) v += "px";
                switch (na) {
                  case "opacity":
                    if (isIE) {
                        s.filter = "" === v ? "" : "alpha(opacity=" + 100 * v + ")";
                        if (!n.currentStyle || !n.currentStyle.hasLayout) s.display = "inline-block";
                    }
                    s[na] = s["-moz-opacity"] = s["-khtml-opacity"] = v || "";
                    break;

                  case "float":
                    isIE ? s.styleFloat = v : s.cssFloat = v;
                    break;

                  default:
                    s[na] = v || "";
                }
                if (t.settings.update_styles) t.setAttrib(e, "data-mce-style");
            });
        },
        getStyle: function(n, na, c) {
            n = this.get(n);
            if (!n) return;
            if (this.doc.defaultView && c) {
                na = na.replace(/[A-Z]/g, function(a) {
                    return "-" + a;
                });
                try {
                    return this.doc.defaultView.getComputedStyle(n, null).getPropertyValue(na);
                } catch (ex) {
                    return null;
                }
            }
            na = na.replace(/-(\D)/g, function(a, b) {
                return b.toUpperCase();
            });
            if ("float" == na) na = isIE ? "styleFloat" : "cssFloat";
            if (n.currentStyle && c) return n.currentStyle[na];
            return n.style ? n.style[na] : void 0;
        },
        setStyles: function(e, o) {
            var t = this, s = t.settings, ol;
            ol = s.update_styles;
            s.update_styles = 0;
            each(o, function(v, n) {
                t.setStyle(e, n, v);
            });
            s.update_styles = ol;
            if (s.update_styles) t.setAttrib(e, s.cssText);
        },
        removeAllAttribs: function(e) {
            return this.run(e, function(e) {
                var i, attrs = e.attributes;
                for (i = attrs.length - 1; i >= 0; i--) e.removeAttributeNode(attrs.item(i));
            });
        },
        setAttrib: function(e, n, v) {
            var t = this;
            if (!e || !n) return;
            if (t.settings.strict) n = n.toLowerCase();
            return this.run(e, function(e) {
                var s = t.settings;
                var originalValue = e.getAttribute(n);
                if (null !== v) switch (n) {
                  case "style":
                    if (!is(v, "string")) {
                        each(v, function(v, n) {
                            t.setStyle(e, n, v);
                        });
                        return;
                    }
                    if (s.keep_values) if (v && !t._isRes(v)) e.setAttribute("data-mce-style", v, 2); else e.removeAttribute("data-mce-style", 2);
                    e.style.cssText = v;
                    break;

                  case "class":
                    e.className = v || "";
                    break;

                  case "src":
                  case "href":
                    if (s.keep_values) {
                        if (s.url_converter) v = s.url_converter.call(s.url_converter_scope || t, v, n, e);
                        t.setAttrib(e, "data-mce-" + n, v, 2);
                    }
                    break;

                  case "shape":
                    e.setAttribute("data-mce-style", v);
                }
                if (is(v) && null !== v && 0 !== v.length) e.setAttribute(n, "" + v, 2); else e.removeAttribute(n, 2);
                if (tinyMCE.activeEditor && originalValue != v) {
                    var ed = tinyMCE.activeEditor;
                    ed.onSetAttrib.dispatch(ed, e, n, v);
                }
            });
        },
        setAttribs: function(e, o) {
            var t = this;
            return this.run(e, function(e) {
                each(o, function(v, n) {
                    t.setAttrib(e, n, v);
                });
            });
        },
        getAttrib: function(e, n, dv) {
            var v, t = this, undef;
            e = t.get(e);
            if (!e || 1 !== e.nodeType) return dv === undef ? false : dv;
            if (!is(dv)) dv = "";
            if (/^(src|href|style|coords|shape)$/.test(n)) {
                v = e.getAttribute("data-mce-" + n);
                if (v) return v;
            }
            if (isIE && t.props[n]) {
                v = e[t.props[n]];
                v = v && v.nodeValue ? v.nodeValue : v;
            }
            if (!v) v = e.getAttribute(n, 2);
            if (/^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noshade|nowrap|readonly|selected)$/.test(n)) {
                if (true === e[t.props[n]] && "" === v) return n;
                return v ? n : "";
            }
            if ("FORM" === e.nodeName && e.getAttributeNode(n)) return e.getAttributeNode(n).nodeValue;
            if ("style" === n) {
                v = v || e.style.cssText;
                if (v) {
                    v = t.serializeStyle(t.parseStyle(v), e.nodeName);
                    if (t.settings.keep_values && !t._isRes(v)) e.setAttribute("data-mce-style", v);
                }
            }
            if (isWebKit && "class" === n && v) v = v.replace(/(apple|webkit)\-[a-z\-]+/gi, "");
            if (isIE) switch (n) {
              case "rowspan":
              case "colspan":
                if (1 === v) v = "";
                break;

              case "size":
                if ("+0" === v || 20 === v || 0 === v) v = "";
                break;

              case "width":
              case "height":
              case "vspace":
              case "checked":
              case "disabled":
              case "readonly":
                if (0 === v) v = "";
                break;

              case "hspace":
                if (v === -1) v = "";
                break;

              case "maxlength":
              case "tabindex":
                if (32768 === v || 2147483647 === v || "32768" === v) v = "";
                break;

              case "multiple":
              case "compact":
              case "noshade":
              case "nowrap":
                if (65535 === v) return n;
                return dv;

              case "shape":
                v = v.toLowerCase();
                break;

              default:
                if (0 === n.indexOf("on") && v) v = tinymce._replace(/^function\s+\w+\(\)\s+\{\s+(.*)\s+\}$/, "$1", "" + v);
            }
            return v !== undef && null !== v && "" !== v ? "" + v : dv;
        },
        getPos: function(n, ro) {
            var t = this, x = 0, y = 0, e, d = t.doc, r;
            n = t.get(n);
            ro = ro || d.body;
            if (n) {
                if (n.getBoundingClientRect) {
                    n = n.getBoundingClientRect();
                    e = t.boxModel ? d.documentElement : d.body;
                    x = n.left + (d.documentElement.scrollLeft || d.body.scrollLeft) - e.clientTop;
                    y = n.top + (d.documentElement.scrollTop || d.body.scrollTop) - e.clientLeft;
                    return {
                        x: x,
                        y: y
                    };
                }
                r = n;
                while (r && r != ro && r.nodeType) {
                    x += r.offsetLeft || 0;
                    y += r.offsetTop || 0;
                    r = r.offsetParent;
                }
                r = n.parentNode;
                while (r && r != ro && r.nodeType) {
                    x -= r.scrollLeft || 0;
                    y -= r.scrollTop || 0;
                    r = r.parentNode;
                }
            }
            return {
                x: x,
                y: y
            };
        },
        parseStyle: function(st) {
            return this.styles.parse(st);
        },
        serializeStyle: function(o, name) {
            return this.styles.serialize(o, name);
        },
        addStyle: function(cssText) {
            var doc = this.doc, head;
            styleElm = doc.getElementById("mceDefaultStyles");
            if (!styleElm) {
                styleElm = doc.createElement("style"), styleElm.id = "mceDefaultStyles";
                styleElm.type = "text/css";
                head = doc.getElementsByTagName("head")[0];
                if (head.firstChild) head.insertBefore(styleElm, head.firstChild); else head.appendChild(styleElm);
            }
            if (styleElm.styleSheet) styleElm.styleSheet.cssText += cssText; else styleElm.appendChild(doc.createTextNode(cssText));
        },
        loadCSS: function(u) {
            var t = this, d = t.doc, head;
            if (!u) u = "";
            head = d.getElementsByTagName("head")[0];
            each(u.split(","), function(u) {
                var link;
                if (t.files[u]) return;
                t.files[u] = true;
                link = t.create("link", {
                    rel: "stylesheet",
                    href: tinymce._addVer(u)
                });
                if (isIE && d.documentMode && d.recalc) link.onload = function() {
                    if (d.recalc) d.recalc();
                    link.onload = null;
                };
                head.appendChild(link);
            });
        },
        addClass: function(e, c) {
            return this.run(e, function(e) {
                var o;
                if (!c) return 0;
                if (this.hasClass(e, c)) return e.className;
                o = this.removeClass(e, c);
                return e.className = ("" != o ? o + " " : "") + c;
            });
        },
        removeClass: function(e, c) {
            var t = this, re;
            return t.run(e, function(e) {
                var v;
                if (t.hasClass(e, c)) {
                    if (!re) re = new RegExp("(^|\\s+)" + c + "(\\s+|$)", "g");
                    v = e.className.replace(re, " ");
                    v = tinymce.trim(" " != v ? v : "");
                    e.className = v;
                    if (!v) {
                        e.removeAttribute("class");
                        e.removeAttribute("className");
                    }
                    return v;
                }
                return e.className;
            });
        },
        hasClass: function(n, c) {
            n = this.get(n);
            if (!n || !c) return false;
            return (" " + n.className + " ").indexOf(" " + c + " ") !== -1;
        },
        show: function(e) {
            return this.setStyle(e, "display", "block");
        },
        hide: function(e) {
            return this.setStyle(e, "display", "none");
        },
        isHidden: function(e) {
            e = this.get(e);
            return !e || "none" == e.style.display || "none" == this.getStyle(e, "display");
        },
        uniqueId: function(p) {
            return (!p ? "mce_" : p) + this.counter++;
        },
        setHTML: function(element, html) {
            var self = this;
            return self.run(element, function(element) {
                if (isIE) {
                    while (element.firstChild) element.removeChild(element.firstChild);
                    try {
                        element.innerHTML = "<br />" + html;
                        element.removeChild(element.firstChild);
                    } catch (ex) {
                        var newElement = self.create("div");
                        newElement.innerHTML = "<br />" + html;
                        each(tinymce.grep(newElement.childNodes), function(node, i) {
                            if (i && element.canHaveHTML) element.appendChild(node);
                        });
                    }
                } else element.innerHTML = html;
                return html;
            });
        },
        getOuterHTML: function(elm) {
            var doc, self = this;
            elm = self.get(elm);
            if (!elm) return null;
            if (1 === elm.nodeType && self.hasOuterHTML) return elm.outerHTML;
            doc = (elm.ownerDocument || self.doc).createElement("body");
            doc.appendChild(elm.cloneNode(true));
            return doc.innerHTML;
        },
        setOuterHTML: function(e, h, d) {
            var t = this;
            function setHTML(e, h, d) {
                var n, tp;
                tp = d.createElement("body");
                tp.innerHTML = h;
                n = tp.lastChild;
                while (n) {
                    t.insertAfter(n.cloneNode(true), e);
                    n = n.previousSibling;
                }
                t.remove(e);
            }
            return this.run(e, function(e) {
                e = t.get(e);
                if (1 == e.nodeType) {
                    d = d || e.ownerDocument || t.doc;
                    if (isIE) try {
                        if (isIE && 1 == e.nodeType) e.outerHTML = h; else setHTML(e, h, d);
                    } catch (ex) {
                        setHTML(e, h, d);
                    } else setHTML(e, h, d);
                }
            });
        },
        decode: Entities.decode,
        encode: Entities.encodeAllRaw,
        insertAfter: function(node, reference_node) {
            reference_node = this.get(reference_node);
            return this.run(node, function(node) {
                var parent, nextSibling;
                parent = reference_node.parentNode;
                nextSibling = reference_node.nextSibling;
                if (nextSibling) parent.insertBefore(node, nextSibling); else parent.appendChild(node);
                return node;
            });
        },
        replace: function(n, o, k) {
            var t = this;
            if (is(o, "array")) n = n.cloneNode(true);
            return t.run(o, function(o) {
                if (k) each(tinymce.grep(o.childNodes), function(c) {
                    n.appendChild(c);
                });
                return o.parentNode.replaceChild(n, o);
            });
        },
        rename: function(elm, name) {
            var t = this, newElm;
            if (elm.nodeName != name.toUpperCase()) {
                newElm = t.create(name);
                each(t.getAttribs(elm), function(attr_node) {
                    t.setAttrib(newElm, attr_node.nodeName, t.getAttrib(elm, attr_node.nodeName));
                });
                t.replace(newElm, elm, 1);
            }
            return newElm || elm;
        },
        findCommonAncestor: function(a, b) {
            var ps = a, pe;
            while (ps) {
                pe = b;
                while (pe && ps != pe) pe = pe.parentNode;
                if (ps == pe) break;
                ps = ps.parentNode;
            }
            if (!ps && a.ownerDocument) return a.ownerDocument.documentElement;
            return ps;
        },
        toHex: function(s) {
            var c = /^\s*rgb\s*?\(\s*?([0-9]+)\s*?,\s*?([0-9]+)\s*?,\s*?([0-9]+)\s*?\)\s*$/i.exec(s);
            function hex(s) {
                s = parseInt(s, 10).toString(16);
                return s.length > 1 ? s : "0" + s;
            }
            if (c) {
                s = "#" + hex(c[1]) + hex(c[2]) + hex(c[3]);
                return s;
            }
            return s;
        },
        getClasses: function() {
            var t = this, cl = [], i, lo = {}, f = t.settings.class_filter, ov;
            if (t.classes) return t.classes;
            function addClasses(s) {
                each(s.imports, function(r) {
                    addClasses(r);
                });
                each(s.cssRules || s.rules, function(r) {
                    switch (r.type || 1) {
                      case 1:
                        if (r.selectorText) each(r.selectorText.split(","), function(v) {
                            v = v.replace(/^\s*|\s*$|^\s\./g, "");
                            if (/\.mce/.test(v) || !/\.[\w\-]+$/.test(v)) return;
                            ov = v;
                            v = tinymce._replace(/.*\.([a-z0-9_\-]+).*/i, "$1", v);
                            if (f && !(v = f(v, ov))) return;
                            if (!lo[v]) {
                                cl.push({
                                    "class": v
                                });
                                lo[v] = 1;
                            }
                        });
                        break;

                      case 3:
                        addClasses(r.styleSheet);
                    }
                });
            }
            try {
                each(t.doc.styleSheets, addClasses);
            } catch (ex) {}
            if (cl.length > 0) t.classes = cl;
            return cl;
        },
        run: function(e, f, s) {
            var t = this, o;
            if (t.doc && "string" === typeof e) e = t.get(e);
            if (!e) return false;
            s = s || this;
            if (!e.nodeType && (e.length || 0 === e.length)) {
                o = [];
                each(e, function(e, i) {
                    if (e) {
                        if ("string" == typeof e) e = t.doc.getElementById(e);
                        o.push(f.call(s, e, i));
                    }
                });
                return o;
            }
            return f.call(s, e);
        },
        getAttribs: function(n) {
            var o;
            n = this.get(n);
            if (!n) return [];
            if (isIE) {
                o = [];
                if ("OBJECT" == n.nodeName) return n.attributes;
                if ("OPTION" === n.nodeName && this.getAttrib(n, "selected")) o.push({
                    specified: 1,
                    nodeName: "selected"
                });
                n.cloneNode(false).outerHTML.replace(/<\/?[\w:\-]+ ?|=[\"][^\"]+\"|=\'[^\']+\'|=[\w\-]+|>/gi, "").replace(/[\w:\-]+/gi, function(a) {
                    o.push({
                        specified: 1,
                        nodeName: a
                    });
                });
                return o;
            }
            return n.attributes;
        },
        isEmpty: function(node, elements) {
            var self = this, i, attributes, type, walker, name, brCount = 0;
            node = node.firstChild;
            if (node) {
                walker = new tinymce.dom.TreeWalker(node, node.parentNode);
                elements = elements || self.schema ? self.schema.getNonEmptyElements() : null;
                do {
                    type = node.nodeType;
                    if (1 === type) {
                        if (node.getAttribute("data-mce-bogus")) continue;
                        name = node.nodeName.toLowerCase();
                        if (elements && elements[name]) {
                            if ("br" === name) {
                                brCount++;
                                continue;
                            }
                            return false;
                        }
                        attributes = self.getAttribs(node);
                        i = node.attributes.length;
                        while (i--) {
                            name = node.attributes[i].nodeName;
                            if ("name" === name || "data-mce-bookmark" === name) return false;
                        }
                    }
                    if (8 == type) return false;
                    if (3 === type && !whiteSpaceRegExp.test(node.nodeValue)) return false;
                } while (node = walker.next());
            }
            return brCount <= 1;
        },
        destroy: function(s) {
            var t = this;
            t.win = t.doc = t.root = t.events = t.frag = null;
            if (!s) tinymce.removeUnload(t.destroy);
        },
        createRng: function() {
            var d = this.doc;
            return d.createRange ? d.createRange() : new tinymce.dom.Range(this);
        },
        nodeIndex: function(node, normalized) {
            var idx = 0, lastNodeType, lastNode, nodeType;
            if (node) for (lastNodeType = node.nodeType, node = node.previousSibling, lastNode = node; node; node = node.previousSibling) {
                nodeType = node.nodeType;
                if (normalized && 3 == nodeType) if (nodeType == lastNodeType || !node.nodeValue.length) continue;
                idx++;
                lastNodeType = nodeType;
            }
            return idx;
        },
        split: function(pe, e, re) {
            var t = this, r = t.createRng(), bef, aft, pa;
            function trim(node) {
                var i, children = node.childNodes, type = node.nodeType;
                function surroundedBySpans(node) {
                    var previousIsSpan = node.previousSibling && "SPAN" == node.previousSibling.nodeName;
                    var nextIsSpan = node.nextSibling && "SPAN" == node.nextSibling.nodeName;
                    return previousIsSpan && nextIsSpan;
                }
                if (1 == type && "bookmark" == node.getAttribute("data-mce-type")) return;
                for (i = children.length - 1; i >= 0; i--) trim(children[i]);
                if (9 != type) {
                    if (3 == type && node.nodeValue.length > 0) {
                        var trimmedLength = tinymce.trim(node.nodeValue).length;
                        if (!t.isBlock(node.parentNode) || trimmedLength > 0 || 0 === trimmedLength && surroundedBySpans(node)) return;
                    } else if (1 == type) {
                        children = node.childNodes;
                        if (1 == children.length && children[0] && 1 == children[0].nodeType && "bookmark" == children[0].getAttribute("data-mce-type")) node.parentNode.insertBefore(children[0], node);
                        if (children.length || /^(br|hr|input|img)$/i.test(node.nodeName)) return;
                    }
                    t.remove(node);
                }
                return node;
            }
            if (pe && e) {
                r.setStart(pe.parentNode, t.nodeIndex(pe));
                r.setEnd(e.parentNode, t.nodeIndex(e));
                bef = r.extractContents();
                r = t.createRng();
                r.setStart(e.parentNode, t.nodeIndex(e) + 1);
                r.setEnd(pe.parentNode, t.nodeIndex(pe) + 1);
                aft = r.extractContents();
                pa = pe.parentNode;
                pa.insertBefore(trim(bef), pe);
                if (re) pa.replaceChild(re, e); else pa.insertBefore(e, pe);
                pa.insertBefore(trim(aft), pe);
                t.remove(pe);
                return re || e;
            }
        },
        bind: function(target, name, func, scope) {
            return this.events.add(target, name, func, scope || this);
        },
        unbind: function(target, name, func) {
            return this.events.remove(target, name, func);
        },
        fire: function(target, name, evt) {
            return this.events.fire(target, name, evt);
        },
        getContentEditable: function(node) {
            var contentEditable;
            if (1 != node.nodeType) return null;
            contentEditable = node.getAttribute("data-mce-contenteditable");
            if (contentEditable && "inherit" !== contentEditable) return contentEditable;
            return "inherit" !== node.contentEditable ? node.contentEditable : null;
        },
        _findSib: function(node, selector, name) {
            var t = this, f = selector;
            if (node) {
                if (is(f, "string")) f = function(node) {
                    return t.is(node, selector);
                };
                for (node = node[name]; node; node = node[name]) if (f(node)) return node;
            }
            return null;
        },
        _isRes: function(c) {
            return /^(top|left|bottom|right|width|height)/i.test(c) || /;\s*(top|left|bottom|right|width|height)/i.test(c);
        }
    });
    tinymce.DOM = new tinymce.dom.DOMUtils(document, {
        process_html: 0
    });
})(tinymce);

(function(ns) {
    function Range(dom) {
        var t = this, doc = dom.doc, EXTRACT = 0, CLONE = 1, DELETE = 2, TRUE = true, FALSE = false, START_OFFSET = "startOffset", START_CONTAINER = "startContainer", END_CONTAINER = "endContainer", END_OFFSET = "endOffset", extend = tinymce.extend, nodeIndex = dom.nodeIndex;
        extend(t, {
            startContainer: doc,
            startOffset: 0,
            endContainer: doc,
            endOffset: 0,
            collapsed: TRUE,
            commonAncestorContainer: doc,
            START_TO_START: 0,
            START_TO_END: 1,
            END_TO_END: 2,
            END_TO_START: 3,
            setStart: setStart,
            setEnd: setEnd,
            setStartBefore: setStartBefore,
            setStartAfter: setStartAfter,
            setEndBefore: setEndBefore,
            setEndAfter: setEndAfter,
            collapse: collapse,
            selectNode: selectNode,
            selectNodeContents: selectNodeContents,
            compareBoundaryPoints: compareBoundaryPoints,
            deleteContents: deleteContents,
            extractContents: extractContents,
            cloneContents: cloneContents,
            insertNode: insertNode,
            surroundContents: surroundContents,
            cloneRange: cloneRange,
            toStringIE: toStringIE
        });
        function createDocumentFragment() {
            return doc.createDocumentFragment();
        }
        function setStart(n, o) {
            _setEndPoint(TRUE, n, o);
        }
        function setEnd(n, o) {
            _setEndPoint(FALSE, n, o);
        }
        function setStartBefore(n) {
            setStart(n.parentNode, nodeIndex(n));
        }
        function setStartAfter(n) {
            setStart(n.parentNode, nodeIndex(n) + 1);
        }
        function setEndBefore(n) {
            setEnd(n.parentNode, nodeIndex(n));
        }
        function setEndAfter(n) {
            setEnd(n.parentNode, nodeIndex(n) + 1);
        }
        function collapse(ts) {
            if (ts) {
                t[END_CONTAINER] = t[START_CONTAINER];
                t[END_OFFSET] = t[START_OFFSET];
            } else {
                t[START_CONTAINER] = t[END_CONTAINER];
                t[START_OFFSET] = t[END_OFFSET];
            }
            t.collapsed = TRUE;
        }
        function selectNode(n) {
            setStartBefore(n);
            setEndAfter(n);
        }
        function selectNodeContents(n) {
            setStart(n, 0);
            setEnd(n, 1 === n.nodeType ? n.childNodes.length : n.nodeValue.length);
        }
        function compareBoundaryPoints(h, r) {
            var sc = t[START_CONTAINER], so = t[START_OFFSET], ec = t[END_CONTAINER], eo = t[END_OFFSET], rsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;
            if (0 === h) return _compareBoundaryPoints(sc, so, rsc, rso);
            if (1 === h) return _compareBoundaryPoints(ec, eo, rsc, rso);
            if (2 === h) return _compareBoundaryPoints(ec, eo, rec, reo);
            if (3 === h) return _compareBoundaryPoints(sc, so, rec, reo);
        }
        function deleteContents() {
            _traverse(DELETE);
        }
        function extractContents() {
            return _traverse(EXTRACT);
        }
        function cloneContents() {
            return _traverse(CLONE);
        }
        function insertNode(n) {
            var startContainer = this[START_CONTAINER], startOffset = this[START_OFFSET], nn, o;
            if ((3 === startContainer.nodeType || 4 === startContainer.nodeType) && startContainer.nodeValue) if (!startOffset) startContainer.parentNode.insertBefore(n, startContainer); else if (startOffset >= startContainer.nodeValue.length) dom.insertAfter(n, startContainer); else {
                nn = startContainer.splitText(startOffset);
                startContainer.parentNode.insertBefore(n, nn);
            } else {
                if (startContainer.childNodes.length > 0) o = startContainer.childNodes[startOffset];
                if (o) startContainer.insertBefore(n, o); else startContainer.appendChild(n);
            }
        }
        function surroundContents(n) {
            var f = t.extractContents();
            t.insertNode(n);
            n.appendChild(f);
            t.selectNode(n);
        }
        function cloneRange() {
            return extend(new Range(dom), {
                startContainer: t[START_CONTAINER],
                startOffset: t[START_OFFSET],
                endContainer: t[END_CONTAINER],
                endOffset: t[END_OFFSET],
                collapsed: t.collapsed,
                commonAncestorContainer: t.commonAncestorContainer
            });
        }
        function _getSelectedNode(container, offset) {
            var child;
            if (3 == container.nodeType) return container;
            if (offset < 0) return container;
            child = container.firstChild;
            while (child && offset > 0) {
                --offset;
                child = child.nextSibling;
            }
            if (child) return child;
            return container;
        }
        function _isCollapsed() {
            return t[START_CONTAINER] == t[END_CONTAINER] && t[START_OFFSET] == t[END_OFFSET];
        }
        function _compareBoundaryPoints(containerA, offsetA, containerB, offsetB) {
            var c, offsetC, n, cmnRoot, childA, childB;
            if (containerA == containerB) {
                if (offsetA == offsetB) return 0;
                if (offsetA < offsetB) return -1;
                return 1;
            }
            c = containerB;
            while (c && c.parentNode != containerA) c = c.parentNode;
            if (c) {
                offsetC = 0;
                n = containerA.firstChild;
                while (n != c && offsetC < offsetA) {
                    offsetC++;
                    n = n.nextSibling;
                }
                if (offsetA <= offsetC) return -1;
                return 1;
            }
            c = containerA;
            while (c && c.parentNode != containerB) c = c.parentNode;
            if (c) {
                offsetC = 0;
                n = containerB.firstChild;
                while (n != c && offsetC < offsetB) {
                    offsetC++;
                    n = n.nextSibling;
                }
                if (offsetC < offsetB) return -1;
                return 1;
            }
            cmnRoot = dom.findCommonAncestor(containerA, containerB);
            childA = containerA;
            while (childA && childA.parentNode != cmnRoot) childA = childA.parentNode;
            if (!childA) childA = cmnRoot;
            childB = containerB;
            while (childB && childB.parentNode != cmnRoot) childB = childB.parentNode;
            if (!childB) childB = cmnRoot;
            if (childA == childB) return 0;
            n = cmnRoot.firstChild;
            while (n) {
                if (n == childA) return -1;
                if (n == childB) return 1;
                n = n.nextSibling;
            }
        }
        function _setEndPoint(st, n, o) {
            var ec, sc;
            if (st) {
                t[START_CONTAINER] = n;
                t[START_OFFSET] = o;
            } else {
                t[END_CONTAINER] = n;
                t[END_OFFSET] = o;
            }
            ec = t[END_CONTAINER];
            while (ec.parentNode) ec = ec.parentNode;
            sc = t[START_CONTAINER];
            while (sc.parentNode) sc = sc.parentNode;
            if (sc == ec) {
                if (_compareBoundaryPoints(t[START_CONTAINER], t[START_OFFSET], t[END_CONTAINER], t[END_OFFSET]) > 0) t.collapse(st);
            } else t.collapse(st);
            t.collapsed = _isCollapsed();
            t.commonAncestorContainer = dom.findCommonAncestor(t[START_CONTAINER], t[END_CONTAINER]);
        }
        function _traverse(how) {
            var c, endContainerDepth = 0, startContainerDepth = 0, p, depthDiff, startNode, endNode, sp, ep;
            if (t[START_CONTAINER] == t[END_CONTAINER]) return _traverseSameContainer(how);
            for (c = t[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
                if (p == t[START_CONTAINER]) return _traverseCommonStartContainer(c, how);
                ++endContainerDepth;
            }
            for (c = t[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
                if (p == t[END_CONTAINER]) return _traverseCommonEndContainer(c, how);
                ++startContainerDepth;
            }
            depthDiff = startContainerDepth - endContainerDepth;
            startNode = t[START_CONTAINER];
            while (depthDiff > 0) {
                startNode = startNode.parentNode;
                depthDiff--;
            }
            endNode = t[END_CONTAINER];
            while (depthDiff < 0) {
                endNode = endNode.parentNode;
                depthDiff++;
            }
            for (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, 
            ep = ep.parentNode) {
                startNode = sp;
                endNode = ep;
            }
            return _traverseCommonAncestors(startNode, endNode, how);
        }
        function _traverseSameContainer(how) {
            var frag, s, sub, n, cnt, sibling, xferNode, start, len;
            if (how != DELETE) frag = createDocumentFragment();
            if (t[START_OFFSET] == t[END_OFFSET]) return frag;
            if (3 == t[START_CONTAINER].nodeType) {
                s = t[START_CONTAINER].nodeValue;
                sub = s.substring(t[START_OFFSET], t[END_OFFSET]);
                if (how != CLONE) {
                    n = t[START_CONTAINER];
                    start = t[START_OFFSET];
                    len = t[END_OFFSET] - t[START_OFFSET];
                    if (0 === start && len >= n.nodeValue.length - 1) n.parentNode.removeChild(n); else n.deleteData(start, len);
                    t.collapse(TRUE);
                }
                if (how == DELETE) return;
                if (sub.length > 0) frag.appendChild(doc.createTextNode(sub));
                return frag;
            }
            n = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]);
            cnt = t[END_OFFSET] - t[START_OFFSET];
            while (n && cnt > 0) {
                sibling = n.nextSibling;
                xferNode = _traverseFullySelected(n, how);
                if (frag) frag.appendChild(xferNode);
                --cnt;
                n = sibling;
            }
            if (how != CLONE) t.collapse(TRUE);
            return frag;
        }
        function _traverseCommonStartContainer(endAncestor, how) {
            var frag, n, endIdx, cnt, sibling, xferNode;
            if (how != DELETE) frag = createDocumentFragment();
            n = _traverseRightBoundary(endAncestor, how);
            if (frag) frag.appendChild(n);
            endIdx = nodeIndex(endAncestor);
            cnt = endIdx - t[START_OFFSET];
            if (cnt <= 0) {
                if (how != CLONE) {
                    t.setEndBefore(endAncestor);
                    t.collapse(FALSE);
                }
                return frag;
            }
            n = endAncestor.previousSibling;
            while (cnt > 0) {
                sibling = n.previousSibling;
                xferNode = _traverseFullySelected(n, how);
                if (frag) frag.insertBefore(xferNode, frag.firstChild);
                --cnt;
                n = sibling;
            }
            if (how != CLONE) {
                t.setEndBefore(endAncestor);
                t.collapse(FALSE);
            }
            return frag;
        }
        function _traverseCommonEndContainer(startAncestor, how) {
            var frag, startIdx, n, cnt, sibling, xferNode;
            if (how != DELETE) frag = createDocumentFragment();
            n = _traverseLeftBoundary(startAncestor, how);
            if (frag) frag.appendChild(n);
            startIdx = nodeIndex(startAncestor);
            ++startIdx;
            cnt = t[END_OFFSET] - startIdx;
            n = startAncestor.nextSibling;
            while (n && cnt > 0) {
                sibling = n.nextSibling;
                xferNode = _traverseFullySelected(n, how);
                if (frag) frag.appendChild(xferNode);
                --cnt;
                n = sibling;
            }
            if (how != CLONE) {
                t.setStartAfter(startAncestor);
                t.collapse(TRUE);
            }
            return frag;
        }
        function _traverseCommonAncestors(startAncestor, endAncestor, how) {
            var n, frag, commonParent, startOffset, endOffset, cnt, sibling, nextSibling;
            if (how != DELETE) frag = createDocumentFragment();
            n = _traverseLeftBoundary(startAncestor, how);
            if (frag) frag.appendChild(n);
            commonParent = startAncestor.parentNode;
            startOffset = nodeIndex(startAncestor);
            endOffset = nodeIndex(endAncestor);
            ++startOffset;
            cnt = endOffset - startOffset;
            sibling = startAncestor.nextSibling;
            while (cnt > 0) {
                nextSibling = sibling.nextSibling;
                n = _traverseFullySelected(sibling, how);
                if (frag) frag.appendChild(n);
                sibling = nextSibling;
                --cnt;
            }
            n = _traverseRightBoundary(endAncestor, how);
            if (frag) frag.appendChild(n);
            if (how != CLONE) {
                t.setStartAfter(startAncestor);
                t.collapse(TRUE);
            }
            return frag;
        }
        function _traverseRightBoundary(root, how) {
            var next = _getSelectedNode(t[END_CONTAINER], t[END_OFFSET] - 1), parent, clonedParent, prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != t[END_CONTAINER];
            if (next == root) return _traverseNode(next, isFullySelected, FALSE, how);
            parent = next.parentNode;
            clonedParent = _traverseNode(parent, FALSE, FALSE, how);
            while (parent) {
                while (next) {
                    prevSibling = next.previousSibling;
                    clonedChild = _traverseNode(next, isFullySelected, FALSE, how);
                    if (how != DELETE) clonedParent.insertBefore(clonedChild, clonedParent.firstChild);
                    isFullySelected = TRUE;
                    next = prevSibling;
                }
                if (parent == root) return clonedParent;
                next = parent.previousSibling;
                parent = parent.parentNode;
                clonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);
                if (how != DELETE) clonedGrandParent.appendChild(clonedParent);
                clonedParent = clonedGrandParent;
            }
        }
        function _traverseLeftBoundary(root, how) {
            var next = _getSelectedNode(t[START_CONTAINER], t[START_OFFSET]), isFullySelected = next != t[START_CONTAINER], parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;
            if (next == root) return _traverseNode(next, isFullySelected, TRUE, how);
            parent = next.parentNode;
            clonedParent = _traverseNode(parent, FALSE, TRUE, how);
            while (parent) {
                while (next) {
                    nextSibling = next.nextSibling;
                    clonedChild = _traverseNode(next, isFullySelected, TRUE, how);
                    if (how != DELETE) clonedParent.appendChild(clonedChild);
                    isFullySelected = TRUE;
                    next = nextSibling;
                }
                if (parent == root) return clonedParent;
                next = parent.nextSibling;
                parent = parent.parentNode;
                clonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);
                if (how != DELETE) clonedGrandParent.appendChild(clonedParent);
                clonedParent = clonedGrandParent;
            }
        }
        function _traverseNode(n, isFullySelected, isLeft, how) {
            var txtValue, newNodeValue, oldNodeValue, offset, newNode;
            if (isFullySelected) return _traverseFullySelected(n, how);
            if (3 == n.nodeType) {
                txtValue = n.nodeValue;
                if (isLeft) {
                    offset = t[START_OFFSET];
                    newNodeValue = txtValue.substring(offset);
                    oldNodeValue = txtValue.substring(0, offset);
                } else {
                    offset = t[END_OFFSET];
                    newNodeValue = txtValue.substring(0, offset);
                    oldNodeValue = txtValue.substring(offset);
                }
                if (how != CLONE) n.nodeValue = oldNodeValue;
                if (how == DELETE) return;
                newNode = dom.clone(n, FALSE);
                newNode.nodeValue = newNodeValue;
                return newNode;
            }
            if (how == DELETE) return;
            return dom.clone(n, FALSE);
        }
        function _traverseFullySelected(n, how) {
            if (how != DELETE) return how == CLONE ? dom.clone(n, TRUE) : n;
            n.parentNode.removeChild(n);
        }
        function toStringIE() {
            return dom.create("body", null, cloneContents()).outerText;
        }
        return t;
    }
    ns.Range = Range;
    Range.prototype.toString = function() {
        return this.toStringIE();
    };
})(tinymce.dom);

(function() {
    function Selection(selection) {
        var self = this, dom = selection.dom, TRUE = true, FALSE = false;
        function getPosition(rng, start) {
            var checkRng, startIndex = 0, endIndex, inside, children, child, offset, index, position = -1, parent;
            checkRng = rng.duplicate();
            checkRng.collapse(start);
            parent = checkRng.parentElement();
            if (parent.ownerDocument !== selection.dom.doc) return;
            while ("false" === parent.contentEditable) parent = parent.parentNode;
            if (!parent.hasChildNodes()) return {
                node: parent,
                inside: 1
            };
            children = parent.children;
            endIndex = children.length - 1;
            while (startIndex <= endIndex) {
                index = Math.floor((startIndex + endIndex) / 2);
                child = children[index];
                checkRng.moveToElementText(child);
                position = checkRng.compareEndPoints(start ? "StartToStart" : "EndToEnd", rng);
                if (position > 0) endIndex = index - 1; else if (position < 0) startIndex = index + 1; else return {
                    node: child
                };
            }
            if (position < 0) {
                if (!child) {
                    checkRng.moveToElementText(parent);
                    checkRng.collapse(true);
                    child = parent;
                    inside = true;
                } else checkRng.collapse(false);
                offset = 0;
                while (0 !== checkRng.compareEndPoints(start ? "StartToStart" : "StartToEnd", rng)) {
                    if (0 === checkRng.move("character", 1) || parent != checkRng.parentElement()) break;
                    offset++;
                }
            } else {
                checkRng.collapse(true);
                offset = 0;
                while (0 !== checkRng.compareEndPoints(start ? "StartToStart" : "StartToEnd", rng)) {
                    if (0 === checkRng.move("character", -1) || parent != checkRng.parentElement()) break;
                    offset++;
                }
            }
            return {
                node: child,
                position: position,
                offset: offset,
                inside: inside
            };
        }
        function getRange() {
            var ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark, fail;
            element = ieRange.item ? ieRange.item(0) : ieRange.parentElement();
            if (element.ownerDocument != dom.doc) return domRange;
            collapsed = selection.isCollapsed();
            if (ieRange.item) {
                domRange.setStart(element.parentNode, dom.nodeIndex(element));
                domRange.setEnd(domRange.startContainer, domRange.startOffset + 1);
                return domRange;
            }
            function findEndPoint(start) {
                var endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = 0, sibling, undef, nodeValue;
                container = endPoint.node;
                offset = endPoint.offset;
                if (endPoint.inside && !container.hasChildNodes()) {
                    domRange[start ? "setStart" : "setEnd"](container, 0);
                    return;
                }
                if (offset === undef) {
                    domRange[start ? "setStartBefore" : "setEndAfter"](container);
                    return;
                }
                if (endPoint.position < 0) {
                    sibling = endPoint.inside ? container.firstChild : container.nextSibling;
                    if (!sibling) {
                        domRange[start ? "setStartAfter" : "setEndAfter"](container);
                        return;
                    }
                    if (!offset) {
                        if (3 == sibling.nodeType) domRange[start ? "setStart" : "setEnd"](sibling, 0); else domRange[start ? "setStartBefore" : "setEndBefore"](sibling);
                        return;
                    }
                    while (sibling) {
                        nodeValue = sibling.nodeValue;
                        textNodeOffset += nodeValue.length;
                        if (textNodeOffset >= offset) {
                            container = sibling;
                            textNodeOffset -= offset;
                            textNodeOffset = nodeValue.length - textNodeOffset;
                            break;
                        }
                        sibling = sibling.nextSibling;
                    }
                } else {
                    sibling = container.previousSibling;
                    if (!sibling) return domRange[start ? "setStartBefore" : "setEndBefore"](container);
                    if (!offset) {
                        if (3 == container.nodeType) domRange[start ? "setStart" : "setEnd"](sibling, container.nodeValue.length); else domRange[start ? "setStartAfter" : "setEndAfter"](sibling);
                        return;
                    }
                    while (sibling) {
                        textNodeOffset += sibling.nodeValue.length;
                        if (textNodeOffset >= offset) {
                            container = sibling;
                            textNodeOffset -= offset;
                            break;
                        }
                        sibling = sibling.previousSibling;
                    }
                }
                domRange[start ? "setStart" : "setEnd"](container, textNodeOffset);
            }
            try {
                findEndPoint(true);
                if (!collapsed) findEndPoint();
            } catch (ex) {
                if (ex.number == -2147024809) {
                    bookmark = self.getBookmark(2);
                    tmpRange = ieRange.duplicate();
                    tmpRange.collapse(true);
                    element = tmpRange.parentElement();
                    if (!collapsed) {
                        tmpRange = ieRange.duplicate();
                        tmpRange.collapse(false);
                        element2 = tmpRange.parentElement();
                        element2.innerHTML = element2.innerHTML;
                    }
                    element.innerHTML = element.innerHTML;
                    self.moveToBookmark(bookmark);
                    ieRange = selection.getRng();
                    findEndPoint(true);
                    if (!collapsed) findEndPoint();
                } else throw ex;
            }
            return domRange;
        }
        this.getBookmark = function(type) {
            var rng = selection.getRng(), start, end, bookmark = {};
            function getIndexes(node) {
                var parent, root, children, i, indexes = [];
                parent = node.parentNode;
                root = dom.getRoot().parentNode;
                while (parent != root && 9 !== parent.nodeType) {
                    children = parent.children;
                    i = children.length;
                    while (i--) if (node === children[i]) {
                        indexes.push(i);
                        break;
                    }
                    node = parent;
                    parent = parent.parentNode;
                }
                return indexes;
            }
            function getBookmarkEndPoint(start) {
                var position;
                position = getPosition(rng, start);
                if (position) return {
                    position: position.position,
                    offset: position.offset,
                    indexes: getIndexes(position.node),
                    inside: position.inside
                };
            }
            if (2 === type) if (!rng.item) {
                bookmark.start = getBookmarkEndPoint(true);
                if (!selection.isCollapsed()) bookmark.end = getBookmarkEndPoint();
            } else bookmark.start = {
                ctrl: true,
                indexes: getIndexes(rng.item(0))
            };
            return bookmark;
        };
        this.moveToBookmark = function(bookmark) {
            var rng, body = dom.doc.body;
            function resolveIndexes(indexes) {
                var node, i, idx, children;
                node = dom.getRoot();
                for (i = indexes.length - 1; i >= 0; i--) {
                    children = node.children;
                    idx = indexes[i];
                    if (idx <= children.length - 1) node = children[idx];
                }
                return node;
            }
            function setBookmarkEndPoint(start) {
                var endPoint = bookmark[start ? "start" : "end"], moveLeft, moveRng, undef;
                if (endPoint) {
                    moveLeft = endPoint.position > 0;
                    moveRng = body.createTextRange();
                    moveRng.moveToElementText(resolveIndexes(endPoint.indexes));
                    offset = endPoint.offset;
                    if (offset !== undef) {
                        moveRng.collapse(endPoint.inside || moveLeft);
                        moveRng.moveStart("character", moveLeft ? -offset : offset);
                    } else moveRng.collapse(start);
                    rng.setEndPoint(start ? "StartToStart" : "EndToStart", moveRng);
                    if (start) rng.collapse(true);
                }
            }
            if (bookmark.start) if (bookmark.start.ctrl) {
                rng = body.createControlRange();
                rng.addElement(resolveIndexes(bookmark.start.indexes));
                rng.select();
            } else {
                rng = body.createTextRange();
                setBookmarkEndPoint(true);
                setBookmarkEndPoint();
                rng.select();
            }
        };
        this.addRange = function(rng) {
            var ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, sibling, doc = selection.dom.doc, body = doc.body, nativeRng, ctrlElm;
            function setEndPoint(start) {
                var container, offset, marker, tmpRng, nodes;
                marker = dom.create("a");
                container = start ? startContainer : endContainer;
                offset = start ? startOffset : endOffset;
                tmpRng = ieRng.duplicate();
                if (container == doc || container == doc.documentElement) {
                    container = body;
                    offset = 0;
                }
                if (3 == container.nodeType) {
                    container.parentNode.insertBefore(marker, container);
                    tmpRng.moveToElementText(marker);
                    tmpRng.moveStart("character", offset);
                    dom.remove(marker);
                    ieRng.setEndPoint(start ? "StartToStart" : "EndToEnd", tmpRng);
                } else {
                    nodes = container.childNodes;
                    if (nodes.length) {
                        if (offset >= nodes.length) dom.insertAfter(marker, nodes[nodes.length - 1]); else container.insertBefore(marker, nodes[offset]);
                        tmpRng.moveToElementText(marker);
                    } else if (container.canHaveHTML) {
                        container.innerHTML = "<span>﻿</span>";
                        marker = container.firstChild;
                        tmpRng.moveToElementText(marker);
                        tmpRng.collapse(FALSE);
                    }
                    ieRng.setEndPoint(start ? "StartToStart" : "EndToEnd", tmpRng);
                    dom.remove(marker);
                }
            }
            startContainer = rng.startContainer;
            startOffset = rng.startOffset;
            endContainer = rng.endContainer;
            endOffset = rng.endOffset;
            ieRng = body.createTextRange();
            if (startContainer == endContainer && 1 == startContainer.nodeType) {
                if (startOffset == endOffset && !startContainer.hasChildNodes()) if (startContainer.canHaveHTML) {
                    sibling = startContainer.previousSibling;
                    if (sibling && !sibling.hasChildNodes() && dom.isBlock(sibling)) sibling.innerHTML = "﻿"; else sibling = null;
                    startContainer.innerHTML = "<span>﻿</span><span>﻿</span>";
                    ieRng.moveToElementText(startContainer.lastChild);
                    ieRng.select();
                    dom.doc.selection.clear();
                    startContainer.innerHTML = "";
                    if (sibling) sibling.innerHTML = "";
                    return;
                } else {
                    startOffset = dom.nodeIndex(startContainer);
                    startContainer = startContainer.parentNode;
                }
                if (startOffset == endOffset - 1) try {
                    ctrlElm = startContainer.childNodes[startOffset];
                    ctrlRng = body.createControlRange();
                    ctrlRng.addElement(ctrlElm);
                    ctrlRng.select();
                    nativeRng = selection.getRng();
                    if (nativeRng.item && ctrlElm === nativeRng.item(0)) return;
                } catch (ex) {}
            }
            setEndPoint(true);
            setEndPoint();
            ieRng.select();
        };
        this.getRangeAt = getRange;
    }
    tinymce.dom.TridentSelection = Selection;
})();

(function(tinymce) {
    tinymce.dom.Element = function(id, settings) {
        var t = this, dom, el;
        t.settings = settings = settings || {};
        t.id = id;
        t.dom = dom = settings.dom || tinymce.DOM;
        if (!tinymce.isIE) el = dom.get(t.id);
        tinymce.each(("getPos,getRect,getParent,add,setStyle,getStyle,setStyles," + "setAttrib,setAttribs,getAttrib,addClass,removeClass," + "hasClass,getOuterHTML,setOuterHTML,remove,show,hide," + "isHidden,setHTML,get").split(/,/), function(k) {
            t[k] = function() {
                var a = [ id ], i;
                for (i = 0; i < arguments.length; i++) a.push(arguments[i]);
                a = dom[k].apply(dom, a);
                t.update(k);
                return a;
            };
        });
        tinymce.extend(t, {
            on: function(n, f, s) {
                return tinymce.dom.Event.add(t.id, n, f, s);
            },
            getXY: function() {
                return {
                    x: parseInt(t.getStyle("left")),
                    y: parseInt(t.getStyle("top"))
                };
            },
            getSize: function() {
                var n = dom.get(t.id);
                return {
                    w: parseInt(t.getStyle("width") || n.clientWidth),
                    h: parseInt(t.getStyle("height") || n.clientHeight)
                };
            },
            moveTo: function(x, y) {
                t.setStyles({
                    left: x,
                    top: y
                });
            },
            moveBy: function(x, y) {
                var p = t.getXY();
                t.moveTo(p.x + x, p.y + y);
            },
            resizeTo: function(w, h) {
                t.setStyles({
                    width: w,
                    height: h
                });
            },
            resizeBy: function(w, h) {
                var s = t.getSize();
                t.resizeTo(s.w + w, s.h + h);
            },
            update: function(k) {
                var b;
                if (tinymce.isIE6 && settings.blocker) {
                    k = k || "";
                    if (0 === k.indexOf("get") || 0 === k.indexOf("has") || 0 === k.indexOf("is")) return;
                    if ("remove" == k) {
                        dom.remove(t.blocker);
                        return;
                    }
                    if (!t.blocker) {
                        t.blocker = dom.uniqueId();
                        b = dom.add(settings.container || dom.getRoot(), "iframe", {
                            id: t.blocker,
                            style: "position:absolute;",
                            frameBorder: 0,
                            src: 'javascript:""'
                        });
                        dom.setStyle(b, "opacity", 0);
                    } else b = dom.get(t.blocker);
                    dom.setStyles(b, {
                        left: t.getStyle("left", 1),
                        top: t.getStyle("top", 1),
                        width: t.getStyle("width", 1),
                        height: t.getStyle("height", 1),
                        display: t.getStyle("display", 1),
                        zIndex: parseInt(t.getStyle("zIndex", 1) || 0) - 1
                    });
                }
            }
        });
    };
})(tinymce);

(function(tinymce) {
    function trimNl(s) {
        return s.replace(/[\n\r]+/g, "");
    }
    var is = tinymce.is, isIE = tinymce.isIE, each = tinymce.each, TreeWalker = tinymce.dom.TreeWalker;
    tinymce.create("tinymce.dom.Selection", {
        Selection: function(dom, win, serializer, editor) {
            var t = this;
            t.dom = dom;
            t.win = win;
            t.serializer = serializer;
            t.editor = editor;
            each([ "onBeforeSetContent", "onBeforeGetContent", "onSetContent", "onGetContent" ], function(e) {
                t[e] = new tinymce.util.Dispatcher(t);
            });
            if (!t.win.getSelection) t.tridentSel = new tinymce.dom.TridentSelection(t);
            if (tinymce.isIE && dom.boxModel) this._fixIESelection();
            tinymce.addUnload(t.destroy, t);
        },
        setCursorLocation: function(node, offset) {
            var t = this;
            var r = t.dom.createRng();
            r.setStart(node, offset);
            r.setEnd(node, offset);
            t.setRng(r);
            t.collapse(false);
        },
        getContent: function(s) {
            var t = this, r = t.getRng(), e = t.dom.create("body"), se = t.getSel(), wb, wa, n;
            s = s || {};
            wb = wa = "";
            s.get = true;
            s.format = s.format || "html";
            s.forced_root_block = "";
            t.onBeforeGetContent.dispatch(t, s);
            if ("text" == s.format) return t.isCollapsed() ? "" : r.text || (se.toString ? se.toString() : "");
            if (r.cloneContents) {
                n = r.cloneContents();
                if (n) e.appendChild(n);
            } else if (is(r.item) || is(r.htmlText)) {
                e.innerHTML = "<br>" + (r.item ? r.item(0).outerHTML : r.htmlText);
                e.removeChild(e.firstChild);
            } else e.innerHTML = r.toString();
            if (/^\s/.test(e.innerHTML)) wb = " ";
            if (/\s+$/.test(e.innerHTML)) wa = " ";
            s.getInner = true;
            s.content = t.isCollapsed() ? "" : wb + t.serializer.serialize(e, s) + wa;
            t.onGetContent.dispatch(t, s);
            return s.content;
        },
        setContent: function(content, args) {
            var self = this, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;
            args = args || {
                format: "html"
            };
            args.set = true;
            content = args.content = content;
            if (!args.no_events) self.onBeforeSetContent.dispatch(self, args);
            content = args.content;
            if (rng.insertNode) {
                content += '<span id="__caret">_</span>';
                if (rng.startContainer == doc && rng.endContainer == doc) doc.body.innerHTML = content; else {
                    rng.deleteContents();
                    if (0 === doc.body.childNodes.length) doc.body.innerHTML = content; else if (rng.createContextualFragment) rng.insertNode(rng.createContextualFragment(content)); else {
                        frag = doc.createDocumentFragment();
                        temp = doc.createElement("div");
                        frag.appendChild(temp);
                        temp.outerHTML = content;
                        rng.insertNode(frag);
                    }
                }
                caretNode = self.dom.get("__caret");
                rng = doc.createRange();
                rng.setStartBefore(caretNode);
                rng.setEndBefore(caretNode);
                self.setRng(rng);
                self.dom.remove("__caret");
                try {
                    self.setRng(rng);
                } catch (ex) {}
            } else {
                if (rng.item) {
                    doc.execCommand("Delete", false, null);
                    rng = self.getRng();
                }
                if (/^\s+/.test(content)) {
                    rng.pasteHTML('<span id="__mce_tmp">_</span>' + content);
                    self.dom.remove("__mce_tmp");
                } else rng.pasteHTML(content);
            }
            if (!args.no_events) self.onSetContent.dispatch(self, args);
        },
        getStart: function() {
            var self = this, rng = self.getRng(), startElement, parentElement, checkRng, node;
            if (rng.duplicate || rng.item) {
                if (rng.item) return rng.item(0);
                checkRng = rng.duplicate();
                checkRng.collapse(1);
                startElement = checkRng.parentElement();
                if (startElement.ownerDocument !== self.dom.doc) startElement = self.dom.getRoot();
                parentElement = node = rng.parentElement();
                while (node = node.parentNode) if (node == startElement) {
                    startElement = parentElement;
                    break;
                }
                return startElement;
            } else {
                startElement = rng.startContainer;
                if (1 == startElement.nodeType && startElement.hasChildNodes()) startElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];
                if (startElement && 3 == startElement.nodeType) return startElement.parentNode;
                return startElement;
            }
        },
        getEnd: function() {
            var self = this, rng = self.getRng(), endElement, endOffset;
            if (rng.duplicate || rng.item) {
                if (rng.item) return rng.item(0);
                rng = rng.duplicate();
                rng.collapse(0);
                endElement = rng.parentElement();
                if (endElement.ownerDocument !== self.dom.doc) endElement = self.dom.getRoot();
                if (endElement && "BODY" == endElement.nodeName) return endElement.lastChild || endElement;
                return endElement;
            } else {
                endElement = rng.endContainer;
                endOffset = rng.endOffset;
                if (1 == endElement.nodeType && endElement.hasChildNodes()) endElement = endElement.childNodes[endOffset > 0 ? endOffset - 1 : endOffset];
                if (endElement && 3 == endElement.nodeType) return endElement.parentNode;
                return endElement;
            }
        },
        getBookmark: function(type, normalized) {
            var t = this, dom = t.dom, rng, rng2, id, collapsed, name, element, index, chr = "﻿", styles;
            function findIndex(name, element) {
                var index = 0;
                each(dom.select(name), function(node, i) {
                    if (node == element) index = i;
                });
                return index;
            }
            function normalizeTableCellSelection(rng) {
                function moveEndPoint(start) {
                    var container, offset, childNodes, prefix = start ? "start" : "end";
                    container = rng[prefix + "Container"];
                    offset = rng[prefix + "Offset"];
                    if (1 == container.nodeType && "TR" == container.nodeName) {
                        childNodes = container.childNodes;
                        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
                        if (container) {
                            offset = start ? 0 : container.childNodes.length;
                            rng["set" + (start ? "Start" : "End")](container, offset);
                        }
                    }
                }
                moveEndPoint(true);
                moveEndPoint();
                return rng;
            }
            function getLocation() {
                var rng = t.getRng(true), root = dom.getRoot(), bookmark = {};
                function getPoint(rng, start) {
                    var container = rng[start ? "startContainer" : "endContainer"], offset = rng[start ? "startOffset" : "endOffset"], point = [], node, childNodes, after = 0;
                    if (3 == container.nodeType) {
                        if (normalized) for (node = container.previousSibling; node && 3 == node.nodeType; node = node.previousSibling) offset += node.nodeValue.length;
                        point.push(offset);
                    } else {
                        childNodes = container.childNodes;
                        if (offset >= childNodes.length && childNodes.length) {
                            after = 1;
                            offset = Math.max(0, childNodes.length - 1);
                        }
                        point.push(t.dom.nodeIndex(childNodes[offset], normalized) + after);
                    }
                    for (;container && container != root; container = container.parentNode) point.push(t.dom.nodeIndex(container, normalized));
                    return point;
                }
                bookmark.start = getPoint(rng, true);
                if (!t.isCollapsed()) bookmark.end = getPoint(rng);
                return bookmark;
            }
            if (2 == type) {
                if (t.tridentSel) return t.tridentSel.getBookmark(type);
                return getLocation();
            }
            if (type) return {
                rng: t.getRng()
            };
            rng = t.getRng();
            id = dom.uniqueId();
            collapsed = tinyMCE.activeEditor.selection.isCollapsed();
            styles = "overflow:hidden;line-height:0px";
            if (rng.duplicate || rng.item) if (!rng.item) {
                rng2 = rng.duplicate();
                try {
                    rng.collapse();
                    rng.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_start" style="' + styles + '">' + chr + "</span>");
                    if (!collapsed) {
                        rng2.collapse(false);
                        rng.moveToElementText(rng2.parentElement());
                        if (0 === rng.compareEndPoints("StartToEnd", rng2)) rng2.move("character", -1);
                        rng2.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_end" style="' + styles + '">' + chr + "</span>");
                    }
                } catch (ex) {
                    return null;
                }
            } else {
                element = rng.item(0);
                name = element.nodeName;
                return {
                    name: name,
                    index: findIndex(name, element)
                };
            } else {
                element = t.getNode();
                name = element.nodeName;
                if ("IMG" == name) return {
                    name: name,
                    index: findIndex(name, element)
                };
                rng2 = normalizeTableCellSelection(rng.cloneRange());
                if (!collapsed) {
                    rng2.collapse(false);
                    rng2.insertNode(dom.create("span", {
                        "data-mce-type": "bookmark",
                        id: id + "_end",
                        style: styles
                    }, chr));
                }
                rng = normalizeTableCellSelection(rng);
                rng.collapse(true);
                rng.insertNode(dom.create("span", {
                    "data-mce-type": "bookmark",
                    id: id + "_start",
                    style: styles
                }, chr));
            }
            t.moveToBookmark({
                id: id,
                keep: 1
            });
            return {
                id: id
            };
        },
        moveToBookmark: function(bookmark) {
            var t = this, dom = t.dom, marker1, marker2, rng, root, startContainer, endContainer, startOffset, endOffset;
            function setEndPoint(start) {
                var point = bookmark[start ? "start" : "end"], i, node, offset, children;
                if (point) {
                    offset = point[0];
                    for (node = root, i = point.length - 1; i >= 1; i--) {
                        children = node.childNodes;
                        if (point[i] > children.length - 1) return;
                        node = children[point[i]];
                    }
                    if (3 === node.nodeType) offset = Math.min(point[0], node.nodeValue.length);
                    if (1 === node.nodeType) offset = Math.min(point[0], node.childNodes.length);
                    if (start) rng.setStart(node, offset); else rng.setEnd(node, offset);
                }
                return true;
            }
            function restoreEndPoint(suffix) {
                var marker = dom.get(bookmark.id + "_" + suffix), node, idx, next, prev, keep = bookmark.keep;
                if (marker) {
                    node = marker.parentNode;
                    if ("start" == suffix) {
                        if (!keep) idx = dom.nodeIndex(marker); else {
                            node = marker.firstChild;
                            idx = 1;
                        }
                        startContainer = endContainer = node;
                        startOffset = endOffset = idx;
                    } else {
                        if (!keep) idx = dom.nodeIndex(marker); else {
                            node = marker.firstChild;
                            idx = 1;
                        }
                        endContainer = node;
                        endOffset = idx;
                    }
                    if (!keep) {
                        prev = marker.previousSibling;
                        next = marker.nextSibling;
                        each(tinymce.grep(marker.childNodes), function(node) {
                            if (3 == node.nodeType) node.nodeValue = node.nodeValue.replace(/\uFEFF/g, "");
                        });
                        while (marker = dom.get(bookmark.id + "_" + suffix)) dom.remove(marker, 1);
                        if (prev && next && prev.nodeType == next.nodeType && 3 == prev.nodeType && !tinymce.isOpera) {
                            idx = prev.nodeValue.length;
                            prev.appendData(next.nodeValue);
                            dom.remove(next);
                            if ("start" == suffix) {
                                startContainer = endContainer = prev;
                                startOffset = endOffset = idx;
                            } else {
                                endContainer = prev;
                                endOffset = idx;
                            }
                        }
                    }
                }
            }
            function addBogus(node) {
                if (dom.isBlock(node) && !node.innerHTML && !isIE) node.innerHTML = '<br data-mce-bogus="1" />';
                return node;
            }
            if (bookmark) if (bookmark.start) {
                rng = dom.createRng();
                root = dom.getRoot();
                if (t.tridentSel) return t.tridentSel.moveToBookmark(bookmark);
                if (setEndPoint(true) && setEndPoint()) t.setRng(rng);
            } else if (bookmark.id) {
                restoreEndPoint("start");
                restoreEndPoint("end");
                if (startContainer) {
                    rng = dom.createRng();
                    rng.setStart(addBogus(startContainer), startOffset);
                    rng.setEnd(addBogus(endContainer), endOffset);
                    t.setRng(rng);
                }
            } else if (bookmark.name) t.select(dom.select(bookmark.name)[bookmark.index]); else if (bookmark.rng) t.setRng(bookmark.rng);
        },
        select: function(node, content) {
            var t = this, dom = t.dom, rng = dom.createRng(), idx;
            function setPoint(node, start) {
                var walker = new TreeWalker(node, node);
                do {
                    if (3 == node.nodeType && 0 !== tinymce.trim(node.nodeValue).length) {
                        if (start) rng.setStart(node, 0); else rng.setEnd(node, node.nodeValue.length);
                        return;
                    }
                    if ("BR" == node.nodeName) {
                        if (start) rng.setStartBefore(node); else rng.setEndBefore(node);
                        return;
                    }
                } while (node = start ? walker.next() : walker.prev());
            }
            if (node) {
                idx = dom.nodeIndex(node);
                rng.setStart(node.parentNode, idx);
                rng.setEnd(node.parentNode, idx + 1);
                if (content) {
                    setPoint(node, 1);
                    setPoint(node);
                }
                t.setRng(rng);
            }
            return node;
        },
        isCollapsed: function() {
            var t = this, r = t.getRng(), s = t.getSel();
            if (!r || r.item) return false;
            if (r.compareEndPoints) return 0 === r.compareEndPoints("StartToEnd", r);
            return !s || r.collapsed;
        },
        collapse: function(to_start) {
            var self = this, rng = self.getRng(), node;
            if (rng.item) {
                node = rng.item(0);
                rng = self.win.document.body.createTextRange();
                rng.moveToElementText(node);
            }
            rng.collapse(!!to_start);
            self.setRng(rng);
        },
        getSel: function() {
            var t = this, w = this.win;
            return w.getSelection ? w.getSelection() : w.document.selection;
        },
        getRng: function(w3c) {
            var self = this, selection, rng, elm, doc = self.win.document;
            if (w3c && self.tridentSel) return self.tridentSel.getRangeAt(0);
            try {
                if (selection = self.getSel()) rng = selection.rangeCount > 0 ? selection.getRangeAt(0) : selection.createRange ? selection.createRange() : doc.createRange();
            } catch (ex) {}
            if (tinymce.isIE && rng && rng.setStart && doc.selection.createRange().item) {
                elm = doc.selection.createRange().item(0);
                rng = doc.createRange();
                rng.setStartBefore(elm);
                rng.setEndAfter(elm);
            }
            if (!rng) rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
            if (!tinymce.isIE && rng.setStart && 9 === rng.startContainer.nodeType && rng.collapsed) {
                elm = self.dom.getRoot();
                rng.setStart(elm, 0);
                rng.setEnd(elm, 0);
            }
            if (self.selectedRange && self.explicitRange) if (0 === rng.compareBoundaryPoints(rng.START_TO_START, self.selectedRange) && 0 === rng.compareBoundaryPoints(rng.END_TO_END, self.selectedRange)) rng = self.explicitRange; else {
                self.selectedRange = null;
                self.explicitRange = null;
            }
            return rng;
        },
        setRng: function(r, forward) {
            var s, t = this;
            if (!t.tridentSel) {
                s = t.getSel();
                if (s) {
                    t.explicitRange = r;
                    try {
                        s.removeAllRanges();
                    } catch (ex) {}
                    s.addRange(r);
                    if (false === forward && s.extend) {
                        s.collapse(r.endContainer, r.endOffset);
                        s.extend(r.startContainer, r.startOffset);
                    }
                    t.selectedRange = s.rangeCount > 0 ? s.getRangeAt(0) : null;
                }
            } else {
                if (r.cloneRange) try {
                    t.tridentSel.addRange(r);
                    return;
                } catch (ex) {}
                try {
                    r.select();
                } catch (ex) {}
            }
        },
        setNode: function(n) {
            var t = this;
            t.setContent(t.dom.getOuterHTML(n));
            return n;
        },
        getNode: function() {
            var t = this, rng = t.getRng(), sel = t.getSel(), elm, start = rng.startContainer, end = rng.endContainer;
            function skipEmptyTextNodes(n, forwards) {
                var orig = n;
                while (n && 3 === n.nodeType && 0 === n.length) n = forwards ? n.nextSibling : n.previousSibling;
                return n || orig;
            }
            if (!rng) return t.dom.getRoot();
            if (rng.setStart) {
                elm = rng.commonAncestorContainer;
                if (!rng.collapsed) {
                    if (rng.startContainer == rng.endContainer) if (rng.endOffset - rng.startOffset < 2) if (rng.startContainer.hasChildNodes()) elm = rng.startContainer.childNodes[rng.startOffset];
                    if (3 === start.nodeType && 3 === end.nodeType) {
                        if (start.length === rng.startOffset) start = skipEmptyTextNodes(start.nextSibling, true); else start = start.parentNode;
                        if (0 === rng.endOffset) end = skipEmptyTextNodes(end.previousSibling, false); else end = end.parentNode;
                        if (start && start === end) return start;
                    }
                }
                if (elm && 3 == elm.nodeType) return elm.parentNode;
                return elm;
            }
            return rng.item ? rng.item(0) : rng.parentElement();
        },
        getSelectedBlocks: function(st, en) {
            var t = this, dom = t.dom, sb, eb, n, bl = [];
            sb = dom.getParent(st || t.getStart(), dom.isBlock);
            eb = dom.getParent(en || t.getEnd(), dom.isBlock);
            if (sb) bl.push(sb);
            if (sb && eb && sb != eb) {
                n = sb;
                var walker = new TreeWalker(sb, dom.getRoot());
                while ((n = walker.next()) && n != eb) if (dom.isBlock(n)) bl.push(n);
            }
            if (eb && sb != eb) bl.push(eb);
            return bl;
        },
        isForward: function() {
            var dom = this.dom, sel = this.getSel(), anchorRange, focusRange;
            if (!sel || null == sel.anchorNode || null == sel.focusNode) return true;
            anchorRange = dom.createRng();
            anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
            anchorRange.collapse(true);
            focusRange = dom.createRng();
            focusRange.setStart(sel.focusNode, sel.focusOffset);
            focusRange.collapse(true);
            return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
        },
        normalize: function() {
            var self = this, rng, normalized, collapsed, node, sibling;
            function normalizeEndPoint(start) {
                var container, offset, walker, dom = self.dom, body = dom.getRoot(), node, nonEmptyElementsMap, nodeName;
                function hasBrBeforeAfter(node, left) {
                    var walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);
                    while (node = walker[left ? "prev" : "next"]()) if ("BR" === node.nodeName) return true;
                }
                function findTextNodeRelative(left, startNode) {
                    var walker, lastInlineElement;
                    startNode = startNode || container;
                    walker = new TreeWalker(startNode, dom.getParent(startNode.parentNode, dom.isBlock) || body);
                    while (node = walker[left ? "prev" : "next"]()) {
                        if (3 === node.nodeType && node.nodeValue.length > 0) {
                            container = node;
                            offset = left ? node.nodeValue.length : 0;
                            normalized = true;
                            return;
                        }
                        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) return;
                        lastInlineElement = node;
                    }
                    if (collapsed && lastInlineElement) {
                        container = lastInlineElement;
                        normalized = true;
                        offset = 0;
                    }
                }
                container = rng[(start ? "start" : "end") + "Container"];
                offset = rng[(start ? "start" : "end") + "Offset"];
                nonEmptyElementsMap = dom.schema.getNonEmptyElements();
                if (9 === container.nodeType) {
                    container = dom.getRoot();
                    offset = 0;
                }
                if (container === body) {
                    if (start) {
                        node = container.childNodes[offset > 0 ? offset - 1 : 0];
                        if (node) {
                            nodeName = node.nodeName.toLowerCase();
                            if (nonEmptyElementsMap[node.nodeName] || "TABLE" == node.nodeName) return;
                        }
                    }
                    if (container.hasChildNodes()) {
                        container = container.childNodes[Math.min(!start && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1)];
                        offset = 0;
                        if (container.hasChildNodes() && !/TABLE/.test(container.nodeName)) {
                            node = container;
                            walker = new TreeWalker(container, body);
                            do {
                                if (3 === node.nodeType && node.nodeValue.length > 0) {
                                    offset = start ? 0 : node.nodeValue.length;
                                    container = node;
                                    normalized = true;
                                    break;
                                }
                                if (nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
                                    offset = dom.nodeIndex(node);
                                    container = node.parentNode;
                                    if ("IMG" == node.nodeName && !start) offset++;
                                    normalized = true;
                                    break;
                                }
                            } while (node = start ? walker.next() : walker.prev());
                        }
                    }
                }
                if (collapsed) {
                    if (3 === container.nodeType && 0 === offset) findTextNodeRelative(true);
                    if (1 === container.nodeType) {
                        node = container.childNodes[offset];
                        if (node && "BR" === node.nodeName && !hasBrBeforeAfter(node) && !hasBrBeforeAfter(node, true)) findTextNodeRelative(true, container.childNodes[offset]);
                    }
                }
                if (start && !collapsed && 3 === container.nodeType && offset === container.nodeValue.length) findTextNodeRelative(false);
                if (normalized) rng["set" + (start ? "Start" : "End")](container, offset);
            }
            if (tinymce.isIE) return;
            rng = self.getRng();
            collapsed = rng.collapsed;
            normalizeEndPoint(true);
            if (!collapsed) normalizeEndPoint();
            if (normalized) {
                if (collapsed) rng.collapse(true);
                self.setRng(rng, self.isForward());
            }
        },
        selectorChanged: function(selector, callback) {
            var self = this, currentSelectors;
            if (!self.selectorChangedData) {
                self.selectorChangedData = {};
                currentSelectors = {};
                self.editor.onNodeChange.addToTop(function(ed, cm, node) {
                    var dom = self.dom, parents = dom.getParents(node, null, dom.getRoot()), matchedSelectors = {};
                    each(self.selectorChangedData, function(callbacks, selector) {
                        each(parents, function(node) {
                            if (dom.is(node, selector)) {
                                if (!currentSelectors[selector]) {
                                    each(callbacks, function(callback) {
                                        callback(true, {
                                            node: node,
                                            selector: selector,
                                            parents: parents
                                        });
                                    });
                                    currentSelectors[selector] = callbacks;
                                }
                                matchedSelectors[selector] = callbacks;
                                return false;
                            }
                        });
                    });
                    each(currentSelectors, function(callbacks, selector) {
                        if (!matchedSelectors[selector]) {
                            delete currentSelectors[selector];
                            each(callbacks, function(callback) {
                                callback(false, {
                                    node: node,
                                    selector: selector,
                                    parents: parents
                                });
                            });
                        }
                    });
                });
            }
            if (!self.selectorChangedData[selector]) self.selectorChangedData[selector] = [];
            self.selectorChangedData[selector].push(callback);
            return self;
        },
        destroy: function(manual) {
            var self = this;
            self.win = null;
            if (!manual) tinymce.removeUnload(self.destroy);
        },
        _fixIESelection: function() {
            var dom = this.dom, doc = dom.doc, body = doc.body, started, startRng, htmlElm;
            function rngFromPoint(x, y) {
                var rng = body.createTextRange();
                try {
                    rng.moveToPoint(x, y);
                } catch (ex) {
                    rng = null;
                }
                return rng;
            }
            function selectionChange(e) {
                var pointRng;
                if (e.button) {
                    pointRng = rngFromPoint(e.x, e.y);
                    if (pointRng) {
                        if (pointRng.compareEndPoints("StartToStart", startRng) > 0) pointRng.setEndPoint("StartToStart", startRng); else pointRng.setEndPoint("EndToEnd", startRng);
                        pointRng.select();
                    }
                } else endSelection();
            }
            function endSelection() {
                var rng = doc.selection.createRange();
                if (startRng && !rng.item && 0 === rng.compareEndPoints("StartToEnd", rng)) startRng.select();
                dom.unbind(doc, "mouseup", endSelection);
                dom.unbind(doc, "mousemove", selectionChange);
                startRng = started = 0;
            }
            doc.documentElement.unselectable = true;
            dom.bind(doc, [ "mousedown", "contextmenu" ], function(e) {
                if ("HTML" === e.target.nodeName) {
                    if (started) endSelection();
                    htmlElm = doc.documentElement;
                    if (htmlElm.scrollHeight > htmlElm.clientHeight) return;
                    started = 1;
                    startRng = rngFromPoint(e.x, e.y);
                    if (startRng) {
                        dom.bind(doc, "mouseup", endSelection);
                        dom.bind(doc, "mousemove", selectionChange);
                        dom.win.focus();
                        startRng.select();
                    }
                }
            });
        }
    });
})(tinymce);

(function(tinymce) {
    tinymce.dom.Serializer = function(settings, dom, schema) {
        var onPreProcess, onPostProcess, isIE = tinymce.isIE, each = tinymce.each, htmlParser;
        if (!settings.apply_source_formatting) settings.indent = false;
        dom = dom || tinymce.DOM;
        schema = schema || new tinymce.html.Schema(settings);
        settings.entity_encoding = settings.entity_encoding || "named";
        settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
        onPreProcess = new tinymce.util.Dispatcher(self);
        onPostProcess = new tinymce.util.Dispatcher(self);
        htmlParser = new tinymce.html.DomParser(settings, schema);
        htmlParser.addAttributeFilter("src,href,style", function(nodes, name) {
            var i = nodes.length, node, value, internalName = "data-mce-" + name, urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;
            while (i--) {
                node = nodes[i];
                value = node.attributes.map[internalName];
                if (value !== undef) {
                    node.attr(name, value.length > 0 ? value : null);
                    node.attr(internalName, null);
                } else {
                    value = node.attributes.map[name];
                    if ("style" === name) value = dom.serializeStyle(dom.parseStyle(value), node.name); else if (urlConverter) value = urlConverter.call(urlConverterScope, value, name, node.name);
                    node.attr(name, value.length > 0 ? value : null);
                }
            }
        });
        htmlParser.addAttributeFilter("class", function(nodes, name) {
            var i = nodes.length, node, value;
            while (i--) {
                node = nodes[i];
                value = node.attr("class").replace(/(?:^|\s)mce(Item\w+|Selected)(?!\S)/g, "");
                node.attr("class", value.length > 0 ? value : null);
            }
        });
        htmlParser.addAttributeFilter("data-mce-type", function(nodes, name, args) {
            var i = nodes.length, node;
            while (i--) {
                node = nodes[i];
                if ("bookmark" === node.attributes.map["data-mce-type"] && !args.cleanup) node.remove();
            }
        });
        htmlParser.addAttributeFilter("data-mce-expando", function(nodes, name, args) {
            var i = nodes.length;
            while (i--) nodes[i].attr(name, null);
        });
        htmlParser.addNodeFilter("noscript", function(nodes) {
            var i = nodes.length, node;
            while (i--) {
                node = nodes[i].firstChild;
                if (node) node.value = tinymce.html.Entities.decode(node.value);
            }
        });
        htmlParser.addNodeFilter("script,style", function(nodes, name) {
            var i = nodes.length, node, value;
            function trim(value) {
                return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
            }
            while (i--) {
                node = nodes[i];
                value = node.firstChild ? node.firstChild.value : "";
                if ("script" === name) {
                    node.attr("type", (node.attr("type") || "text/javascript").replace(/^mce\-/, ""));
                    if (value.length > 0) node.firstChild.value = "// <![CDATA[\n" + trim(value) + "\n// ]]>";
                } else if (value.length > 0) node.firstChild.value = "<!--\n" + trim(value) + "\n-->";
            }
        });
        htmlParser.addNodeFilter("#comment", function(nodes, name) {
            var i = nodes.length, node;
            while (i--) {
                node = nodes[i];
                if (0 === node.value.indexOf("[CDATA[")) {
                    node.name = "#cdata";
                    node.type = 4;
                    node.value = node.value.replace(/^\[CDATA\[|\]\]$/g, "");
                } else if (0 === node.value.indexOf("mce:protected ")) {
                    node.name = "#text";
                    node.type = 3;
                    node.raw = true;
                    node.value = unescape(node.value).substr(14);
                }
            }
        });
        htmlParser.addNodeFilter("xml:namespace,input", function(nodes, name) {
            var i = nodes.length, node;
            while (i--) {
                node = nodes[i];
                if (7 === node.type) node.remove(); else if (1 === node.type) if ("input" === name && !("type" in node.attributes.map)) node.attr("type", "text");
            }
        });
        if (settings.fix_list_elements) htmlParser.addNodeFilter("ul,ol", function(nodes, name) {
            var i = nodes.length, node, parentNode;
            while (i--) {
                node = nodes[i];
                parentNode = node.parent;
                if ("ul" === parentNode.name || "ol" === parentNode.name) if (node.prev && "li" === node.prev.name) node.prev.append(node);
            }
        });
        htmlParser.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style", function(nodes, name) {
            var i = nodes.length;
            while (i--) nodes[i].attr(name, null);
        });
        return {
            schema: schema,
            addNodeFilter: htmlParser.addNodeFilter,
            addAttributeFilter: htmlParser.addAttributeFilter,
            onPreProcess: onPreProcess,
            onPostProcess: onPostProcess,
            serialize: function(node, args) {
                var impl, doc, oldDoc, htmlSerializer, content;
                if (isIE && dom.select("script,style,select,map").length > 0) {
                    content = node.innerHTML;
                    node = node.cloneNode(false);
                    dom.setHTML(node, content);
                } else node = node.cloneNode(true);
                impl = node.ownerDocument.implementation;
                if (impl.createHTMLDocument) {
                    doc = impl.createHTMLDocument("");
                    each("BODY" == node.nodeName ? node.childNodes : [ node ], function(node) {
                        doc.body.appendChild(doc.importNode(node, true));
                    });
                    if ("BODY" != node.nodeName) node = doc.body.firstChild; else node = doc.body;
                    oldDoc = dom.doc;
                    dom.doc = doc;
                }
                args = args || {};
                args.format = args.format || "html";
                if (!args.no_events) {
                    args.node = node;
                    onPreProcess.dispatch(self, args);
                }
                htmlSerializer = new tinymce.html.Serializer(settings, schema);
                args.content = htmlSerializer.serialize(htmlParser.parse(tinymce.trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node)), args));
                if (!args.cleanup) args.content = args.content.replace(/\uFEFF/g, "");
                if (!args.no_events) onPostProcess.dispatch(self, args);
                if (oldDoc) dom.doc = oldDoc;
                args.node = null;
                return args.content;
            },
            addRules: function(rules) {
                schema.addValidElements(rules);
            },
            setRules: function(rules) {
                schema.setValidElements(rules);
            }
        };
    };
})(tinymce);

(function(tinymce) {
    tinymce.dom.ScriptLoader = function(settings) {
        var QUEUED = 0, LOADING = 1, LOADED = 2, states = {}, queue = [], scriptLoadedCallbacks = {}, queueLoadedCallbacks = [], loading = 0, undef;
        function loadScript(url, callback) {
            var t = this, dom = tinymce.DOM, elm, uri, loc, id;
            function done() {
                dom.remove(id);
                if (elm) elm.onreadystatechange = elm.onload = elm = null;
                callback();
            }
            function error() {
                if ("undefined" !== typeof console && console.log) console.log("Failed to load: " + url);
            }
            id = dom.uniqueId();
            if (tinymce.isIE6) {
                uri = new tinymce.util.URI(url);
                loc = location;
                if (uri.host == loc.hostname && uri.port == loc.port && uri.protocol + ":" == loc.protocol && "file" != uri.protocol.toLowerCase()) {
                    tinymce.util.XHR.send({
                        url: tinymce._addVer(uri.getURI()),
                        success: function(content) {
                            var script = dom.create("script", {
                                type: "text/javascript"
                            });
                            script.text = content;
                            document.getElementsByTagName("head")[0].appendChild(script);
                            dom.remove(script);
                            done();
                        },
                        error: error
                    });
                    return;
                }
            }
            elm = document.createElement("script");
            elm.id = id;
            elm.type = "text/javascript";
            elm.src = tinymce._addVer(url);
            if (!tinymce.isIE) elm.onload = done;
            elm.onerror = error;
            if (!tinymce.isOpera) elm.onreadystatechange = function() {
                var state = elm.readyState;
                if ("complete" == state || "loaded" == state) done();
            };
            (document.getElementsByTagName("head")[0] || document.body).appendChild(elm);
        }
        this.isDone = function(url) {
            return states[url] == LOADED;
        };
        this.markDone = function(url) {
            states[url] = LOADED;
        };
        this.add = this.load = function(url, callback, scope) {
            var item, state = states[url];
            if (state == undef) {
                queue.push(url);
                states[url] = QUEUED;
            }
            if (callback) {
                if (!scriptLoadedCallbacks[url]) scriptLoadedCallbacks[url] = [];
                scriptLoadedCallbacks[url].push({
                    func: callback,
                    scope: scope || this
                });
            }
        };
        this.loadQueue = function(callback, scope) {
            this.loadScripts(queue, callback, scope);
        };
        this.loadScripts = function(scripts, callback, scope) {
            var loadScripts;
            function execScriptLoadedCallbacks(url) {
                tinymce.each(scriptLoadedCallbacks[url], function(callback) {
                    callback.func.call(callback.scope);
                });
                scriptLoadedCallbacks[url] = undef;
            }
            queueLoadedCallbacks.push({
                func: callback,
                scope: scope || this,
                executing: false
            });
            loadScripts = function() {
                var loadingScripts = tinymce.grep(scripts);
                scripts.length = 0;
                tinymce.each(loadingScripts, function(url) {
                    if (states[url] == LOADED) {
                        execScriptLoadedCallbacks(url);
                        return;
                    }
                    if (states[url] != LOADING) {
                        states[url] = LOADING;
                        loading++;
                        loadScript(url, function() {
                            states[url] = LOADED;
                            loading--;
                            execScriptLoadedCallbacks(url);
                            loadScripts();
                        });
                    }
                });
                if (!loading) {
                    tinymce.each(queueLoadedCallbacks, function(callback) {
                        if (!callback.executing) {
                            callback.executing = true;
                            callback.func.call(callback.scope);
                        }
                    });
                    queueLoadedCallbacks.length = 0;
                }
            };
            loadScripts();
        };
    };
    tinymce.ScriptLoader = new tinymce.dom.ScriptLoader();
})(tinymce);

(function(tinymce) {
    tinymce.dom.RangeUtils = function(dom) {
        var INVISIBLE_CHAR = "﻿";
        this.walk = function(rng, callback) {
            var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset, ancestor, startPoint, endPoint, node, parent, siblings, nodes;
            nodes = dom.select("td.mceSelected,th.mceSelected");
            if (nodes.length > 0) {
                tinymce.each(nodes, function(node) {
                    callback([ node ]);
                });
                return;
            }
            function exclude(nodes) {
                var node;
                node = nodes[0];
                if (3 === node.nodeType && node === startContainer && startOffset >= node.nodeValue.length) nodes.splice(0, 1);
                node = nodes[nodes.length - 1];
                if (0 === endOffset && nodes.length > 0 && node === endContainer && 3 === node.nodeType) nodes.splice(nodes.length - 1, 1);
                return nodes;
            }
            function collectSiblings(node, name, end_node) {
                var siblings = [];
                for (;node && node != end_node; node = node[name]) siblings.push(node);
                return siblings;
            }
            function findEndPoint(node, root) {
                do {
                    if (node.parentNode == root) return node;
                    node = node.parentNode;
                } while (node);
            }
            function walkBoundary(start_node, end_node, next) {
                var siblingName = next ? "nextSibling" : "previousSibling";
                for (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {
                    parent = node.parentNode;
                    siblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);
                    if (siblings.length) {
                        if (!next) siblings.reverse();
                        callback(exclude(siblings));
                    }
                }
            }
            if (1 == startContainer.nodeType && startContainer.hasChildNodes()) startContainer = startContainer.childNodes[startOffset];
            if (1 == endContainer.nodeType && endContainer.hasChildNodes()) endContainer = endContainer.childNodes[Math.min(endOffset - 1, endContainer.childNodes.length - 1)];
            if (startContainer == endContainer) return callback(exclude([ startContainer ]));
            ancestor = dom.findCommonAncestor(startContainer, endContainer);
            for (node = startContainer; node; node = node.parentNode) {
                if (node === endContainer) return walkBoundary(startContainer, ancestor, true);
                if (node === ancestor) break;
            }
            for (node = endContainer; node; node = node.parentNode) {
                if (node === startContainer) return walkBoundary(endContainer, ancestor);
                if (node === ancestor) break;
            }
            startPoint = findEndPoint(startContainer, ancestor) || startContainer;
            endPoint = findEndPoint(endContainer, ancestor) || endContainer;
            walkBoundary(startContainer, startPoint, true);
            siblings = collectSiblings(startPoint == startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint == endContainer ? endPoint.nextSibling : endPoint);
            if (siblings.length) callback(exclude(siblings));
            walkBoundary(endContainer, endPoint);
        };
        this.split = function(rng) {
            var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
            function splitText(node, offset) {
                return node.splitText(offset);
            }
            if (startContainer == endContainer && 3 == startContainer.nodeType) {
                if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
                    endContainer = splitText(startContainer, startOffset);
                    startContainer = endContainer.previousSibling;
                    if (endOffset > startOffset) {
                        endOffset -= startOffset;
                        startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
                        endOffset = endContainer.nodeValue.length;
                        startOffset = 0;
                    } else endOffset = 0;
                }
            } else {
                if (3 == startContainer.nodeType && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
                    startContainer = splitText(startContainer, startOffset);
                    startOffset = 0;
                }
                if (3 == endContainer.nodeType && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
                    endContainer = splitText(endContainer, endOffset).previousSibling;
                    endOffset = endContainer.nodeValue.length;
                }
            }
            return {
                startContainer: startContainer,
                startOffset: startOffset,
                endContainer: endContainer,
                endOffset: endOffset
            };
        };
    };
    tinymce.dom.RangeUtils.compareRanges = function(rng1, rng2) {
        if (rng1 && rng2) if (rng1.item || rng1.duplicate) {
            if (rng1.item && rng2.item && rng1.item(0) === rng2.item(0)) return true;
            if (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1)) return true;
        } else return rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;
        return false;
    };
})(tinymce);

(function(tinymce) {
    var Event = tinymce.dom.Event, each = tinymce.each;
    tinymce.create("tinymce.ui.KeyboardNavigation", {
        KeyboardNavigation: function(settings, dom) {
            var t = this, root = settings.root, items = settings.items, enableUpDown = settings.enableUpDown, enableLeftRight = settings.enableLeftRight || !settings.enableUpDown, excludeFromTabOrder = settings.excludeFromTabOrder, itemFocussed, itemBlurred, rootKeydown, rootFocussed, focussedId;
            dom = dom || tinymce.DOM;
            itemFocussed = function(evt) {
                focussedId = evt.target.id;
            };
            itemBlurred = function(evt) {
                dom.setAttrib(evt.target.id, "tabindex", "-1");
            };
            rootFocussed = function(evt) {
                var item = dom.get(focussedId);
                dom.setAttrib(item, "tabindex", "0");
                item.focus();
            };
            t.focus = function() {
                dom.get(focussedId).focus();
            };
            t.destroy = function() {
                each(items, function(item) {
                    var elm = dom.get(item.id);
                    dom.unbind(elm, "focus", itemFocussed);
                    dom.unbind(elm, "blur", itemBlurred);
                });
                var rootElm = dom.get(root);
                dom.unbind(rootElm, "focus", rootFocussed);
                dom.unbind(rootElm, "keydown", rootKeydown);
                items = dom = root = t.focus = itemFocussed = itemBlurred = rootKeydown = rootFocussed = null;
                t.destroy = function() {};
            };
            t.moveFocus = function(dir, evt) {
                var idx = -1, controls = t.controls, newFocus;
                if (!focussedId) return;
                each(items, function(item, index) {
                    if (item.id === focussedId) {
                        idx = index;
                        return false;
                    }
                });
                idx += dir;
                if (idx < 0) idx = items.length - 1; else if (idx >= items.length) idx = 0;
                newFocus = items[idx];
                dom.setAttrib(focussedId, "tabindex", "-1");
                dom.setAttrib(newFocus.id, "tabindex", "0");
                dom.get(newFocus.id).focus();
                if (settings.actOnFocus) settings.onAction(newFocus.id);
                if (evt) Event.cancel(evt);
            };
            rootKeydown = function(evt) {
                var DOM_VK_LEFT = 37, DOM_VK_RIGHT = 39, DOM_VK_UP = 38, DOM_VK_DOWN = 40, DOM_VK_ESCAPE = 27, DOM_VK_ENTER = 14, DOM_VK_RETURN = 13, DOM_VK_SPACE = 32;
                switch (evt.keyCode) {
                  case DOM_VK_LEFT:
                    if (enableLeftRight) t.moveFocus(-1);
                    break;

                  case DOM_VK_RIGHT:
                    if (enableLeftRight) t.moveFocus(1);
                    break;

                  case DOM_VK_UP:
                    if (enableUpDown) t.moveFocus(-1);
                    break;

                  case DOM_VK_DOWN:
                    if (enableUpDown) t.moveFocus(1);
                    break;

                  case DOM_VK_ESCAPE:
                    if (settings.onCancel) {
                        settings.onCancel();
                        Event.cancel(evt);
                    }
                    break;

                  case DOM_VK_ENTER:
                  case DOM_VK_RETURN:
                  case DOM_VK_SPACE:
                    if (settings.onAction) {
                        settings.onAction(focussedId);
                        Event.cancel(evt);
                    }
                }
            };
            each(items, function(item, idx) {
                var tabindex, elm;
                if (!item.id) item.id = dom.uniqueId("_mce_item_");
                elm = dom.get(item.id);
                if (excludeFromTabOrder) {
                    dom.bind(elm, "blur", itemBlurred);
                    tabindex = "-1";
                } else tabindex = 0 === idx ? "0" : "-1";
                elm.setAttribute("tabindex", tabindex);
                dom.bind(elm, "focus", itemFocussed);
            });
            if (items[0]) focussedId = items[0].id;
            dom.setAttrib(root, "tabindex", "-1");
            var rootElm = dom.get(root);
            dom.bind(rootElm, "focus", rootFocussed);
            dom.bind(rootElm, "keydown", rootKeydown);
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM, is = tinymce.is;
    tinymce.create("tinymce.ui.Control", {
        Control: function(id, s, editor) {
            this.id = id;
            this.settings = s = s || {};
            this.rendered = false;
            this.onRender = new tinymce.util.Dispatcher(this);
            this.classPrefix = "";
            this.scope = s.scope || this;
            this.disabled = 0;
            this.active = 0;
            this.editor = editor;
        },
        setAriaProperty: function(property, value) {
            var element = DOM.get(this.id + "_aria") || DOM.get(this.id);
            if (element) DOM.setAttrib(element, "aria-" + property, !!value);
        },
        focus: function() {
            DOM.get(this.id).focus();
        },
        setDisabled: function(s) {
            if (s != this.disabled) {
                this.setAriaProperty("disabled", s);
                this.setState("Disabled", s);
                this.setState("Enabled", !s);
                this.disabled = s;
            }
        },
        isDisabled: function() {
            return this.disabled;
        },
        setActive: function(s) {
            if (s != this.active) {
                this.setState("Active", s);
                this.active = s;
                this.setAriaProperty("pressed", s);
            }
        },
        isActive: function() {
            return this.active;
        },
        setState: function(c, s) {
            var n = DOM.get(this.id);
            c = this.classPrefix + c;
            if (s) DOM.addClass(n, c); else DOM.removeClass(n, c);
        },
        isRendered: function() {
            return this.rendered;
        },
        renderHTML: function() {},
        renderTo: function(n) {
            DOM.setHTML(n, this.renderHTML());
        },
        postRender: function() {
            var t = this, b;
            if (is(t.disabled)) {
                b = t.disabled;
                t.disabled = -1;
                t.setDisabled(b);
            }
            if (is(t.active)) {
                b = t.active;
                t.active = -1;
                t.setActive(b);
            }
        },
        remove: function() {
            DOM.remove(this.id);
            this.destroy();
        },
        destroy: function() {
            tinymce.dom.Event.clear(this.id);
        }
    });
})(tinymce);

tinymce.create("tinymce.ui.Container:tinymce.ui.Control", {
    Container: function(id, s, editor) {
        this.parent(id, s, editor);
        this.controls = [];
        this.lookup = {};
    },
    add: function(c) {
        this.lookup[c.id] = c;
        this.controls.push(c);
        return c;
    },
    get: function(n) {
        return this.lookup[n];
    }
});

tinymce.create("tinymce.ui.Separator:tinymce.ui.Control", {
    Separator: function(id, s) {
        this.parent(id, s);
        this.classPrefix = "mceSeparator";
        this.setDisabled(true);
    },
    renderHTML: function() {
        return tinymce.DOM.createHTML("span", {
            "class": this.classPrefix,
            role: "separator",
            "aria-orientation": "vertical",
            tabindex: "-1"
        });
    }
});

(function(tinymce) {
    var is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, walk = tinymce.walk;
    tinymce.create("tinymce.ui.MenuItem:tinymce.ui.Control", {
        MenuItem: function(id, s) {
            this.parent(id, s);
            this.classPrefix = "mceMenuItem";
        },
        setSelected: function(s) {
            this.setState("Selected", s);
            this.setAriaProperty("checked", !!s);
            this.selected = s;
        },
        isSelected: function() {
            return this.selected;
        },
        postRender: function() {
            var t = this;
            t.parent();
            if (is(t.selected)) t.setSelected(t.selected);
        }
    });
})(tinymce);

(function(tinymce) {
    var is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, walk = tinymce.walk;
    tinymce.create("tinymce.ui.Menu:tinymce.ui.MenuItem", {
        Menu: function(id, s) {
            var t = this;
            t.parent(id, s);
            t.items = {};
            t.collapsed = false;
            t.menuCount = 0;
            t.onAddItem = new tinymce.util.Dispatcher(this);
        },
        expand: function(d) {
            var t = this;
            if (d) walk(t, function(o) {
                if (o.expand) o.expand();
            }, "items", t);
            t.collapsed = false;
        },
        collapse: function(d) {
            var t = this;
            if (d) walk(t, function(o) {
                if (o.collapse) o.collapse();
            }, "items", t);
            t.collapsed = true;
        },
        isCollapsed: function() {
            return this.collapsed;
        },
        add: function(o) {
            if (!o.settings) o = new tinymce.ui.MenuItem(o.id || DOM.uniqueId(), o);
            this.onAddItem.dispatch(this, o);
            return this.items[o.id] = o;
        },
        addSeparator: function() {
            return this.add({
                separator: true
            });
        },
        addMenu: function(o) {
            if (!o.collapse) o = this.createMenu(o);
            this.menuCount++;
            return this.add(o);
        },
        hasMenus: function() {
            return 0 !== this.menuCount;
        },
        remove: function(o) {
            delete this.items[o.id];
        },
        removeAll: function() {
            var t = this;
            walk(t, function(o) {
                if (o.removeAll) o.removeAll(); else o.remove();
                o.destroy();
            }, "items", t);
            t.items = {};
        },
        createMenu: function(o) {
            var m = new tinymce.ui.Menu(o.id || DOM.uniqueId(), o);
            m.onAddItem.add(this.onAddItem.dispatch, this.onAddItem);
            return m;
        }
    });
})(tinymce);

(function(tinymce) {
    var is = tinymce.is, DOM = tinymce.DOM, each = tinymce.each, Event = tinymce.dom.Event, Element = tinymce.dom.Element;
    tinymce.create("tinymce.ui.DropMenu:tinymce.ui.Menu", {
        DropMenu: function(id, s) {
            s = s || {};
            s.container = s.container || DOM.doc.body;
            s.offset_x = s.offset_x || 0;
            s.offset_y = s.offset_y || 0;
            s.vp_offset_x = s.vp_offset_x || 0;
            s.vp_offset_y = s.vp_offset_y || 0;
            if (is(s.icons) && !s.icons) s["class"] += " mceNoIcons";
            this.parent(id, s);
            this.onShowMenu = new tinymce.util.Dispatcher(this);
            this.onHideMenu = new tinymce.util.Dispatcher(this);
            this.classPrefix = "mceMenu";
        },
        createMenu: function(s) {
            var t = this, cs = t.settings, m;
            s.container = s.container || cs.container;
            s.parent = t;
            s.constrain = s.constrain || cs.constrain;
            s["class"] = s["class"] || cs["class"];
            s.vp_offset_x = s.vp_offset_x || cs.vp_offset_x;
            s.vp_offset_y = s.vp_offset_y || cs.vp_offset_y;
            s.keyboard_focus = cs.keyboard_focus;
            m = new tinymce.ui.DropMenu(s.id || DOM.uniqueId(), s);
            m.onAddItem.add(t.onAddItem.dispatch, t.onAddItem);
            return m;
        },
        focus: function() {
            var t = this;
            if (t.keyboardNav) t.keyboardNav.focus();
        },
        update: function() {
            var t = this, s = t.settings, tb = DOM.get("menu_" + t.id + "_tbl"), co = DOM.get("menu_" + t.id + "_co"), tw, th;
            tw = s.max_width ? Math.min(tb.offsetWidth, s.max_width) : tb.offsetWidth;
            th = s.max_height ? Math.min(tb.offsetHeight, s.max_height) : tb.offsetHeight;
            if (!DOM.boxModel) t.element.setStyles({
                width: tw + 2,
                height: th + 2
            }); else t.element.setStyles({
                width: tw,
                height: th
            });
            if (s.max_width) DOM.setStyle(co, "width", tw);
            if (s.max_height) {
                DOM.setStyle(co, "height", th);
                if (tb.clientHeight < s.max_height) DOM.setStyle(co, "overflow", "hidden");
            }
        },
        showMenu: function(x, y, px) {
            var t = this, s = t.settings, co, vp = DOM.getViewPort(), w, h, mx, my, ot = 2, dm, tb, cp = t.classPrefix;
            t.collapse(1);
            if (t.isMenuVisible) return;
            if (!t.rendered) {
                co = DOM.add(t.settings.container, t.renderNode());
                each(t.items, function(o) {
                    o.postRender();
                });
                t.element = new Element("menu_" + t.id, {
                    blocker: 1,
                    container: s.container
                });
            } else co = DOM.get("menu_" + t.id);
            if (!tinymce.isOpera) DOM.setStyles(co, {
                left: -65535,
                top: -65535
            });
            DOM.show(co);
            t.update();
            x += s.offset_x || 0;
            y += s.offset_y || 0;
            vp.w -= 4;
            vp.h -= 4;
            if (s.constrain) {
                w = co.clientWidth - ot;
                h = co.clientHeight - ot;
                mx = vp.x + vp.w;
                my = vp.y + vp.h;
                if (x + s.vp_offset_x + w > mx) x = px ? px - w : Math.max(0, mx - s.vp_offset_x - w);
                if (y + s.vp_offset_y + h > my) y = Math.max(0, my - s.vp_offset_y - h);
            }
            DOM.setStyles(co, {
                left: x,
                top: y
            });
            t.element.update();
            t.isMenuVisible = 1;
            t.mouseClickFunc = Event.add(co, "click", function(e) {
                var m;
                e = e.target;
                if (e && (e = DOM.getParent(e, "tr")) && !DOM.hasClass(e, cp + "ItemSub")) {
                    m = t.items[e.id];
                    if (m.isDisabled()) return;
                    dm = t;
                    while (dm) {
                        if (dm.hideMenu) dm.hideMenu();
                        dm = dm.settings.parent;
                    }
                    if (m.settings.onclick) m.settings.onclick(e);
                    return false;
                }
            });
            if (t.hasMenus()) t.mouseOverFunc = Event.add(co, "mouseover", function(e) {
                var m, r, mi;
                e = e.target;
                if (e && (e = DOM.getParent(e, "tr"))) {
                    m = t.items[e.id];
                    if (t.lastMenu) t.lastMenu.collapse(1);
                    if (m.isDisabled()) return;
                    if (e && DOM.hasClass(e, cp + "ItemSub")) {
                        r = DOM.getRect(e);
                        m.showMenu(r.x + r.w - ot, r.y - ot, r.x);
                        t.lastMenu = m;
                        DOM.addClass(DOM.get(m.id).firstChild, cp + "ItemActive");
                    }
                }
            });
            Event.add(co, "keydown", t._keyHandler, t);
            t.onShowMenu.dispatch(t);
            if (s.keyboard_focus) t._setupKeyboardNav();
        },
        hideMenu: function(c) {
            var t = this, co = DOM.get("menu_" + t.id), e;
            if (!t.isMenuVisible) return;
            if (t.keyboardNav) t.keyboardNav.destroy();
            Event.remove(co, "mouseover", t.mouseOverFunc);
            Event.remove(co, "click", t.mouseClickFunc);
            Event.remove(co, "keydown", t._keyHandler);
            DOM.hide(co);
            t.isMenuVisible = 0;
            if (!c) t.collapse(1);
            if (t.element) t.element.hide();
            if (e = DOM.get(t.id)) DOM.removeClass(e.firstChild, t.classPrefix + "ItemActive");
            t.onHideMenu.dispatch(t);
        },
        add: function(o) {
            var t = this, co;
            o = t.parent(o);
            if (t.isRendered && (co = DOM.get("menu_" + t.id))) t._add(DOM.select("tbody", co)[0], o);
            return o;
        },
        collapse: function(d) {
            this.parent(d);
            this.hideMenu(1);
        },
        remove: function(o) {
            DOM.remove(o.id);
            this.destroy();
            return this.parent(o);
        },
        destroy: function() {
            var t = this, co = DOM.get("menu_" + t.id);
            if (t.keyboardNav) t.keyboardNav.destroy();
            Event.remove(co, "mouseover", t.mouseOverFunc);
            Event.remove(DOM.select("a", co), "focus", t.mouseOverFunc);
            Event.remove(co, "click", t.mouseClickFunc);
            Event.remove(co, "keydown", t._keyHandler);
            if (t.element) t.element.remove();
            DOM.remove(co);
        },
        renderNode: function() {
            var t = this, s = t.settings, n, tb, co, w;
            w = DOM.create("div", {
                role: "listbox",
                id: "menu_" + t.id,
                "class": s["class"],
                style: "position:absolute;left:0;top:0;z-index:200000;outline:0"
            });
            if (t.settings.parent) DOM.setAttrib(w, "aria-parent", "menu_" + t.settings.parent.id);
            co = DOM.add(w, "div", {
                role: "presentation",
                id: "menu_" + t.id + "_co",
                "class": t.classPrefix + (s["class"] ? " " + s["class"] : "")
            });
            t.element = new Element("menu_" + t.id, {
                blocker: 1,
                container: s.container
            });
            if (s.menu_line) DOM.add(co, "span", {
                "class": t.classPrefix + "Line"
            });
            n = DOM.add(co, "table", {
                role: "presentation",
                id: "menu_" + t.id + "_tbl",
                border: 0,
                cellPadding: 0,
                cellSpacing: 0
            });
            tb = DOM.add(n, "tbody");
            each(t.items, function(o) {
                t._add(tb, o);
            });
            t.rendered = true;
            return w;
        },
        _setupKeyboardNav: function() {
            var contextMenu, menuItems, t = this;
            contextMenu = DOM.get("menu_" + t.id);
            menuItems = DOM.select("a[role=option]", "menu_" + t.id);
            menuItems.splice(0, 0, contextMenu);
            t.keyboardNav = new tinymce.ui.KeyboardNavigation({
                root: "menu_" + t.id,
                items: menuItems,
                onCancel: function() {
                    t.hideMenu();
                },
                enableUpDown: true
            });
            contextMenu.focus();
        },
        _keyHandler: function(evt) {
            var t = this, e;
            switch (evt.keyCode) {
              case 37:
                if (t.settings.parent) {
                    t.hideMenu();
                    t.settings.parent.focus();
                    Event.cancel(evt);
                }
                break;

              case 39:
                if (t.mouseOverFunc) t.mouseOverFunc(evt);
                break;

              case 38:
              case 40:
                tinymce.dom.Event.cancel(evt);
                return;
            }
        },
        _add: function(tb, o) {
            var n, s = o.settings, a, ro, it, cp = this.classPrefix, ic;
            if (s.separator) {
                ro = DOM.add(tb, "tr", {
                    id: o.id,
                    "class": cp + "ItemSeparator"
                });
                DOM.add(ro, "td", {
                    "class": cp + "ItemSeparator"
                });
                if (n = ro.previousSibling) DOM.addClass(n, "mceLast");
                return;
            }
            n = ro = DOM.add(tb, "tr", {
                id: o.id,
                "class": cp + "Item " + cp + "ItemEnabled"
            });
            n = it = DOM.add(n, s.titleItem ? "th" : "td");
            n = a = DOM.add(n, "a", {
                id: o.id + "_aria",
                role: s.titleItem ? "presentation" : "option",
                href: "javascript:;",
                onclick: "return false;",
                onmousedown: "return false;"
            });
            if (s.parent) {
                DOM.setAttrib(a, "aria-haspopup", "true");
                DOM.setAttrib(a, "aria-owns", "menu_" + o.id);
            }
            DOM.addClass(it, s["class"]);
            ic = DOM.add(n, "span", {
                "class": "mceIcon" + (s.icon ? " mce_" + s.icon : "")
            });
            if (s.icon_src) DOM.add(ic, "img", {
                src: s.icon_src
            });
            n = DOM.add(n, s.element || "span", {
                "class": "mceText",
                title: o.settings.title
            }, o.settings.title);
            if (o.settings.style) {
                if ("function" == typeof o.settings.style) o.settings.style = o.settings.style();
                DOM.setAttrib(n, "style", o.settings.style);
            }
            if (1 == tb.childNodes.length) DOM.addClass(ro, "mceFirst");
            if ((n = ro.previousSibling) && DOM.hasClass(n, cp + "ItemSeparator")) DOM.addClass(ro, "mceFirst");
            if (o.collapse) DOM.addClass(ro, cp + "ItemSub");
            if (n = ro.previousSibling) DOM.removeClass(n, "mceLast");
            DOM.addClass(ro, "mceLast");
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM;
    tinymce.create("tinymce.ui.Button:tinymce.ui.Control", {
        Button: function(id, s, ed) {
            this.parent(id, s, ed);
            this.classPrefix = "mceButton";
        },
        renderHTML: function() {
            var cp = this.classPrefix, s = this.settings, h, l;
            l = DOM.encode(s.label || "");
            h = '<a role="button" id="' + this.id + '" href="javascript:;" class="' + cp + " " + cp + "Enabled " + s["class"] + (l ? " " + cp + "Labeled" : "") + '" onmousedown="return false;" onclick="return false;" aria-labelledby="' + this.id + '_voice" title="' + DOM.encode(s.title) + '">';
            if (s.image && !(this.editor && this.editor.forcedHighContrastMode)) h += '<span class="mceIcon ' + s["class"] + '"><img class="mceIcon" src="' + s.image + '" alt="' + DOM.encode(s.title) + '" /></span>' + (l ? '<span class="' + cp + 'Label">' + l + "</span>" : ""); else h += '<span class="mceIcon ' + s["class"] + '"></span>' + (l ? '<span class="' + cp + 'Label">' + l + "</span>" : "");
            h += '<span class="mceVoiceLabel mceIconOnly" style="display: none;" id="' + this.id + '_voice">' + s.title + "</span>";
            h += "</a>";
            return h;
        },
        postRender: function() {
            var t = this, s = t.settings, imgBookmark;
            if (tinymce.isIE && t.editor) tinymce.dom.Event.add(t.id, "mousedown", function(e) {
                var nodeName = t.editor.selection.getNode().nodeName;
                imgBookmark = "IMG" === nodeName ? t.editor.selection.getBookmark() : null;
            });
            tinymce.dom.Event.add(t.id, "click", function(e) {
                if (!t.isDisabled()) {
                    if (tinymce.isIE && t.editor && null !== imgBookmark) t.editor.selection.moveToBookmark(imgBookmark);
                    return s.onclick.call(s.scope, e);
                }
            });
            tinymce.dom.Event.add(t.id, "keyup", function(e) {
                if (!t.isDisabled() && e.keyCode == tinymce.VK.SPACEBAR) return s.onclick.call(s.scope, e);
            });
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, Dispatcher = tinymce.util.Dispatcher, undef;
    tinymce.create("tinymce.ui.ListBox:tinymce.ui.Control", {
        ListBox: function(id, s, ed) {
            var t = this;
            t.parent(id, s, ed);
            t.items = [];
            t.onChange = new Dispatcher(t);
            t.onPostRender = new Dispatcher(t);
            t.onAdd = new Dispatcher(t);
            t.onRenderMenu = new tinymce.util.Dispatcher(this);
            t.classPrefix = "mceListBox";
            t.marked = {};
        },
        select: function(va) {
            var t = this, fv, f;
            t.marked = {};
            if (va == undef) return t.selectByIndex(-1);
            if (va && "function" == typeof va) f = va; else f = function(v) {
                return v == va;
            };
            if (va != t.selectedValue) {
                each(t.items, function(o, i) {
                    if (f(o.value)) {
                        fv = 1;
                        t.selectByIndex(i);
                        return false;
                    }
                });
                if (!fv) t.selectByIndex(-1);
            }
        },
        selectByIndex: function(idx) {
            var t = this, e, o, label;
            t.marked = {};
            if (idx != t.selectedIndex) {
                e = DOM.get(t.id + "_text");
                label = DOM.get(t.id + "_voiceDesc");
                o = t.items[idx];
                if (o) {
                    t.selectedValue = o.value;
                    t.selectedIndex = idx;
                    DOM.setHTML(e, DOM.encode(o.title));
                    DOM.setHTML(label, t.settings.title + " - " + o.title);
                    DOM.removeClass(e, "mceTitle");
                    DOM.setAttrib(t.id, "aria-valuenow", o.title);
                } else {
                    DOM.setHTML(e, DOM.encode(t.settings.title));
                    DOM.setHTML(label, DOM.encode(t.settings.title));
                    DOM.addClass(e, "mceTitle");
                    t.selectedValue = t.selectedIndex = null;
                    DOM.setAttrib(t.id, "aria-valuenow", t.settings.title);
                }
                e = 0;
            }
        },
        mark: function(value) {
            this.marked[value] = true;
        },
        add: function(n, v, o) {
            var t = this;
            o = o || {};
            o = tinymce.extend(o, {
                title: n,
                value: v
            });
            t.items.push(o);
            t.onAdd.dispatch(t, o);
        },
        getLength: function() {
            return this.items.length;
        },
        renderHTML: function() {
            var h = "", t = this, s = t.settings, cp = t.classPrefix;
            h = '<span role="listbox" aria-haspopup="true" aria-labelledby="' + t.id + '_voiceDesc" aria-describedby="' + t.id + '_voiceDesc"><table role="presentation" tabindex="0" id="' + t.id + '" cellpadding="0" cellspacing="0" class="' + cp + " " + cp + "Enabled" + (s["class"] ? " " + s["class"] : "") + '"><tbody><tr>';
            h += "<td>" + DOM.createHTML("span", {
                id: t.id + "_voiceDesc",
                "class": "voiceLabel",
                style: "display:none;"
            }, t.settings.title);
            h += DOM.createHTML("a", {
                id: t.id + "_text",
                tabindex: -1,
                href: "javascript:;",
                "class": "mceText",
                onclick: "return false;",
                onmousedown: "return false;"
            }, DOM.encode(t.settings.title)) + "</td>";
            h += "<td>" + DOM.createHTML("a", {
                id: t.id + "_open",
                tabindex: -1,
                href: "javascript:;",
                "class": "mceOpen",
                onclick: "return false;",
                onmousedown: "return false;"
            }, '<span><span style="display:none;" class="mceIconOnly" aria-hidden="true">▼</span></span>') + "</td>";
            h += "</tr></tbody></table></span>";
            return h;
        },
        showMenu: function() {
            var t = this, p2, e = DOM.get(this.id), m;
            if (t.isDisabled() || 0 === t.items.length) return;
            if (t.menu && t.menu.isMenuVisible) return t.hideMenu();
            if (!t.isMenuRendered) {
                t.renderMenu();
                t.isMenuRendered = true;
            }
            p2 = DOM.getPos(e);
            m = t.menu;
            m.settings.offset_x = p2.x;
            m.settings.offset_y = p2.y;
            m.settings.keyboard_focus = !tinymce.isOpera;
            each(t.items, function(o) {
                if (m.items[o.id]) m.items[o.id].setSelected(0);
            });
            each(t.items, function(o) {
                if (m.items[o.id] && t.marked[o.value]) m.items[o.id].setSelected(1);
                if (o.value === t.selectedValue) m.items[o.id].setSelected(1);
            });
            m.showMenu(0, e.clientHeight);
            Event.add(DOM.doc, "mousedown", t.hideMenu, t);
            DOM.addClass(t.id, t.classPrefix + "Selected");
        },
        hideMenu: function(e) {
            var t = this;
            if (t.menu && t.menu.isMenuVisible) {
                DOM.removeClass(t.id, t.classPrefix + "Selected");
                if (e && "mousedown" == e.type && (e.target.id == t.id + "_text" || e.target.id == t.id + "_open")) return;
                if (!e || !DOM.getParent(e.target, ".mceMenu")) {
                    DOM.removeClass(t.id, t.classPrefix + "Selected");
                    Event.remove(DOM.doc, "mousedown", t.hideMenu, t);
                    t.menu.hideMenu();
                }
            }
        },
        renderMenu: function() {
            var t = this, m;
            m = t.settings.control_manager.createDropMenu(t.id + "_menu", {
                menu_line: 1,
                "class": t.classPrefix + "Menu mceNoIcons",
                max_width: 250,
                max_height: 150
            });
            m.onHideMenu.add(function() {
                t.hideMenu();
                t.focus();
            });
            m.add({
                title: t.settings.title,
                "class": "mceMenuItemTitle",
                onclick: function() {
                    if (false !== t.settings.onselect("")) t.select("");
                }
            });
            each(t.items, function(o) {
                if (o.value === undef) m.add({
                    title: o.title,
                    role: "option",
                    "class": "mceMenuItemTitle",
                    onclick: function() {
                        if (false !== t.settings.onselect("")) t.select("");
                    }
                }); else {
                    o.id = DOM.uniqueId();
                    o.role = "option";
                    o.onclick = function() {
                        if (false !== t.settings.onselect(o.value)) t.select(o.value);
                    };
                    m.add(o);
                }
            });
            t.onRenderMenu.dispatch(t, m);
            t.menu = m;
        },
        postRender: function() {
            var t = this, cp = t.classPrefix;
            Event.add(t.id, "click", t.showMenu, t);
            Event.add(t.id, "keydown", function(evt) {
                if (32 == evt.keyCode) {
                    t.showMenu(evt);
                    Event.cancel(evt);
                }
            });
            Event.add(t.id, "focus", function() {
                if (!t._focused) {
                    t.keyDownHandler = Event.add(t.id, "keydown", function(e) {
                        if (40 == e.keyCode) {
                            t.showMenu();
                            Event.cancel(e);
                        }
                    });
                    t.keyPressHandler = Event.add(t.id, "keypress", function(e) {
                        var v;
                        if (13 == e.keyCode) {
                            v = t.selectedValue;
                            t.selectedValue = null;
                            Event.cancel(e);
                            t.settings.onselect(v);
                        }
                    });
                }
                t._focused = 1;
            });
            Event.add(t.id, "blur", function() {
                Event.remove(t.id, "keydown", t.keyDownHandler);
                Event.remove(t.id, "keypress", t.keyPressHandler);
                t._focused = 0;
            });
            if (tinymce.isIE6 || !DOM.boxModel) {
                Event.add(t.id, "mouseover", function() {
                    if (!DOM.hasClass(t.id, cp + "Disabled")) DOM.addClass(t.id, cp + "Hover");
                });
                Event.add(t.id, "mouseout", function() {
                    if (!DOM.hasClass(t.id, cp + "Disabled")) DOM.removeClass(t.id, cp + "Hover");
                });
            }
            t.onPostRender.dispatch(t, DOM.get(t.id));
        },
        destroy: function() {
            this.parent();
            Event.clear(this.id + "_text");
            Event.clear(this.id + "_open");
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, Dispatcher = tinymce.util.Dispatcher, undef;
    tinymce.create("tinymce.ui.NativeListBox:tinymce.ui.ListBox", {
        NativeListBox: function(id, s) {
            this.parent(id, s);
            this.classPrefix = "mceNativeListBox";
        },
        setDisabled: function(s) {
            DOM.get(this.id).disabled = s;
            this.setAriaProperty("disabled", s);
        },
        isDisabled: function() {
            return DOM.get(this.id).disabled;
        },
        select: function(va) {
            var t = this, fv, f;
            if (va == undef) return t.selectByIndex(-1);
            if (va && "function" == typeof va) f = va; else f = function(v) {
                return v == va;
            };
            if (va != t.selectedValue) {
                each(t.items, function(o, i) {
                    if (f(o.value)) {
                        fv = 1;
                        t.selectByIndex(i);
                        return false;
                    }
                });
                if (!fv) t.selectByIndex(-1);
            }
        },
        selectByIndex: function(idx) {
            DOM.get(this.id).selectedIndex = idx + 1;
            this.selectedValue = this.items[idx] ? this.items[idx].value : null;
        },
        add: function(n, v, a) {
            var o, t = this;
            a = a || {};
            a.value = v;
            if (t.isRendered()) DOM.add(DOM.get(this.id), "option", a, n);
            o = {
                title: n,
                value: v,
                attribs: a
            };
            t.items.push(o);
            t.onAdd.dispatch(t, o);
        },
        getLength: function() {
            return this.items.length;
        },
        renderHTML: function() {
            var h, t = this;
            h = DOM.createHTML("option", {
                value: ""
            }, "-- " + t.settings.title + " --");
            each(t.items, function(it) {
                h += DOM.createHTML("option", {
                    value: it.value
                }, it.title);
            });
            h = DOM.createHTML("select", {
                id: t.id,
                "class": "mceNativeListBox",
                "aria-labelledby": t.id + "_aria"
            }, h);
            h += DOM.createHTML("span", {
                id: t.id + "_aria",
                style: "display: none"
            }, t.settings.title);
            return h;
        },
        postRender: function() {
            var t = this, ch, changeListenerAdded = true;
            t.rendered = true;
            function onChange(e) {
                var v = t.items[e.target.selectedIndex - 1];
                if (v && (v = v.value)) {
                    t.onChange.dispatch(t, v);
                    if (t.settings.onselect) t.settings.onselect(v);
                }
            }
            Event.add(t.id, "change", onChange);
            Event.add(t.id, "keydown", function(e) {
                var bf;
                Event.remove(t.id, "change", ch);
                changeListenerAdded = false;
                bf = Event.add(t.id, "blur", function() {
                    if (changeListenerAdded) return;
                    changeListenerAdded = true;
                    Event.add(t.id, "change", onChange);
                    Event.remove(t.id, "blur", bf);
                });
                if (tinymce.isWebKit && (37 == e.keyCode || 39 == e.keyCode)) return Event.prevent(e);
                if (13 == e.keyCode || 32 == e.keyCode) {
                    onChange(e);
                    return Event.cancel(e);
                }
            });
            t.onPostRender.dispatch(t, DOM.get(t.id));
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each;
    tinymce.create("tinymce.ui.MenuButton:tinymce.ui.Button", {
        MenuButton: function(id, s, ed) {
            this.parent(id, s, ed);
            this.onRenderMenu = new tinymce.util.Dispatcher(this);
            s.menu_container = s.menu_container || DOM.doc.body;
        },
        showMenu: function() {
            var t = this, p1, p2, e = DOM.get(t.id), m;
            if (t.isDisabled()) return;
            if (!t.isMenuRendered) {
                t.renderMenu();
                t.isMenuRendered = true;
            }
            if (t.isMenuVisible) return t.hideMenu();
            p1 = DOM.getPos(t.settings.menu_container);
            p2 = DOM.getPos(e);
            m = t.menu;
            m.settings.offset_x = p2.x;
            m.settings.offset_y = p2.y;
            m.settings.vp_offset_x = p2.x;
            m.settings.vp_offset_y = p2.y;
            m.settings.keyboard_focus = t._focused;
            m.showMenu(0, e.firstChild.clientHeight);
            Event.add(DOM.doc, "mousedown", t.hideMenu, t);
            t.setState("Selected", 1);
            t.isMenuVisible = 1;
        },
        renderMenu: function() {
            var t = this, m;
            m = t.settings.control_manager.createDropMenu(t.id + "_menu", {
                menu_line: 1,
                "class": this.classPrefix + "Menu",
                icons: t.settings.icons
            });
            m.onHideMenu.add(function() {
                t.hideMenu();
                t.focus();
            });
            t.onRenderMenu.dispatch(t, m);
            t.menu = m;
        },
        hideMenu: function(e) {
            var t = this;
            if (e && "mousedown" == e.type && DOM.getParent(e.target, function(e) {
                return e.id === t.id || e.id === t.id + "_open";
            })) return;
            if (!e || !DOM.getParent(e.target, ".mceMenu")) {
                t.setState("Selected", 0);
                Event.remove(DOM.doc, "mousedown", t.hideMenu, t);
                if (t.menu) t.menu.hideMenu();
            }
            t.isMenuVisible = 0;
        },
        postRender: function() {
            var t = this, s = t.settings;
            Event.add(t.id, "click", function() {
                if (!t.isDisabled()) {
                    if (s.onclick) s.onclick(t.value);
                    t.showMenu();
                }
            });
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each;
    tinymce.create("tinymce.ui.SplitButton:tinymce.ui.MenuButton", {
        SplitButton: function(id, s, ed) {
            this.parent(id, s, ed);
            this.classPrefix = "mceSplitButton";
        },
        renderHTML: function() {
            var cp = this.classPrefix, h, t = this, s = t.settings, h1;
            h = "<tbody><tr>";
            var l = DOM.encode(s.label || "");
            if (s.image) h1 = DOM.createHTML("img ", {
                src: s.image,
                role: "presentation",
                "class": "mceAction " + s["class"]
            }) + 1; else h1 = DOM.createHTML("span", {
                "class": "mceAction " + s["class"]
            }, "") + (l ? '<span class="' + cp + 'Label">' + l + "</span>" : "");
            h1 += DOM.createHTML("span", {
                "class": "mceVoiceLabel mceIconOnly",
                id: t.id + "_voice",
                style: "display:none;"
            }, s.title);
            h += "<td >" + DOM.createHTML("a", {
                role: "button",
                id: t.id + "_action",
                tabindex: "-1",
                href: "javascript:;",
                "class": "mceAction " + s["class"],
                onclick: "return false;",
                onmousedown: "return false;",
                title: s.title
            }, h1) + "</td>";
            h1 = DOM.createHTML("span", {
                "class": "mceOpen " + s["class"]
            }, "");
            h += "<td>" + DOM.createHTML("a", {
                id: t.id + "_open",
                href: "javascript:;",
                "class": "mceOpen " + s["class"],
                onclick: "return false;",
                onmousedown: "return false;",
                title: s.title
            }, h1) + "</td>";
            h += "</tr></tbody>";
            return DOM.createHTML("table", {
                id: t.id,
                "class": cp + " " + cp + "Enabled " + s["class"] + (l ? " " + cp + "Labeled" : ""),
                cellpadding: "0",
                cellspacing: "0",
                onmousedown: "return false;",
                title: s.title
            }, h);
        },
        postRender: function() {
            var t = this, s = t.settings, activate;
            if (s.onclick) {
                activate = function(evt) {
                    if (!t.isDisabled()) {
                        s.onclick(t.value);
                        Event.cancel(evt);
                    }
                };
                Event.add(t.id + "_action", "click", activate);
                Event.add(t.id, [ "click", "keydown" ], function(evt) {
                    var DOM_VK_SPACE = 32, DOM_VK_ENTER = 14, DOM_VK_RETURN = 13, DOM_VK_UP = 38, DOM_VK_DOWN = 40;
                    if ((32 === evt.keyCode || 13 === evt.keyCode || 14 === evt.keyCode) && !evt.altKey && !evt.ctrlKey && !evt.metaKey) {
                        activate();
                        Event.cancel(evt);
                    } else if ("click" === evt.type || evt.keyCode === DOM_VK_DOWN) {
                        t.showMenu();
                        Event.cancel(evt);
                    }
                });
            }
            Event.add(t.id + "_open", "click", function(evt) {
                t.showMenu();
                Event.cancel(evt);
            });
            Event.add([ t.id, t.id + "_open" ], "focus", function() {
                t._focused = 1;
            });
            Event.add([ t.id, t.id + "_open" ], "blur", function() {
                t._focused = 0;
            });
            if (tinymce.isIE6 || !DOM.boxModel) {
                Event.add(t.id, "mouseover", function() {
                    if (!DOM.hasClass(t.id, "mceSplitButtonDisabled")) DOM.addClass(t.id, "mceSplitButtonHover");
                });
                Event.add(t.id, "mouseout", function() {
                    if (!DOM.hasClass(t.id, "mceSplitButtonDisabled")) DOM.removeClass(t.id, "mceSplitButtonHover");
                });
            }
        },
        destroy: function() {
            this.parent();
            Event.clear(this.id + "_action");
            Event.clear(this.id + "_open");
            Event.clear(this.id);
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event, is = tinymce.is, each = tinymce.each;
    tinymce.create("tinymce.ui.ColorSplitButton:tinymce.ui.SplitButton", {
        ColorSplitButton: function(id, s, ed) {
            var t = this;
            t.parent(id, s, ed);
            t.settings = s = tinymce.extend({
                colors: "000000,993300,333300,003300,003366,000080,333399,333333,800000,FF6600,808000,008000,008080,0000FF,666699,808080,FF0000,FF9900,99CC00,339966,33CCCC,3366FF,800080,999999,FF00FF,FFCC00,FFFF00,00FF00,00FFFF,00CCFF,993366,C0C0C0,FF99CC,FFCC99,FFFF99,CCFFCC,CCFFFF,99CCFF,CC99FF,FFFFFF",
                grid_width: 8,
                default_color: "#888888"
            }, t.settings);
            t.onShowMenu = new tinymce.util.Dispatcher(t);
            t.onHideMenu = new tinymce.util.Dispatcher(t);
            t.value = s.default_color;
        },
        showMenu: function() {
            var t = this, r, p, e, p2;
            if (t.isDisabled()) return;
            if (!t.isMenuRendered) {
                t.renderMenu();
                t.isMenuRendered = true;
            }
            if (t.isMenuVisible) return t.hideMenu();
            e = DOM.get(t.id);
            DOM.show(t.id + "_menu");
            DOM.addClass(e, "mceSplitButtonSelected");
            p2 = DOM.getPos(e);
            DOM.setStyles(t.id + "_menu", {
                left: p2.x,
                top: p2.y + e.firstChild.clientHeight,
                zIndex: 2e5
            });
            e = 0;
            Event.add(DOM.doc, "mousedown", t.hideMenu, t);
            t.onShowMenu.dispatch(t);
            if (t._focused) {
                t._keyHandler = Event.add(t.id + "_menu", "keydown", function(e) {
                    if (27 == e.keyCode) t.hideMenu();
                });
                DOM.select("a", t.id + "_menu")[0].focus();
            }
            t.keyboardNav = new tinymce.ui.KeyboardNavigation({
                root: t.id + "_menu",
                items: DOM.select("a", t.id + "_menu"),
                onCancel: function() {
                    t.hideMenu();
                    t.focus();
                }
            });
            t.keyboardNav.focus();
            t.isMenuVisible = 1;
        },
        hideMenu: function(e) {
            var t = this;
            if (t.isMenuVisible) {
                if (e && "mousedown" == e.type && DOM.getParent(e.target, function(e) {
                    return e.id === t.id + "_open";
                })) return;
                if (!e || !DOM.getParent(e.target, ".mceSplitButtonMenu")) {
                    DOM.removeClass(t.id, "mceSplitButtonSelected");
                    Event.remove(DOM.doc, "mousedown", t.hideMenu, t);
                    Event.remove(t.id + "_menu", "keydown", t._keyHandler);
                    DOM.hide(t.id + "_menu");
                }
                t.isMenuVisible = 0;
                t.onHideMenu.dispatch();
                t.keyboardNav.destroy();
            }
        },
        renderMenu: function() {
            var t = this, m, i = 0, s = t.settings, n, tb, tr, w, context;
            w = DOM.add(s.menu_container, "div", {
                role: "listbox",
                id: t.id + "_menu",
                "class": s.menu_class + " " + s["class"],
                style: "position:absolute;left:0;top:-1000px;"
            });
            m = DOM.add(w, "div", {
                "class": s["class"] + " mceSplitButtonMenu"
            });
            DOM.add(m, "span", {
                "class": "mceMenuLine"
            });
            n = DOM.add(m, "table", {
                role: "presentation",
                "class": "mceColorSplitMenu"
            });
            tb = DOM.add(n, "tbody");
            i = 0;
            each(is(s.colors, "array") ? s.colors : s.colors.split(","), function(c) {
                c = c.replace(/^#/, "");
                if (!i--) {
                    tr = DOM.add(tb, "tr");
                    i = s.grid_width - 1;
                }
                n = DOM.add(tr, "td");
                var settings = {
                    href: "javascript:;",
                    style: {
                        backgroundColor: "#" + c
                    },
                    title: t.editor.getLang("colors." + c, c),
                    "data-mce-color": "#" + c
                };
                if (!tinymce.isIE) settings.role = "option";
                n = DOM.add(n, "a", settings);
                if (t.editor.forcedHighContrastMode) {
                    n = DOM.add(n, "canvas", {
                        width: 16,
                        height: 16,
                        "aria-hidden": "true"
                    });
                    if (n.getContext && (context = n.getContext("2d"))) {
                        context.fillStyle = "#" + c;
                        context.fillRect(0, 0, 16, 16);
                    } else DOM.remove(n);
                }
            });
            if (s.more_colors_func) {
                n = DOM.add(tb, "tr");
                n = DOM.add(n, "td", {
                    colspan: s.grid_width,
                    "class": "mceMoreColors"
                });
                n = DOM.add(n, "a", {
                    role: "option",
                    id: t.id + "_more",
                    href: "javascript:;",
                    onclick: "return false;",
                    "class": "mceMoreColors"
                }, s.more_colors_title);
                Event.add(n, "click", function(e) {
                    s.more_colors_func.call(s.more_colors_scope || this);
                    return Event.cancel(e);
                });
            }
            DOM.addClass(m, "mceColorSplitMenu");
            Event.add(t.id + "_menu", "mousedown", function(e) {
                return Event.cancel(e);
            });
            Event.add(t.id + "_menu", "click", function(e) {
                var c;
                e = DOM.getParent(e.target, "a", tb);
                if (e && "a" == e.nodeName.toLowerCase() && (c = e.getAttribute("data-mce-color"))) t.setColor(c);
                return false;
            });
            return w;
        },
        setColor: function(c) {
            this.displayColor(c);
            this.hideMenu();
            this.settings.onselect(c);
        },
        displayColor: function(c) {
            var t = this;
            DOM.setStyle(t.id + "_preview", "backgroundColor", c);
            t.value = c;
        },
        postRender: function() {
            var t = this, id = t.id;
            t.parent();
            DOM.add(id + "_action", "div", {
                id: id + "_preview",
                "class": "mceColorPreview"
            });
            DOM.setStyle(t.id + "_preview", "backgroundColor", t.value);
        },
        destroy: function() {
            var self = this;
            self.parent();
            Event.clear(self.id + "_menu");
            Event.clear(self.id + "_more");
            DOM.remove(self.id + "_menu");
            if (self.keyboardNav) self.keyboardNav.destroy();
        }
    });
})(tinymce);

(function(tinymce) {
    var dom = tinymce.DOM, each = tinymce.each, Event = tinymce.dom.Event;
    tinymce.create("tinymce.ui.ToolbarGroup:tinymce.ui.Container", {
        renderHTML: function() {
            var t = this, h = [], controls = t.controls, each = tinymce.each, settings = t.settings;
            h.push('<div id="' + t.id + '" role="group" aria-labelledby="' + t.id + '_voice">');
            h.push("<span role='application'>");
            h.push('<span id="' + t.id + '_voice" class="mceVoiceLabel" style="display:none;">' + dom.encode(settings.name) + "</span>");
            each(controls, function(toolbar) {
                h.push(toolbar.renderHTML());
            });
            h.push("</span>");
            h.push("</div>");
            return h.join("");
        },
        focus: function() {
            var t = this;
            dom.get(t.id).focus();
        },
        postRender: function() {
            var t = this, items = [];
            each(t.controls, function(toolbar) {
                each(toolbar.controls, function(control) {
                    if (control.id) items.push(control);
                });
            });
            t.keyNav = new tinymce.ui.KeyboardNavigation({
                root: t.id,
                items: items,
                onCancel: function() {
                    if (tinymce.isWebKit) dom.get(t.editor.id + "_ifr").focus();
                    t.editor.focus();
                },
                excludeFromTabOrder: !t.settings.tab_focus_toolbar
            });
        },
        destroy: function() {
            var self = this;
            self.parent();
            self.keyNav.destroy();
            Event.clear(self.id);
        }
    });
})(tinymce);

(function(tinymce) {
    var dom = tinymce.DOM, each = tinymce.each;
    tinymce.create("tinymce.ui.Toolbar:tinymce.ui.Container", {
        renderHTML: function() {
            var t = this, h = "", c, co, s = t.settings, i, pr, nx, cl;
            cl = t.controls;
            for (i = 0; i < cl.length; i++) {
                co = cl[i];
                pr = cl[i - 1];
                nx = cl[i + 1];
                if (0 === i) {
                    c = "mceToolbarStart";
                    if (co.Button) c += " mceToolbarStartButton"; else if (co.SplitButton) c += " mceToolbarStartSplitButton"; else if (co.ListBox) c += " mceToolbarStartListBox";
                    h += dom.createHTML("td", {
                        "class": c
                    }, dom.createHTML("span", null, "<!-- IE -->"));
                }
                if (pr && co.ListBox) if (pr.Button || pr.SplitButton) h += dom.createHTML("td", {
                    "class": "mceToolbarEnd"
                }, dom.createHTML("span", null, "<!-- IE -->"));
                if (dom.stdMode) h += '<td style="position: relative">' + co.renderHTML() + "</td>"; else h += "<td>" + co.renderHTML() + "</td>";
                if (nx && co.ListBox) if (nx.Button || nx.SplitButton) h += dom.createHTML("td", {
                    "class": "mceToolbarStart"
                }, dom.createHTML("span", null, "<!-- IE -->"));
            }
            c = "mceToolbarEnd";
            if (co.Button) c += " mceToolbarEndButton"; else if (co.SplitButton) c += " mceToolbarEndSplitButton"; else if (co.ListBox) c += " mceToolbarEndListBox";
            h += dom.createHTML("td", {
                "class": c
            }, dom.createHTML("span", null, "<!-- IE -->"));
            return dom.createHTML("table", {
                id: t.id,
                "class": "mceToolbar" + (s["class"] ? " " + s["class"] : ""),
                cellpadding: "0",
                cellspacing: "0",
                align: t.settings.align || "",
                role: "presentation",
                tabindex: "-1"
            }, "<tbody><tr>" + h + "</tr></tbody>");
        }
    });
})(tinymce);

(function(tinymce) {
    var Dispatcher = tinymce.util.Dispatcher, each = tinymce.each;
    tinymce.create("tinymce.AddOnManager", {
        AddOnManager: function() {
            var self = this;
            self.items = [];
            self.urls = {};
            self.lookup = {};
            self.onAdd = new Dispatcher(self);
        },
        get: function(n) {
            if (this.lookup[n]) return this.lookup[n].instance; else return void 0;
        },
        dependencies: function(n) {
            var result;
            if (this.lookup[n]) result = this.lookup[n].dependencies;
            return result || [];
        },
        requireLangPack: function(n) {
            var s = tinymce.settings;
            if (s && s.language && false !== s.language_load) tinymce.ScriptLoader.add(this.urls[n] + "/langs/" + s.language + ".js");
        },
        add: function(id, o, dependencies) {
            this.items.push(o);
            this.lookup[id] = {
                instance: o,
                dependencies: dependencies
            };
            this.onAdd.dispatch(this, id, o);
            return o;
        },
        createUrl: function(baseUrl, dep) {
            if ("object" === typeof dep) return dep; else return {
                prefix: baseUrl.prefix,
                resource: dep,
                suffix: baseUrl.suffix
            };
        },
        addComponents: function(pluginName, scripts) {
            var pluginUrl = this.urls[pluginName];
            tinymce.each(scripts, function(script) {
                tinymce.ScriptLoader.add(pluginUrl + "/" + script);
            });
        },
        load: function(n, u, cb, s) {
            var t = this, url = u;
            function loadDependencies() {
                var dependencies = t.dependencies(n);
                tinymce.each(dependencies, function(dep) {
                    var newUrl = t.createUrl(u, dep);
                    t.load(newUrl.resource, newUrl, void 0, void 0);
                });
                if (cb) if (s) cb.call(s); else cb.call(tinymce.ScriptLoader);
            }
            if (t.urls[n]) return;
            if ("object" === typeof u) url = u.prefix + u.resource + u.suffix;
            if (0 !== url.indexOf("/") && url.indexOf("://") == -1) url = tinymce.baseURL + "/" + url;
            t.urls[n] = url.substring(0, url.lastIndexOf("/"));
            if (t.lookup[n]) loadDependencies(); else tinymce.ScriptLoader.add(url, loadDependencies, s);
        }
    });
    tinymce.PluginManager = new tinymce.AddOnManager();
    tinymce.ThemeManager = new tinymce.AddOnManager();
})(tinymce);

(function(tinymce) {
    var each = tinymce.each, extend = tinymce.extend, DOM = tinymce.DOM, Event = tinymce.dom.Event, ThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager, explode = tinymce.explode, Dispatcher = tinymce.util.Dispatcher, undef, instanceCounter = 0;
    tinymce.documentBaseURL = window.location.href.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
    if (!/[\/\\]$/.test(tinymce.documentBaseURL)) tinymce.documentBaseURL += "/";
    tinymce.baseURL = new tinymce.util.URI(tinymce.documentBaseURL).toAbsolute(tinymce.baseURL);
    tinymce.baseURI = new tinymce.util.URI(tinymce.baseURL);
    tinymce.onBeforeUnload = new Dispatcher(tinymce);
    Event.add(window, "beforeunload", function(e) {
        tinymce.onBeforeUnload.dispatch(tinymce, e);
    });
    tinymce.onAddEditor = new Dispatcher(tinymce);
    tinymce.onRemoveEditor = new Dispatcher(tinymce);
    tinymce.EditorManager = extend(tinymce, {
        editors: [],
        i18n: {},
        activeEditor: null,
        init: function(s) {
            var t = this, pl, sl = tinymce.ScriptLoader, e, el = [], ed;
            function createId(elm) {
                var id = elm.id;
                if (!id) {
                    id = elm.name;
                    if (id && !DOM.get(id)) id = elm.name; else id = DOM.uniqueId();
                    elm.setAttribute("id", id);
                }
                return id;
            }
            function execCallback(se, n, s) {
                var f = se[n];
                if (!f) return;
                if (tinymce.is(f, "string")) {
                    s = f.replace(/\.\w+$/, "");
                    s = s ? tinymce.resolve(s) : 0;
                    f = tinymce.resolve(f);
                }
                return f.apply(s || this, Array.prototype.slice.call(arguments, 2));
            }
            function hasClass(n, c) {
                return c.constructor === RegExp ? c.test(n.className) : DOM.hasClass(n, c);
            }
            t.settings = s;
            Event.bind(window, "ready", function() {
                var l, co;
                execCallback(s, "onpageload");
                switch (s.mode) {
                  case "exact":
                    l = s.elements || "";
                    if (l.length > 0) each(explode(l), function(v) {
                        if (DOM.get(v)) {
                            ed = new tinymce.Editor(v, s);
                            el.push(ed);
                            ed.render(1);
                        } else each(document.forms, function(f) {
                            each(f.elements, function(e) {
                                if (e.name === v) {
                                    v = "mce_editor_" + instanceCounter++;
                                    DOM.setAttrib(e, "id", v);
                                    ed = new tinymce.Editor(v, s);
                                    el.push(ed);
                                    ed.render(1);
                                }
                            });
                        });
                    });
                    break;

                  case "textareas":
                  case "specific_textareas":
                    each(DOM.select("textarea"), function(elm) {
                        if (s.editor_deselector && hasClass(elm, s.editor_deselector)) return;
                        if (!s.editor_selector || hasClass(elm, s.editor_selector)) {
                            ed = new tinymce.Editor(createId(elm), s);
                            el.push(ed);
                            ed.render(1);
                        }
                    });
                    break;

                  default:
                    if (s.types) each(s.types, function(type) {
                        each(DOM.select(type.selector), function(elm) {
                            var editor = new tinymce.Editor(createId(elm), tinymce.extend({}, s, type));
                            el.push(editor);
                            editor.render(1);
                        });
                    }); else if (s.selector) each(DOM.select(s.selector), function(elm) {
                        var editor = new tinymce.Editor(createId(elm), s);
                        el.push(editor);
                        editor.render(1);
                    });
                }
                if (s.oninit) {
                    l = co = 0;
                    each(el, function(ed) {
                        co++;
                        if (!ed.initialized) ed.onInit.add(function() {
                            l++;
                            if (l == co) execCallback(s, "oninit");
                        }); else l++;
                        if (l == co) execCallback(s, "oninit");
                    });
                }
            });
        },
        get: function(id) {
            if (id === undef) return this.editors;
            if (!this.editors.hasOwnProperty(id)) return undef;
            return this.editors[id];
        },
        getInstanceById: function(id) {
            return this.get(id);
        },
        add: function(editor) {
            var self = this, editors = self.editors;
            editors[editor.id] = editor;
            editors.push(editor);
            self._setActive(editor);
            self.onAddEditor.dispatch(self, editor);
            if (tinymce.adapter) tinymce.adapter.patchEditor(editor);
            return editor;
        },
        remove: function(editor) {
            var t = this, i, editors = t.editors;
            if (!editors[editor.id]) return null;
            delete editors[editor.id];
            for (i = 0; i < editors.length; i++) if (editors[i] == editor) {
                editors.splice(i, 1);
                break;
            }
            if (t.activeEditor == editor) t._setActive(editors[0]);
            editor.destroy();
            t.onRemoveEditor.dispatch(t, editor);
            return editor;
        },
        execCommand: function(c, u, v) {
            var t = this, ed = t.get(v), w;
            function clr() {
                ed.destroy();
                w.detachEvent("onunload", clr);
                w = w.tinyMCE = w.tinymce = null;
            }
            switch (c) {
              case "mceFocus":
                ed.focus();
                return true;

              case "mceAddEditor":
              case "mceAddControl":
                if (!t.get(v)) new tinymce.Editor(v, t.settings).render();
                return true;

              case "mceAddFrameControl":
                w = v.window;
                w.tinyMCE = tinyMCE;
                w.tinymce = tinymce;
                tinymce.DOM.doc = w.document;
                tinymce.DOM.win = w;
                ed = new tinymce.Editor(v.element_id, v);
                ed.render();
                if (tinymce.isIE) w.attachEvent("onunload", clr);
                v.page_window = null;
                return true;

              case "mceRemoveEditor":
              case "mceRemoveControl":
                if (ed) ed.remove();
                return true;

              case "mceToggleEditor":
                if (!ed) {
                    t.execCommand("mceAddControl", 0, v);
                    return true;
                }
                if (ed.isHidden()) ed.show(); else ed.hide();
                return true;
            }
            if (t.activeEditor) return t.activeEditor.execCommand(c, u, v);
            return false;
        },
        execInstanceCommand: function(id, c, u, v) {
            var ed = this.get(id);
            if (ed) return ed.execCommand(c, u, v);
            return false;
        },
        triggerSave: function() {
            each(this.editors, function(e) {
                e.save();
            });
        },
        addI18n: function(p, o) {
            var lo, i18n = this.i18n;
            if (!tinymce.is(p, "string")) each(p, function(o, lc) {
                each(o, function(o, g) {
                    each(o, function(o, k) {
                        if ("common" === g) i18n[lc + "." + k] = o; else i18n[lc + "." + g + "." + k] = o;
                    });
                });
            }); else each(o, function(o, k) {
                i18n[p + "." + k] = o;
            });
        },
        _setActive: function(editor) {
            this.selectedInstance = this.activeEditor = editor;
        }
    });
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event, extend = tinymce.extend, each = tinymce.each, isGecko = tinymce.isGecko, isIE = tinymce.isIE, isWebKit = tinymce.isWebKit, is = tinymce.is, ThemeManager = tinymce.ThemeManager, PluginManager = tinymce.PluginManager, explode = tinymce.explode;
    tinymce.create("tinymce.Editor", {
        Editor: function(id, settings) {
            var self = this, TRUE = true;
            self.settings = settings = extend({
                id: id,
                language: "en",
                theme: "advanced",
                skin: "default",
                delta_width: 0,
                delta_height: 0,
                popup_css: "",
                plugins: "",
                document_base_url: tinymce.documentBaseURL,
                add_form_submit_trigger: TRUE,
                submit_patch: TRUE,
                add_unload_trigger: TRUE,
                convert_urls: TRUE,
                relative_urls: TRUE,
                remove_script_host: TRUE,
                table_inline_editing: false,
                object_resizing: TRUE,
                accessibility_focus: TRUE,
                doctype: tinymce.isIE6 ? '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">' : "<!DOCTYPE>",
                visual: TRUE,
                font_size_style_values: "xx-small,x-small,small,medium,large,x-large,xx-large",
                font_size_legacy_values: "xx-small,small,medium,large,x-large,xx-large,300%",
                apply_source_formatting: TRUE,
                directionality: "ltr",
                forced_root_block: "p",
                hidden_input: TRUE,
                padd_empty_editor: TRUE,
                render_ui: TRUE,
                indentation: "30px",
                fix_table_elements: TRUE,
                inline_styles: TRUE,
                convert_fonts_to_spans: TRUE,
                indent: "simple",
                indent_before: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist",
                indent_after: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist",
                validate: TRUE,
                entity_encoding: "named",
                url_converter: self.convertURL,
                url_converter_scope: self,
                ie7_compat: TRUE
            }, settings);
            self.id = self.editorId = id;
            self.isNotDirty = false;
            self.plugins = {};
            self.documentBaseURI = new tinymce.util.URI(settings.document_base_url || tinymce.documentBaseURL, {
                base_uri: tinyMCE.baseURI
            });
            self.baseURI = tinymce.baseURI;
            self.contentCSS = [];
            self.contentStyles = [];
            self.setupEvents();
            self.execCommands = {};
            self.queryStateCommands = {};
            self.queryValueCommands = {};
            self.execCallback("setup", self);
        },
        render: function(nst) {
            var t = this, s = t.settings, id = t.id, sl = tinymce.ScriptLoader;
            if (!Event.domLoaded) {
                Event.add(window, "ready", function() {
                    t.render();
                });
                return;
            }
            tinyMCE.settings = s;
            if (!t.getElement()) return;
            if (tinymce.isIDevice && !tinymce.isIOS5) return;
            if (!/TEXTAREA|INPUT/i.test(t.getElement().nodeName) && s.hidden_input && DOM.getParent(id, "form")) DOM.insertAfter(DOM.create("input", {
                type: "hidden",
                name: id
            }), id);
            if (!s.content_editable) {
                t.orgVisibility = t.getElement().style.visibility;
                t.getElement().style.visibility = "hidden";
            }
            if (tinymce.WindowManager) t.windowManager = new tinymce.WindowManager(t);
            if ("xml" == s.encoding) t.onGetContent.add(function(ed, o) {
                if (o.save) o.content = DOM.encode(o.content);
            });
            if (s.add_form_submit_trigger) t.onSubmit.addToTop(function() {
                if (t.initialized) {
                    t.save();
                    t.isNotDirty = 1;
                }
            });
            if (s.add_unload_trigger) t._beforeUnload = tinyMCE.onBeforeUnload.add(function() {
                if (t.initialized && !t.destroyed && !t.isHidden()) t.save({
                    format: "raw",
                    no_events: true
                });
            });
            tinymce.addUnload(t.destroy, t);
            if (s.submit_patch) t.onBeforeRenderUI.add(function() {
                var n = t.getElement().form;
                if (!n) return;
                if (n._mceOldSubmit) return;
                if (!n.submit.nodeType && !n.submit.length) {
                    t.formElement = n;
                    n._mceOldSubmit = n.submit;
                    n.submit = function() {
                        tinymce.triggerSave();
                        t.isNotDirty = 1;
                        return t.formElement._mceOldSubmit(t.formElement);
                    };
                }
                n = null;
            });
            function loadScripts() {
                if (s.language && false !== s.language_load) sl.add(tinymce.baseURL + "/langs/" + s.language + ".js");
                if (s.theme && "function" != typeof s.theme && "-" != s.theme.charAt(0) && !ThemeManager.urls[s.theme]) ThemeManager.load(s.theme, "themes/" + s.theme + "/editor_template" + tinymce.suffix + ".js");
                each(explode(s.plugins), function(p) {
                    if (p && !PluginManager.urls[p]) if ("-" == p.charAt(0)) {
                        p = p.substr(1, p.length);
                        var dependencies = PluginManager.dependencies(p);
                        each(dependencies, function(dep) {
                            var defaultSettings = {
                                prefix: "plugins/",
                                resource: dep,
                                suffix: "/editor_plugin" + tinymce.suffix + ".js"
                            };
                            dep = PluginManager.createUrl(defaultSettings, dep);
                            PluginManager.load(dep.resource, dep);
                        });
                    } else {
                        if ("safari" == p) return;
                        PluginManager.load(p, {
                            prefix: "plugins/",
                            resource: p,
                            suffix: "/editor_plugin" + tinymce.suffix + ".js"
                        });
                    }
                });
                sl.loadQueue(function() {
                    if (!t.removed) t.init();
                });
            }
            loadScripts();
        },
        init: function() {
            var n, t = this, s = t.settings, w, h, mh, e = t.getElement(), o, ti, u, bi, bc, re, i, initializedPlugins = [];
            tinymce.add(t);
            s.aria_label = s.aria_label || DOM.getAttrib(e, "aria-label", t.getLang("aria.rich_text_area"));
            if (s.theme) if ("function" != typeof s.theme) {
                s.theme = s.theme.replace(/-/, "");
                o = ThemeManager.get(s.theme);
                t.theme = new o();
                if (t.theme.init) t.theme.init(t, ThemeManager.urls[s.theme] || tinymce.documentBaseURL.replace(/\/$/, ""));
            } else t.theme = s.theme;
            function initPlugin(p) {
                var c = PluginManager.get(p), u = PluginManager.urls[p] || tinymce.documentBaseURL.replace(/\/$/, ""), po;
                if (c && tinymce.inArray(initializedPlugins, p) === -1) {
                    each(PluginManager.dependencies(p), function(dep) {
                        initPlugin(dep);
                    });
                    po = new c(t, u);
                    t.plugins[p] = po;
                    if (po.init) {
                        po.init(t, u);
                        initializedPlugins.push(p);
                    }
                }
            }
            each(explode(s.plugins.replace(/\-/g, "")), initPlugin);
            if (false !== s.popup_css) if (s.popup_css) s.popup_css = t.documentBaseURI.toAbsolute(s.popup_css); else s.popup_css = t.baseURI.toAbsolute("themes/" + s.theme + "/skins/" + s.skin + "/dialog.css");
            if (s.popup_css_add) s.popup_css += "," + t.documentBaseURI.toAbsolute(s.popup_css_add);
            t.controlManager = new tinymce.ControlManager(t);
            t.onBeforeRenderUI.dispatch(t, t.controlManager);
            if (s.render_ui && t.theme) {
                t.orgDisplay = e.style.display;
                if ("function" != typeof s.theme) {
                    w = s.width || e.style.width || e.offsetWidth;
                    h = s.height || e.style.height || e.offsetHeight;
                    mh = s.min_height || 100;
                    re = /^[0-9\.]+(|px)$/i;
                    if (re.test("" + w)) w = Math.max(parseInt(w, 10) + (o.deltaWidth || 0), 100);
                    if (re.test("" + h)) h = Math.max(parseInt(h, 10) + (o.deltaHeight || 0), mh);
                    o = t.theme.renderUI({
                        targetNode: e,
                        width: w,
                        height: h,
                        deltaWidth: s.delta_width,
                        deltaHeight: s.delta_height
                    });
                    DOM.setStyles(o.sizeContainer || o.editorContainer, {
                        width: w,
                        height: h
                    });
                    h = (o.iframeHeight || h) + ("number" == typeof h ? o.deltaHeight || 0 : "");
                    if (h < mh) h = mh;
                } else {
                    o = s.theme(t, e);
                    if (o.editorContainer.nodeType) o.editorContainer = o.editorContainer.id = o.editorContainer.id || t.id + "_parent";
                    if (o.iframeContainer.nodeType) o.iframeContainer = o.iframeContainer.id = o.iframeContainer.id || t.id + "_iframecontainer";
                    h = o.iframeHeight || e.offsetHeight;
                    if (isIE) t.onInit.add(function(ed) {
                        ed.dom.bind(ed.getBody(), "beforedeactivate keydown", function() {
                            ed.lastIERng = ed.selection.getRng();
                        });
                    });
                }
                t.editorContainer = o.editorContainer;
            }
            if (s.content_css) each(explode(s.content_css), function(u) {
                t.contentCSS.push(t.documentBaseURI.toAbsolute(u));
            });
            if (s.content_style) t.contentStyles.push(s.content_style);
            if (s.content_editable) {
                e = n = o = null;
                return t.initContentBody();
            }
            if (document.domain && location.hostname != document.domain) tinymce.relaxedDomain = document.domain;
            t.iframeHTML = s.doctype + '<html><head xmlns="http://www.w3.org/1999/xhtml">';
            if (s.document_base_url != tinymce.documentBaseURL) t.iframeHTML += '<base href="' + t.documentBaseURI.getURI() + '" />';
            if (s.ie7_compat) t.iframeHTML += '<meta http-equiv="X-UA-Compatible" content="IE=7" />'; else t.iframeHTML += '<meta http-equiv="X-UA-Compatible" content="IE=edge" />';
            t.iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
            for (i = 0; i < t.contentCSS.length; i++) t.iframeHTML += '<link type="text/css" rel="stylesheet" href="' + t.contentCSS[i] + '" />';
            t.contentCSS = [];
            bi = s.body_id || "tinymce";
            if (bi.indexOf("=") != -1) {
                bi = t.getParam("body_id", "", "hash");
                bi = bi[t.id] || bi;
            }
            bc = s.body_class || "";
            if (bc.indexOf("=") != -1) {
                bc = t.getParam("body_class", "", "hash");
                bc = bc[t.id] || "";
            }
            t.iframeHTML += '</head><body id="' + bi + '" class="mceContentBody ' + bc + '" onload="window.parent.tinyMCE.get(\'' + t.id + "').onLoad.dispatch();\"><br></body></html>";
            if (tinymce.relaxedDomain && (isIE || tinymce.isOpera && parseFloat(opera.version()) < 11)) u = 'javascript:(function(){document.open();document.domain="' + document.domain + '";var ed = window.parent.tinyMCE.get("' + t.id + '");document.write(ed.iframeHTML);document.close();ed.initContentBody();})()';
            n = DOM.add(o.iframeContainer, "iframe", {
                id: t.id + "_ifr",
                src: u || 'javascript:""',
                frameBorder: "0",
                allowTransparency: "true",
                title: s.aria_label,
                style: {
                    width: "100%",
                    height: h,
                    display: "block"
                }
            });
            t.contentAreaContainer = o.iframeContainer;
            if (o.editorContainer) DOM.get(o.editorContainer).style.display = t.orgDisplay;
            e.style.visibility = t.orgVisibility;
            DOM.get(t.id).style.display = "none";
            DOM.setAttrib(t.id, "aria-hidden", true);
            if (!tinymce.relaxedDomain || !u) t.initContentBody();
            e = n = o = null;
        },
        initContentBody: function() {
            var self = this, settings = self.settings, targetElm = DOM.get(self.id), doc = self.getDoc(), html, body, contentCssText;
            if ((!isIE || !tinymce.relaxedDomain) && !settings.content_editable) {
                doc.open();
                doc.write(self.iframeHTML);
                doc.close();
                if (tinymce.relaxedDomain) doc.domain = tinymce.relaxedDomain;
            }
            if (settings.content_editable) {
                DOM.addClass(targetElm, "mceContentBody");
                self.contentDocument = doc = settings.content_document || document;
                self.contentWindow = settings.content_window || window;
                self.bodyElement = targetElm;
                settings.content_document = settings.content_window = null;
            }
            body = self.getBody();
            body.disabled = true;
            if (!settings.readonly) body.contentEditable = self.getParam("content_editable_state", true);
            body.disabled = false;
            self.schema = new tinymce.html.Schema(settings);
            self.dom = new tinymce.dom.DOMUtils(doc, {
                keep_values: true,
                url_converter: self.convertURL,
                url_converter_scope: self,
                hex_colors: settings.force_hex_style_colors,
                class_filter: settings.class_filter,
                update_styles: true,
                root_element: settings.content_editable ? self.id : null,
                schema: self.schema
            });
            self.parser = new tinymce.html.DomParser(settings, self.schema);
            self.parser.addAttributeFilter("src,href,style", function(nodes, name) {
                var i = nodes.length, node, dom = self.dom, value, internalName;
                while (i--) {
                    node = nodes[i];
                    value = node.attr(name);
                    internalName = "data-mce-" + name;
                    if (!node.attributes.map[internalName]) if ("style" === name) node.attr(internalName, dom.serializeStyle(dom.parseStyle(value), node.name)); else node.attr(internalName, self.convertURL(value, name, node.name));
                }
            });
            self.parser.addNodeFilter("script", function(nodes, name) {
                var i = nodes.length, node;
                while (i--) {
                    node = nodes[i];
                    node.attr("type", "mce-" + (node.attr("type") || "text/javascript"));
                }
            });
            self.parser.addNodeFilter("#cdata", function(nodes, name) {
                var i = nodes.length, node;
                while (i--) {
                    node = nodes[i];
                    node.type = 8;
                    node.name = "#comment";
                    node.value = "[CDATA[" + node.value + "]]";
                }
            });
            self.parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", function(nodes, name) {
                var i = nodes.length, node, nonEmptyElements = self.schema.getNonEmptyElements();
                while (i--) {
                    node = nodes[i];
                    if (node.isEmpty(nonEmptyElements)) node.empty().append(new tinymce.html.Node("br", 1)).shortEnded = true;
                }
            });
            self.serializer = new tinymce.dom.Serializer(settings, self.dom, self.schema);
            self.selection = new tinymce.dom.Selection(self.dom, self.getWin(), self.serializer, self);
            self.formatter = new tinymce.Formatter(self);
            self.undoManager = new tinymce.UndoManager(self);
            self.forceBlocks = new tinymce.ForceBlocks(self);
            self.enterKey = new tinymce.EnterKey(self);
            self.editorCommands = new tinymce.EditorCommands(self);
            self.onExecCommand.add(function(editor, command) {
                if (!/^(FontName|FontSize)$/.test(command)) self.nodeChanged();
            });
            self.serializer.onPreProcess.add(function(se, o) {
                return self.onPreProcess.dispatch(self, o, se);
            });
            self.serializer.onPostProcess.add(function(se, o) {
                return self.onPostProcess.dispatch(self, o, se);
            });
            self.onPreInit.dispatch(self);
            if (!settings.browser_spellcheck && !settings.gecko_spellcheck) doc.body.spellcheck = false;
            if (!settings.readonly) self.bindNativeEvents();
            self.controlManager.onPostRender.dispatch(self, self.controlManager);
            self.onPostRender.dispatch(self);
            self.quirks = tinymce.util.Quirks(self);
            if (settings.directionality) body.dir = settings.directionality;
            if (settings.nowrap) body.style.whiteSpace = "nowrap";
            if (settings.protect) self.onBeforeSetContent.add(function(ed, o) {
                each(settings.protect, function(pattern) {
                    o.content = o.content.replace(pattern, function(str) {
                        return "<!--mce:protected " + escape(str) + "-->";
                    });
                });
            });
            self.onSetContent.add(function() {
                self.addVisual(self.getBody());
            });
            if (settings.padd_empty_editor) self.onPostProcess.add(function(ed, o) {
                o.content = o.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\s|\u00a0|)<\/p>[\r\n]*|<br \/>[\r\n]*)$/, "");
            });
            self.load({
                initial: true,
                format: "html"
            });
            self.startContent = self.getContent({
                format: "raw"
            });
            self.initialized = true;
            self.onInit.dispatch(self);
            self.execCallback("setupcontent_callback", self.id, body, doc);
            self.execCallback("init_instance_callback", self);
            self.focus(true);
            self.nodeChanged({
                initial: true
            });
            if (self.contentStyles.length > 0) {
                contentCssText = "";
                each(self.contentStyles, function(style) {
                    contentCssText += style + "\r\n";
                });
                self.dom.addStyle(contentCssText);
            }
            each(self.contentCSS, function(url) {
                self.dom.loadCSS(url);
            });
            if (settings.auto_focus) setTimeout(function() {
                var ed = tinymce.get(settings.auto_focus);
                ed.selection.select(ed.getBody(), 1);
                ed.selection.collapse(1);
                ed.getBody().focus();
                ed.getWin().focus();
            }, 100);
            targetElm = doc = body = null;
        },
        focus: function(skip_focus) {
            var oed, self = this, selection = self.selection, contentEditable = self.settings.content_editable, ieRng, controlElm, doc = self.getDoc(), body;
            if (!skip_focus) {
                if (self.lastIERng) selection.setRng(self.lastIERng);
                ieRng = selection.getRng();
                if (ieRng.item) controlElm = ieRng.item(0);
                self._refreshContentEditable();
                if (!contentEditable) self.getWin().focus();
                if (tinymce.isGecko || contentEditable) {
                    body = self.getBody();
                    if (body.setActive) body.setActive(); else body.focus();
                    if (contentEditable) selection.normalize();
                }
                if (controlElm && controlElm.ownerDocument == doc) {
                    ieRng = doc.body.createControlRange();
                    ieRng.addElement(controlElm);
                    ieRng.select();
                }
            }
            if (tinymce.activeEditor != self) {
                if (null != (oed = tinymce.activeEditor)) oed.onDeactivate.dispatch(oed, self);
                self.onActivate.dispatch(self, oed);
            }
            tinymce._setActive(self);
        },
        execCallback: function(n) {
            var t = this, f = t.settings[n], s;
            if (!f) return;
            if (t.callbackLookup && (s = t.callbackLookup[n])) {
                f = s.func;
                s = s.scope;
            }
            if (is(f, "string")) {
                s = f.replace(/\.\w+$/, "");
                s = s ? tinymce.resolve(s) : 0;
                f = tinymce.resolve(f);
                t.callbackLookup = t.callbackLookup || {};
                t.callbackLookup[n] = {
                    func: f,
                    scope: s
                };
            }
            return f.apply(s || t, Array.prototype.slice.call(arguments, 1));
        },
        translate: function(s) {
            var c = this.settings.language || "en", i18n = tinymce.i18n;
            if (!s) return "";
            return i18n[c + "." + s] || s.replace(/\{\#([^\}]+)\}/g, function(a, b) {
                return i18n[c + "." + b] || "{#" + b + "}";
            });
        },
        getLang: function(n, dv) {
            return tinymce.i18n[(this.settings.language || "en") + "." + n] || (is(dv) ? dv : "{#" + n + "}");
        },
        getParam: function(n, dv, ty) {
            var tr = tinymce.trim, v = is(this.settings[n]) ? this.settings[n] : dv, o;
            if ("hash" === ty) {
                o = {};
                if (is(v, "string")) each(v.indexOf("=") > 0 ? v.split(/[;,](?![^=;,]*(?:[;,]|$))/) : v.split(","), function(v) {
                    v = v.split("=");
                    if (v.length > 1) o[tr(v[0])] = tr(v[1]); else o[tr(v[0])] = tr(v);
                }); else o = v;
                return o;
            }
            return v;
        },
        nodeChanged: function(o) {
            var self = this, selection = self.selection, node;
            if (self.initialized) {
                o = o || {};
                node = selection.getStart() || self.getBody();
                node = isIE && node.ownerDocument != self.getDoc() ? self.getBody() : node;
                o.parents = [];
                self.dom.getParent(node, function(node) {
                    if ("BODY" == node.nodeName) return true;
                    o.parents.push(node);
                });
                self.onNodeChange.dispatch(self, o ? o.controlManager || self.controlManager : self.controlManager, node, selection.isCollapsed(), o);
            }
        },
        addButton: function(name, settings) {
            var self = this;
            self.buttons = self.buttons || {};
            self.buttons[name] = settings;
        },
        addCommand: function(name, callback, scope) {
            this.execCommands[name] = {
                func: callback,
                scope: scope || this
            };
        },
        addQueryStateHandler: function(name, callback, scope) {
            this.queryStateCommands[name] = {
                func: callback,
                scope: scope || this
            };
        },
        addQueryValueHandler: function(name, callback, scope) {
            this.queryValueCommands[name] = {
                func: callback,
                scope: scope || this
            };
        },
        addShortcut: function(pa, desc, cmd_func, sc) {
            var t = this, c;
            if (false === t.settings.custom_shortcuts) return false;
            t.shortcuts = t.shortcuts || {};
            if (is(cmd_func, "string")) {
                c = cmd_func;
                cmd_func = function() {
                    t.execCommand(c, false, null);
                };
            }
            if (is(cmd_func, "object")) {
                c = cmd_func;
                cmd_func = function() {
                    t.execCommand(c[0], c[1], c[2]);
                };
            }
            each(explode(pa), function(pa) {
                var o = {
                    func: cmd_func,
                    scope: sc || this,
                    desc: t.translate(desc),
                    alt: false,
                    ctrl: false,
                    shift: false
                };
                each(explode(pa, "+"), function(v) {
                    switch (v) {
                      case "alt":
                      case "ctrl":
                      case "shift":
                        o[v] = true;
                        break;

                      default:
                        o.charCode = v.charCodeAt(0);
                        o.keyCode = v.toUpperCase().charCodeAt(0);
                    }
                });
                t.shortcuts[(o.ctrl ? "ctrl" : "") + "," + (o.alt ? "alt" : "") + "," + (o.shift ? "shift" : "") + "," + o.keyCode] = o;
            });
            return true;
        },
        execCommand: function(cmd, ui, val, a) {
            var t = this, s = 0, o, st;
            if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint|SelectAll)$/.test(cmd) && (!a || !a.skip_focus)) t.focus();
            a = extend({}, a);
            t.onBeforeExecCommand.dispatch(t, cmd, ui, val, a);
            if (a.terminate) return false;
            if (t.execCallback("execcommand_callback", t.id, t.selection.getNode(), cmd, ui, val)) {
                t.onExecCommand.dispatch(t, cmd, ui, val, a);
                return true;
            }
            if (o = t.execCommands[cmd]) {
                st = o.func.call(o.scope, ui, val);
                if (true !== st) {
                    t.onExecCommand.dispatch(t, cmd, ui, val, a);
                    return st;
                }
            }
            each(t.plugins, function(p) {
                if (p.execCommand && p.execCommand(cmd, ui, val)) {
                    t.onExecCommand.dispatch(t, cmd, ui, val, a);
                    s = 1;
                    return false;
                }
            });
            if (s) return true;
            if (t.theme && t.theme.execCommand && t.theme.execCommand(cmd, ui, val)) {
                t.onExecCommand.dispatch(t, cmd, ui, val, a);
                return true;
            }
            if (t.editorCommands.execCommand(cmd, ui, val)) {
                t.onExecCommand.dispatch(t, cmd, ui, val, a);
                return true;
            }
            t.getDoc().execCommand(cmd, ui, val);
            t.onExecCommand.dispatch(t, cmd, ui, val, a);
        },
        queryCommandState: function(cmd) {
            var t = this, o, s;
            if (t._isHidden()) return;
            if (o = t.queryStateCommands[cmd]) {
                s = o.func.call(o.scope);
                if (true !== s) return s;
            }
            o = t.editorCommands.queryCommandState(cmd);
            if (o !== -1) return o;
            try {
                return this.getDoc().queryCommandState(cmd);
            } catch (ex) {}
        },
        queryCommandValue: function(c) {
            var t = this, o, s;
            if (t._isHidden()) return;
            if (o = t.queryValueCommands[c]) {
                s = o.func.call(o.scope);
                if (true !== s) return s;
            }
            o = t.editorCommands.queryCommandValue(c);
            if (is(o)) return o;
            try {
                return this.getDoc().queryCommandValue(c);
            } catch (ex) {}
        },
        show: function() {
            var self = this;
            DOM.show(self.getContainer());
            DOM.hide(self.id);
            self.load();
        },
        hide: function() {
            var self = this, doc = self.getDoc();
            if (isIE && doc) doc.execCommand("SelectAll");
            self.save();
            DOM.hide(self.getContainer());
            DOM.setStyle(self.id, "display", self.orgDisplay);
        },
        isHidden: function() {
            return !DOM.isHidden(this.id);
        },
        setProgressState: function(b, ti, o) {
            this.onSetProgressState.dispatch(this, b, ti, o);
            return b;
        },
        load: function(o) {
            var t = this, e = t.getElement(), h;
            if (e) {
                o = o || {};
                o.load = true;
                h = t.setContent(is(e.value) ? e.value : e.innerHTML, o);
                o.element = e;
                if (!o.no_events) t.onLoadContent.dispatch(t, o);
                o.element = e = null;
                return h;
            }
        },
        save: function(o) {
            var t = this, e = t.getElement(), h, f;
            if (!e || !t.initialized) return;
            o = o || {};
            o.save = true;
            o.element = e;
            h = o.content = t.getContent(o);
            if (!o.no_events) t.onSaveContent.dispatch(t, o);
            h = o.content;
            if (!/TEXTAREA|INPUT/i.test(e.nodeName)) {
                e.innerHTML = h;
                if (f = DOM.getParent(t.id, "form")) each(f.elements, function(e) {
                    if (e.name == t.id) {
                        e.value = h;
                        return false;
                    }
                });
            } else e.value = h;
            o.element = e = null;
            return h;
        },
        setContent: function(content, args) {
            var self = this, rootNode, body = self.getBody(), forcedRootBlockName;
            args = args || {};
            args.format = args.format || "html";
            args.set = true;
            args.content = content;
            if (!args.no_events) self.onBeforeSetContent.dispatch(self, args);
            content = args.content;
            if (!tinymce.isIE && (0 === content.length || /^\s+$/.test(content))) {
                forcedRootBlockName = self.settings.forced_root_block;
                if (forcedRootBlockName) content = "<" + forcedRootBlockName + '><br data-mce-bogus="1"></' + forcedRootBlockName + ">"; else content = '<br data-mce-bogus="1">';
                body.innerHTML = content;
                self.selection.select(body, true);
                self.selection.collapse(true);
                return;
            }
            if ("raw" !== args.format) content = new tinymce.html.Serializer({}, self.schema).serialize(self.parser.parse(content));
            args.content = tinymce.trim(content);
            self.dom.setHTML(body, args.content);
            if (!args.no_events) self.onSetContent.dispatch(self, args);
            if (!self.settings.content_editable || document.activeElement === self.getBody()) self.selection.normalize();
            return args.content;
        },
        getContent: function(args) {
            var self = this, content, body = self.getBody();
            args = args || {};
            args.format = args.format || "html";
            args.get = true;
            args.getInner = true;
            if (!args.no_events) self.onBeforeGetContent.dispatch(self, args);
            if ("raw" == args.format) content = body.innerHTML; else if ("text" == args.format) content = body.innerText || body.textContent; else content = self.serializer.serialize(body, args);
            if ("text" != args.format) args.content = tinymce.trim(content); else args.content = content;
            if (!args.no_events) self.onGetContent.dispatch(self, args);
            return args.content;
        },
        isDirty: function() {
            var self = this;
            return tinymce.trim(self.startContent) != tinymce.trim(self.getContent({
                format: "raw",
                no_events: 1
            })) && !self.isNotDirty;
        },
        getContainer: function() {
            var self = this;
            if (!self.container) self.container = DOM.get(self.editorContainer || self.id + "_parent");
            return self.container;
        },
        getContentAreaContainer: function() {
            return this.contentAreaContainer;
        },
        getElement: function() {
            return DOM.get(this.settings.content_element || this.id);
        },
        getWin: function() {
            var self = this, elm;
            if (!self.contentWindow) {
                elm = DOM.get(self.id + "_ifr");
                if (elm) self.contentWindow = elm.contentWindow;
            }
            return self.contentWindow;
        },
        getDoc: function() {
            var self = this, win;
            if (!self.contentDocument) {
                win = self.getWin();
                if (win) self.contentDocument = win.document;
            }
            return self.contentDocument;
        },
        getBody: function() {
            return this.bodyElement || this.getDoc().body;
        },
        convertURL: function(url, name, elm) {
            var self = this, settings = self.settings;
            if (settings.urlconverter_callback) return self.execCallback("urlconverter_callback", url, elm, true, name);
            if (!settings.convert_urls || elm && "LINK" == elm.nodeName || 0 === url.indexOf("file:")) return url;
            if (settings.relative_urls) return self.documentBaseURI.toRelative(url);
            url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);
            return url;
        },
        addVisual: function(elm) {
            var self = this, settings = self.settings, dom = self.dom, cls;
            elm = elm || self.getBody();
            if (!is(self.hasVisual)) self.hasVisual = settings.visual;
            each(dom.select("table,a", elm), function(elm) {
                var value;
                switch (elm.nodeName) {
                  case "TABLE":
                    cls = settings.visual_table_class || "mceItemTable";
                    value = dom.getAttrib(elm, "border");
                    if (!value || "0" == value) if (self.hasVisual) dom.addClass(elm, cls); else dom.removeClass(elm, cls);
                    return;

                  case "A":
                    if (!dom.getAttrib(elm, "href", false)) {
                        value = dom.getAttrib(elm, "name") || elm.id;
                        cls = "mceItemAnchor";
                        if (value) if (self.hasVisual) dom.addClass(elm, cls); else dom.removeClass(elm, cls);
                    }
                    return;
                }
            });
            self.onVisualAid.dispatch(self, elm, self.hasVisual);
        },
        remove: function() {
            var self = this, elm = self.getContainer();
            if (!self.removed) {
                self.removed = 1;
                self.hide();
                if (!self.settings.content_editable) {
                    Event.unbind(self.getWin());
                    Event.unbind(self.getDoc());
                }
                Event.unbind(self.getBody());
                Event.clear(elm);
                self.execCallback("remove_instance_callback", self);
                self.onRemove.dispatch(self);
                self.onExecCommand.listeners = [];
                tinymce.remove(self);
                DOM.remove(elm);
            }
        },
        destroy: function(s) {
            var t = this;
            if (t.destroyed) return;
            if (isGecko) {
                Event.unbind(t.getDoc());
                Event.unbind(t.getWin());
                Event.unbind(t.getBody());
            }
            if (!s) {
                tinymce.removeUnload(t.destroy);
                tinyMCE.onBeforeUnload.remove(t._beforeUnload);
                if (t.theme && t.theme.destroy) t.theme.destroy();
                t.controlManager.destroy();
                t.selection.destroy();
                t.dom.destroy();
            }
            if (t.formElement) {
                t.formElement.submit = t.formElement._mceOldSubmit;
                t.formElement._mceOldSubmit = null;
            }
            t.contentAreaContainer = t.formElement = t.container = t.settings.content_element = t.bodyElement = t.contentDocument = t.contentWindow = null;
            if (t.selection) t.selection = t.selection.win = t.selection.dom = t.selection.dom.doc = null;
            t.destroyed = 1;
        },
        _refreshContentEditable: function() {
            var self = this, body, parent;
            if (self._isHidden()) {
                body = self.getBody();
                parent = body.parentNode;
                parent.removeChild(body);
                parent.appendChild(body);
                body.focus();
            }
        },
        _isHidden: function() {
            var s;
            if (!isGecko) return 0;
            s = this.selection.getSel();
            return !s || !s.rangeCount || 0 === s.rangeCount;
        }
    });
})(tinymce);

(function(tinymce) {
    var each = tinymce.each;
    tinymce.Editor.prototype.setupEvents = function() {
        var self = this, settings = self.settings;
        each([ "onPreInit", "onBeforeRenderUI", "onPostRender", "onLoad", "onInit", "onRemove", "onActivate", "onDeactivate", "onClick", "onEvent", "onMouseUp", "onMouseDown", "onDblClick", "onKeyDown", "onKeyUp", "onKeyPress", "onContextMenu", "onSubmit", "onReset", "onPaste", "onPreProcess", "onPostProcess", "onBeforeSetContent", "onBeforeGetContent", "onSetContent", "onGetContent", "onLoadContent", "onSaveContent", "onNodeChange", "onChange", "onBeforeExecCommand", "onExecCommand", "onUndo", "onRedo", "onVisualAid", "onSetProgressState", "onSetAttrib" ], function(name) {
            self[name] = new tinymce.util.Dispatcher(self);
        });
        if (settings.cleanup_callback) {
            self.onBeforeSetContent.add(function(ed, o) {
                o.content = ed.execCallback("cleanup_callback", "insert_to_editor", o.content, o);
            });
            self.onPreProcess.add(function(ed, o) {
                if (o.set) ed.execCallback("cleanup_callback", "insert_to_editor_dom", o.node, o);
                if (o.get) ed.execCallback("cleanup_callback", "get_from_editor_dom", o.node, o);
            });
            self.onPostProcess.add(function(ed, o) {
                if (o.set) o.content = ed.execCallback("cleanup_callback", "insert_to_editor", o.content, o);
                if (o.get) o.content = ed.execCallback("cleanup_callback", "get_from_editor", o.content, o);
            });
        }
        if (settings.save_callback) self.onGetContent.add(function(ed, o) {
            if (o.save) o.content = ed.execCallback("save_callback", ed.id, o.content, ed.getBody());
        });
        if (settings.handle_event_callback) self.onEvent.add(function(ed, e, o) {
            if (false === self.execCallback("handle_event_callback", e, ed, o)) {
                e.preventDefault();
                e.stopPropagation();
            }
        });
        if (settings.handle_node_change_callback) self.onNodeChange.add(function(ed, cm, n) {
            ed.execCallback("handle_node_change_callback", ed.id, n, -1, -1, true, ed.selection.isCollapsed());
        });
        if (settings.save_callback) self.onSaveContent.add(function(ed, o) {
            var h = ed.execCallback("save_callback", ed.id, o.content, ed.getBody());
            if (h) o.content = h;
        });
        if (settings.onchange_callback) self.onChange.add(function(ed, l) {
            ed.execCallback("onchange_callback", ed, l);
        });
    };
    tinymce.Editor.prototype.bindNativeEvents = function() {
        var self = this, i, settings = self.settings, dom = self.dom, nativeToDispatcherMap;
        nativeToDispatcherMap = {
            mouseup: "onMouseUp",
            mousedown: "onMouseDown",
            click: "onClick",
            keyup: "onKeyUp",
            keydown: "onKeyDown",
            keypress: "onKeyPress",
            submit: "onSubmit",
            reset: "onReset",
            contextmenu: "onContextMenu",
            dblclick: "onDblClick",
            paste: "onPaste"
        };
        function eventHandler(evt, args) {
            var type = evt.type;
            if (self.removed) return;
            if (false !== self.onEvent.dispatch(self, evt, args)) self[nativeToDispatcherMap[evt.fakeType || evt.type]].dispatch(self, evt, args);
        }
        function doOperaFocus(e) {
            self.focus(true);
        }
        function nodeChanged(ed, e) {
            if (65 != e.keyCode || !tinymce.VK.metaKeyPressed(e)) self.selection.normalize();
            self.nodeChanged();
        }
        each(nativeToDispatcherMap, function(dispatcherName, nativeName) {
            var root = settings.content_editable ? self.getBody() : self.getDoc();
            switch (nativeName) {
              case "contextmenu":
                dom.bind(root, nativeName, eventHandler);
                break;

              case "paste":
                dom.bind(self.getBody(), nativeName, eventHandler);
                break;

              case "submit":
              case "reset":
                dom.bind(self.getElement().form || tinymce.DOM.getParent(self.id, "form"), nativeName, eventHandler);
                break;

              default:
                dom.bind(root, nativeName, eventHandler);
            }
        });
        dom.bind(settings.content_editable ? self.getBody() : tinymce.isGecko ? self.getDoc() : self.getWin(), "focus", function(e) {
            self.focus(true);
        });
        if (settings.content_editable && tinymce.isOpera) {
            dom.bind(self.getBody(), "click", doOperaFocus);
            dom.bind(self.getBody(), "keydown", doOperaFocus);
        }
        self.onMouseUp.add(nodeChanged);
        self.onKeyUp.add(function(ed, e) {
            var keyCode = e.keyCode;
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || 13 == keyCode || 45 == keyCode || 46 == keyCode || 8 == keyCode || tinymce.isMac && (91 == keyCode || 93 == keyCode) || e.ctrlKey) nodeChanged(ed, e);
        });
        self.onReset.add(function() {
            self.setContent(self.startContent, {
                format: "raw"
            });
        });
        function handleShortcut(e, execute) {
            if (e.altKey || e.ctrlKey || e.metaKey) each(self.shortcuts, function(shortcut) {
                var ctrlState = tinymce.isMac ? e.metaKey : e.ctrlKey;
                if (shortcut.ctrl != ctrlState || shortcut.alt != e.altKey || shortcut.shift != e.shiftKey) return;
                if (e.keyCode == shortcut.keyCode || e.charCode && e.charCode == shortcut.charCode) {
                    e.preventDefault();
                    if (execute) shortcut.func.call(shortcut.scope);
                    return true;
                }
            });
        }
        self.onKeyUp.add(function(ed, e) {
            handleShortcut(e);
        });
        self.onKeyPress.add(function(ed, e) {
            handleShortcut(e);
        });
        self.onKeyDown.add(function(ed, e) {
            handleShortcut(e, true);
        });
        if (tinymce.isOpera) self.onClick.add(function(ed, e) {
            e.preventDefault();
        });
    };
})(tinymce);

(function(tinymce) {
    var each = tinymce.each, undef, TRUE = true, FALSE = false;
    tinymce.EditorCommands = function(editor) {
        var dom = editor.dom, selection = editor.selection, commands = {
            state: {},
            exec: {},
            value: {}
        }, settings = editor.settings, formatter = editor.formatter, bookmark;
        function execCommand(command, ui, value) {
            var func;
            command = command.toLowerCase();
            if (func = commands.exec[command]) {
                func(command, ui, value);
                return TRUE;
            }
            return FALSE;
        }
        function queryCommandState(command) {
            var func;
            command = command.toLowerCase();
            if (func = commands.state[command]) return func(command);
            return -1;
        }
        function queryCommandValue(command) {
            var func;
            command = command.toLowerCase();
            if (func = commands.value[command]) return func(command);
            return FALSE;
        }
        function addCommands(command_list, type) {
            type = type || "exec";
            each(command_list, function(callback, command) {
                each(command.toLowerCase().split(","), function(command) {
                    commands[type][command] = callback;
                });
            });
        }
        tinymce.extend(this, {
            execCommand: execCommand,
            queryCommandState: queryCommandState,
            queryCommandValue: queryCommandValue,
            addCommands: addCommands
        });
        function execNativeCommand(command, ui, value) {
            if (ui === undef) ui = FALSE;
            if (value === undef) value = null;
            return editor.getDoc().execCommand(command, ui, value);
        }
        function isFormatMatch(name) {
            return formatter.match(name);
        }
        function toggleFormat(name, value) {
            formatter.toggle(name, value ? {
                value: value
            } : undef);
        }
        function storeSelection(type) {
            bookmark = selection.getBookmark(type);
        }
        function restoreSelection() {
            selection.moveToBookmark(bookmark);
        }
        addCommands({
            "mceResetDesignMode,mceBeginUndoLevel": function() {},
            "mceEndUndoLevel,mceAddUndoLevel": function() {
                editor.undoManager.add();
            },
            "Cut,Copy,Paste": function(command) {
                var doc = editor.getDoc(), failed;
                try {
                    execNativeCommand(command);
                } catch (ex) {
                    failed = TRUE;
                }
                if (failed || !doc.queryCommandSupported(command)) if (tinymce.isGecko) editor.windowManager.confirm(editor.getLang("clipboard_msg"), function(state) {
                    if (state) open("http://www.mozilla.org/editor/midasdemo/securityprefs.html", "_blank");
                }); else editor.windowManager.alert(editor.getLang("clipboard_no_support"));
            },
            unlink: function(command) {
                if (selection.isCollapsed()) selection.select(selection.getNode());
                execNativeCommand(command);
                selection.collapse(FALSE);
            },
            "JustifyLeft,JustifyCenter,JustifyRight,JustifyFull": function(command) {
                var align = command.substring(7);
                each("left,center,right,full".split(","), function(name) {
                    if (align != name) formatter.remove("align" + name);
                });
                toggleFormat("align" + align);
                execCommand("mceRepaint");
            },
            "InsertUnorderedList,InsertOrderedList": function(command) {
                var listElm, listParent;
                execNativeCommand(command);
                listElm = dom.getParent(selection.getNode(), "ol,ul");
                if (listElm) {
                    listParent = listElm.parentNode;
                    if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
                        storeSelection();
                        dom.split(listParent, listElm);
                        restoreSelection();
                    }
                }
            },
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
                toggleFormat(command);
            },
            "ForeColor,HiliteColor,FontName": function(command, ui, value) {
                toggleFormat(command, value);
            },
            FontSize: function(command, ui, value) {
                var fontClasses, fontSizes;
                if (value >= 1 && value <= 7) {
                    fontSizes = tinymce.explode(settings.font_size_style_values);
                    fontClasses = tinymce.explode(settings.font_size_classes);
                    if (fontClasses) value = fontClasses[value - 1] || value; else value = fontSizes[value - 1] || value;
                }
                toggleFormat(command, value);
            },
            RemoveFormat: function(command) {
                formatter.remove(command);
            },
            mceBlockQuote: function(command) {
                toggleFormat("blockquote");
            },
            FormatBlock: function(command, ui, value) {
                return toggleFormat(value || "p");
            },
            mceCleanup: function() {
                var bookmark = selection.getBookmark();
                editor.setContent(editor.getContent({
                    cleanup: TRUE
                }), {
                    cleanup: TRUE
                });
                selection.moveToBookmark(bookmark);
            },
            mceRemoveNode: function(command, ui, value) {
                var node = value || selection.getNode();
                if (node != editor.getBody()) {
                    storeSelection();
                    editor.dom.remove(node, TRUE);
                    restoreSelection();
                }
            },
            mceSelectNodeDepth: function(command, ui, value) {
                var counter = 0;
                dom.getParent(selection.getNode(), function(node) {
                    if (1 == node.nodeType && counter++ == value) {
                        selection.select(node);
                        return FALSE;
                    }
                }, editor.getBody());
            },
            mceSelectNode: function(command, ui, value) {
                selection.select(value);
            },
            mceInsertContent: function(command, ui, value) {
                var parser, serializer, parentNode, rootNode, fragment, args, marker, nodeRect, viewPortRect, rng, node, node2, bookmarkHtml, viewportBodyElement;
                parser = editor.parser;
                serializer = new tinymce.html.Serializer({}, editor.schema);
                bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">﻿</span>';
                args = {
                    content: value,
                    format: "html"
                };
                selection.onBeforeSetContent.dispatch(selection, args);
                value = args.content;
                if (value.indexOf("{$caret}") == -1) value += "{$caret}";
                value = value.replace(/\{\$caret\}/, bookmarkHtml);
                if (!selection.isCollapsed()) editor.getDoc().execCommand("Delete", false, null);
                parentNode = selection.getNode();
                args = {
                    context: parentNode.nodeName.toLowerCase()
                };
                fragment = parser.parse(value, args);
                node = fragment.lastChild;
                if ("mce_marker" == node.attr("id")) {
                    marker = node;
                    for (node = node.prev; node; node = node.walk(true)) if (3 == node.type || !dom.isBlock(node.name)) {
                        node.parent.insert(marker, node, "br" === node.name);
                        break;
                    }
                }
                if (!args.invalid) {
                    value = serializer.serialize(fragment);
                    node = parentNode.firstChild;
                    node2 = parentNode.lastChild;
                    if (!node || node === node2 && "BR" === node.nodeName) dom.setHTML(parentNode, value); else selection.setContent(value);
                } else {
                    selection.setContent(bookmarkHtml);
                    parentNode = selection.getNode();
                    rootNode = editor.getBody();
                    if (9 == parentNode.nodeType) parentNode = node = rootNode; else node = parentNode;
                    while (node !== rootNode) {
                        parentNode = node;
                        node = node.parentNode;
                    }
                    value = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
                    value = serializer.serialize(parser.parse(value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
                        return serializer.serialize(fragment);
                    })));
                    if (parentNode == rootNode) dom.setHTML(rootNode, value); else dom.setOuterHTML(parentNode, value);
                }
                marker = dom.get("mce_marker");
                nodeRect = dom.getRect(marker);
                viewPortRect = dom.getViewPort(editor.getWin());
                if (nodeRect.y + nodeRect.h > viewPortRect.y + viewPortRect.h || nodeRect.y < viewPortRect.y || nodeRect.x > viewPortRect.x + viewPortRect.w || nodeRect.x < viewPortRect.x) {
                    viewportBodyElement = tinymce.isIE ? editor.getDoc().documentElement : editor.getBody();
                    viewportBodyElement.scrollLeft = nodeRect.x;
                    viewportBodyElement.scrollTop = nodeRect.y - viewPortRect.h + 25;
                }
                rng = dom.createRng();
                node = marker.previousSibling;
                if (node && 3 == node.nodeType) rng.setStart(node, node.nodeValue.length); else {
                    rng.setStartBefore(marker);
                    rng.setEndBefore(marker);
                }
                dom.remove(marker);
                selection.setRng(rng);
                selection.onSetContent.dispatch(selection, args);
                editor.addVisual();
            },
            mceInsertRawHTML: function(command, ui, value) {
                selection.setContent("tiny_mce_marker");
                editor.setContent(editor.getContent().replace(/tiny_mce_marker/g, function() {
                    return value;
                }));
            },
            mceToggleFormat: function(command, ui, value) {
                toggleFormat(value);
            },
            mceSetContent: function(command, ui, value) {
                editor.setContent(value);
            },
            "Indent,Outdent": function(command) {
                var intentValue, indentUnit, value;
                intentValue = settings.indentation;
                indentUnit = /[a-z%]+$/i.exec(intentValue);
                intentValue = parseInt(intentValue);
                if (!queryCommandState("InsertUnorderedList") && !queryCommandState("InsertOrderedList")) {
                    if (!settings.forced_root_block && !dom.getParent(selection.getNode(), dom.isBlock)) formatter.apply("div");
                    each(selection.getSelectedBlocks(), function(element) {
                        if ("outdent" == command) {
                            value = Math.max(0, parseInt(element.style.paddingLeft || 0) - intentValue);
                            dom.setStyle(element, "paddingLeft", value ? value + indentUnit : "");
                        } else dom.setStyle(element, "paddingLeft", parseInt(element.style.paddingLeft || 0) + intentValue + indentUnit);
                    });
                } else execNativeCommand(command);
            },
            mceRepaint: function() {
                var bookmark;
                if (tinymce.isGecko) try {
                    storeSelection(TRUE);
                    if (selection.getSel()) selection.getSel().selectAllChildren(editor.getBody());
                    selection.collapse(TRUE);
                    restoreSelection();
                } catch (ex) {}
            },
            mceToggleFormat: function(command, ui, value) {
                formatter.toggle(value);
            },
            InsertHorizontalRule: function() {
                editor.execCommand("mceInsertContent", false, "<hr />");
            },
            mceToggleVisualAid: function() {
                editor.hasVisual = !editor.hasVisual;
                editor.addVisual();
            },
            mceReplaceContent: function(command, ui, value) {
                editor.execCommand("mceInsertContent", false, value.replace(/\{\$selection\}/g, selection.getContent({
                    format: "text"
                })));
            },
            mceInsertLink: function(command, ui, value) {
                var anchor;
                if ("string" == typeof value) value = {
                    href: value
                };
                anchor = dom.getParent(selection.getNode(), "a");
                value.href = value.href.replace(" ", "%20");
                if (!anchor || !value.href) formatter.remove("link");
                if (value.href) formatter.apply("link", value, anchor);
            },
            selectAll: function() {
                var root = dom.getRoot(), rng = dom.createRng();
                if (selection.getRng().setStart) {
                    rng.setStart(root, 0);
                    rng.setEnd(root, root.childNodes.length);
                    selection.setRng(rng);
                } else execNativeCommand("SelectAll");
            }
        });
        addCommands({
            "JustifyLeft,JustifyCenter,JustifyRight,JustifyFull": function(command) {
                var name = "align" + command.substring(7);
                var nodes = selection.isCollapsed() ? [ dom.getParent(selection.getNode(), dom.isBlock) ] : selection.getSelectedBlocks();
                var matches = tinymce.map(nodes, function(node) {
                    return !!formatter.matchNode(node, name);
                });
                return tinymce.inArray(matches, TRUE) !== -1;
            },
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
                return isFormatMatch(command);
            },
            mceBlockQuote: function() {
                return isFormatMatch("blockquote");
            },
            Outdent: function() {
                var node;
                if (settings.inline_styles) {
                    if ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0) return TRUE;
                    if ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft) > 0) return TRUE;
                }
                return queryCommandState("InsertUnorderedList") || queryCommandState("InsertOrderedList") || !settings.inline_styles && !!dom.getParent(selection.getNode(), "BLOCKQUOTE");
            },
            "InsertUnorderedList,InsertOrderedList": function(command) {
                var list = dom.getParent(selection.getNode(), "ul,ol");
                return list && ("insertunorderedlist" === command && "UL" === list.tagName || "insertorderedlist" === command && "OL" === list.tagName);
            }
        }, "state");
        addCommands({
            "FontSize,FontName": function(command) {
                var value = 0, parent;
                if (parent = dom.getParent(selection.getNode(), "span")) if ("fontsize" == command) value = parent.style.fontSize; else value = parent.style.fontFamily.replace(/, /g, ",").replace(/[\'\"]/g, "").toLowerCase();
                return value;
            }
        }, "value");
        addCommands({
            Undo: function() {
                editor.undoManager.undo();
            },
            Redo: function() {
                editor.undoManager.redo();
            }
        });
    };
})(tinymce);

(function(tinymce) {
    var Dispatcher = tinymce.util.Dispatcher;
    tinymce.UndoManager = function(editor) {
        var self, index = 0, data = [], beforeBookmark, onAdd, onUndo, onRedo;
        function getContent() {
            return tinymce.trim(editor.getContent({
                format: "raw",
                no_events: 1
            }).replace(/<span[^>]+data-mce-bogus[^>]+>[\u200B\uFEFF]+<\/span>/g, ""));
        }
        function addNonTypingUndoLevel() {
            self.typing = false;
            self.add();
        }
        onBeforeAdd = new Dispatcher(self);
        onAdd = new Dispatcher(self);
        onUndo = new Dispatcher(self);
        onRedo = new Dispatcher(self);
        onAdd.add(function(undoman, level) {
            if (undoman.hasUndo()) return editor.onChange.dispatch(editor, level, undoman);
        });
        onUndo.add(function(undoman, level) {
            return editor.onUndo.dispatch(editor, level, undoman);
        });
        onRedo.add(function(undoman, level) {
            return editor.onRedo.dispatch(editor, level, undoman);
        });
        editor.onInit.add(function() {
            self.add();
        });
        editor.onBeforeExecCommand.add(function(ed, cmd, ui, val, args) {
            if ("Undo" != cmd && "Redo" != cmd && "mceRepaint" != cmd && (!args || !args.skip_undo)) self.beforeChange();
        });
        editor.onExecCommand.add(function(ed, cmd, ui, val, args) {
            if ("Undo" != cmd && "Redo" != cmd && "mceRepaint" != cmd && (!args || !args.skip_undo)) self.add();
        });
        editor.onSaveContent.add(addNonTypingUndoLevel);
        editor.dom.bind(editor.dom.getRoot(), "dragend", addNonTypingUndoLevel);
        editor.dom.bind(editor.getDoc(), tinymce.isGecko ? "blur" : "focusout", function(e) {
            if (!editor.removed && self.typing) addNonTypingUndoLevel();
        });
        editor.onKeyUp.add(function(editor, e) {
            var keyCode = e.keyCode;
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || 45 == keyCode || 13 == keyCode || e.ctrlKey) addNonTypingUndoLevel();
        });
        editor.onKeyDown.add(function(editor, e) {
            var keyCode = e.keyCode;
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || 45 == keyCode) {
                if (self.typing) addNonTypingUndoLevel();
                return;
            }
            if ((keyCode < 16 || keyCode > 20) && 224 != keyCode && 91 != keyCode && !self.typing) {
                self.beforeChange();
                self.typing = true;
                self.add();
            }
        });
        editor.onMouseDown.add(function(editor, e) {
            if (self.typing) addNonTypingUndoLevel();
        });
        editor.addShortcut("ctrl+z", "undo_desc", "Undo");
        editor.addShortcut("ctrl+y", "redo_desc", "Redo");
        self = {
            data: data,
            typing: false,
            onBeforeAdd: onBeforeAdd,
            onAdd: onAdd,
            onUndo: onUndo,
            onRedo: onRedo,
            beforeChange: function() {
                beforeBookmark = editor.selection.getBookmark(2, true);
            },
            add: function(level) {
                var i, settings = editor.settings, lastLevel;
                level = level || {};
                level.content = getContent();
                self.onBeforeAdd.dispatch(self, level);
                lastLevel = data[index];
                if (lastLevel && lastLevel.content == level.content) return null;
                if (data[index]) data[index].beforeBookmark = beforeBookmark;
                if (settings.custom_undo_redo_levels) if (data.length > settings.custom_undo_redo_levels) {
                    for (i = 0; i < data.length - 1; i++) data[i] = data[i + 1];
                    data.length--;
                    index = data.length;
                }
                level.bookmark = editor.selection.getBookmark(2, true);
                if (index < data.length - 1) data.length = index + 1;
                data.push(level);
                index = data.length - 1;
                self.onAdd.dispatch(self, level);
                editor.isNotDirty = 0;
                return level;
            },
            undo: function() {
                var level, i;
                if (self.typing) {
                    self.add();
                    self.typing = false;
                }
                if (index > 0) {
                    level = data[--index];
                    editor.setContent(level.content, {
                        format: "raw"
                    });
                    editor.selection.moveToBookmark(level.beforeBookmark);
                    self.onUndo.dispatch(self, level);
                }
                return level;
            },
            redo: function() {
                var level;
                if (index < data.length - 1) {
                    level = data[++index];
                    editor.setContent(level.content, {
                        format: "raw"
                    });
                    editor.selection.moveToBookmark(level.bookmark);
                    self.onRedo.dispatch(self, level);
                }
                return level;
            },
            clear: function() {
                data = [];
                index = 0;
                self.typing = false;
            },
            hasUndo: function() {
                return index > 0 || this.typing;
            },
            hasRedo: function() {
                return index < data.length - 1 && !this.typing;
            }
        };
        return self;
    };
})(tinymce);

tinymce.ForceBlocks = function(editor) {
    var settings = editor.settings, dom = editor.dom, selection = editor.selection, blockElements = editor.schema.getBlockElements();
    function addRootBlocks() {
        var node = selection.getStart(), rootNode = editor.getBody(), rng, startContainer, startOffset, endContainer, endOffset, rootBlockNode, tempNode, offset = -16777215, wrapped, isInEditorDocument;
        if (!node || 1 !== node.nodeType || !settings.forced_root_block) return;
        while (node && node != rootNode) {
            if (blockElements[node.nodeName]) return;
            node = node.parentNode;
        }
        rng = selection.getRng();
        if (rng.setStart) {
            startContainer = rng.startContainer;
            startOffset = rng.startOffset;
            endContainer = rng.endContainer;
            endOffset = rng.endOffset;
        } else {
            if (rng.item) {
                node = rng.item(0);
                rng = editor.getDoc().body.createTextRange();
                rng.moveToElementText(node);
            }
            isInEditorDocument = rng.parentElement().ownerDocument === editor.getDoc();
            tmpRng = rng.duplicate();
            tmpRng.collapse(true);
            startOffset = tmpRng.move("character", offset) * -1;
            if (!tmpRng.collapsed) {
                tmpRng = rng.duplicate();
                tmpRng.collapse(false);
                endOffset = tmpRng.move("character", offset) * -1 - startOffset;
            }
        }
        node = rootNode.firstChild;
        while (node) if (3 === node.nodeType || 1 == node.nodeType && !blockElements[node.nodeName]) {
            if (3 === node.nodeType && 0 == node.nodeValue.length) {
                tempNode = node;
                node = node.nextSibling;
                dom.remove(tempNode);
                continue;
            }
            if (!rootBlockNode) {
                rootBlockNode = dom.create(settings.forced_root_block);
                node.parentNode.insertBefore(rootBlockNode, node);
                wrapped = true;
            }
            tempNode = node;
            node = node.nextSibling;
            rootBlockNode.appendChild(tempNode);
        } else {
            rootBlockNode = null;
            node = node.nextSibling;
        }
        if (wrapped) {
            if (rng.setStart) {
                rng.setStart(startContainer, startOffset);
                rng.setEnd(endContainer, endOffset);
                selection.setRng(rng);
            } else if (isInEditorDocument) try {
                rng = editor.getDoc().body.createTextRange();
                rng.moveToElementText(rootNode);
                rng.collapse(true);
                rng.moveStart("character", startOffset);
                if (endOffset > 0) rng.moveEnd("character", endOffset);
                rng.select();
            } catch (ex) {}
            editor.nodeChanged();
        }
    }
    if (settings.forced_root_block) {
        editor.onKeyUp.add(addRootBlocks);
        editor.onNodeChange.add(addRootBlocks);
    }
};

(function(tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event, each = tinymce.each, extend = tinymce.extend;
    tinymce.create("tinymce.ControlManager", {
        ControlManager: function(ed, s) {
            var t = this, i;
            s = s || {};
            t.editor = ed;
            t.controls = {};
            t.onAdd = new tinymce.util.Dispatcher(t);
            t.onPostRender = new tinymce.util.Dispatcher(t);
            t.prefix = s.prefix || ed.id + "_";
            t._cls = {};
            t.onPostRender.add(function() {
                each(t.controls, function(c) {
                    c.postRender();
                });
            });
        },
        get: function(id) {
            return this.controls[this.prefix + id] || this.controls[id];
        },
        setActive: function(id, s) {
            var c = null;
            if (c = this.get(id)) c.setActive(s);
            return c;
        },
        setDisabled: function(id, s) {
            var c = null;
            if (c = this.get(id)) c.setDisabled(s);
            return c;
        },
        add: function(c) {
            var t = this;
            if (c) {
                t.controls[c.id] = c;
                t.onAdd.dispatch(c, t);
            }
            return c;
        },
        createControl: function(name) {
            var ctrl, i, l, self = this, editor = self.editor, factories, ctrlName;
            if (!self.controlFactories) {
                self.controlFactories = [];
                each(editor.plugins, function(plugin) {
                    if (plugin.createControl) self.controlFactories.push(plugin);
                });
            }
            factories = self.controlFactories;
            for (i = 0, l = factories.length; i < l; i++) {
                ctrl = factories[i].createControl(name, self);
                if (ctrl) return self.add(ctrl);
            }
            if ("|" === name || "separator" === name) return self.createSeparator();
            if (editor.buttons && (ctrl = editor.buttons[name])) return self.createButton(name, ctrl);
            return self.add(ctrl);
        },
        createDropMenu: function(id, s, cc) {
            var t = this, ed = t.editor, c, bm, v, cls;
            s = extend({
                "class": "mceDropDown",
                constrain: ed.settings.constrain_menus
            }, s);
            s["class"] = s["class"] + " " + ed.getParam("skin") + "Skin";
            if (v = ed.getParam("skin_variant")) s["class"] += " " + ed.getParam("skin") + "Skin" + v.substring(0, 1).toUpperCase() + v.substring(1);
            s["class"] += "rtl" == ed.settings.directionality ? " mceRtl" : "";
            id = t.prefix + id;
            cls = cc || t._cls.dropmenu || tinymce.ui.DropMenu;
            c = t.controls[id] = new cls(id, s);
            c.onAddItem.add(function(c, o) {
                var s = o.settings;
                s.title = ed.getLang(s.title, s.title);
                if (!s.onclick) s.onclick = function(v) {
                    if (s.cmd) ed.execCommand(s.cmd, s.ui || false, s.value);
                };
            });
            ed.onRemove.add(function() {
                c.destroy();
            });
            if (tinymce.isIE) {
                c.onShowMenu.add(function() {
                    ed.focus();
                    bm = ed.selection.getBookmark(1);
                });
                c.onHideMenu.add(function() {
                    if (bm) {
                        ed.selection.moveToBookmark(bm);
                        bm = 0;
                    }
                });
            }
            return t.add(c);
        },
        createListBox: function(id, s, cc) {
            var t = this, ed = t.editor, cmd, c, cls;
            if (t.get(id)) return null;
            s.title = ed.translate(s.title);
            s.scope = s.scope || ed;
            if (!s.onselect) s.onselect = function(v) {
                ed.execCommand(s.cmd, s.ui || false, v || s.value);
            };
            s = extend({
                title: s.title,
                "class": "mce_" + id,
                scope: s.scope,
                control_manager: t
            }, s);
            id = t.prefix + id;
            function useNativeListForAccessibility(ed) {
                return ed.settings.use_accessible_selects && !tinymce.isGecko;
            }
            if (ed.settings.use_native_selects || useNativeListForAccessibility(ed)) c = new tinymce.ui.NativeListBox(id, s); else {
                cls = cc || t._cls.listbox || tinymce.ui.ListBox;
                c = new cls(id, s, ed);
            }
            t.controls[id] = c;
            if (tinymce.isWebKit) c.onPostRender.add(function(c, n) {
                Event.add(n, "mousedown", function() {
                    ed.bookmark = ed.selection.getBookmark(1);
                });
                Event.add(n, "focus", function() {
                    ed.selection.moveToBookmark(ed.bookmark);
                    ed.bookmark = null;
                });
            });
            if (c.hideMenu) ed.onMouseDown.add(c.hideMenu, c);
            return t.add(c);
        },
        createButton: function(id, s, cc) {
            var t = this, ed = t.editor, o, c, cls;
            if (t.get(id)) return null;
            s.title = ed.translate(s.title);
            s.label = ed.translate(s.label);
            s.scope = s.scope || ed;
            if (!s.onclick && !s.menu_button) s.onclick = function() {
                ed.execCommand(s.cmd, s.ui || false, s.value);
            };
            s = extend({
                title: s.title,
                "class": "mce_" + id,
                unavailable_prefix: ed.getLang("unavailable", ""),
                scope: s.scope,
                control_manager: t
            }, s);
            id = t.prefix + id;
            if (s.menu_button) {
                cls = cc || t._cls.menubutton || tinymce.ui.MenuButton;
                c = new cls(id, s, ed);
                ed.onMouseDown.add(c.hideMenu, c);
            } else {
                cls = t._cls.button || tinymce.ui.Button;
                c = new cls(id, s, ed);
            }
            return t.add(c);
        },
        createMenuButton: function(id, s, cc) {
            s = s || {};
            s.menu_button = 1;
            return this.createButton(id, s, cc);
        },
        createSplitButton: function(id, s, cc) {
            var t = this, ed = t.editor, cmd, c, cls;
            if (t.get(id)) return null;
            s.title = ed.translate(s.title);
            s.scope = s.scope || ed;
            if (!s.onclick) s.onclick = function(v) {
                ed.execCommand(s.cmd, s.ui || false, v || s.value);
            };
            if (!s.onselect) s.onselect = function(v) {
                ed.execCommand(s.cmd, s.ui || false, v || s.value);
            };
            s = extend({
                title: s.title,
                "class": "mce_" + id,
                scope: s.scope,
                control_manager: t
            }, s);
            id = t.prefix + id;
            cls = cc || t._cls.splitbutton || tinymce.ui.SplitButton;
            c = t.add(new cls(id, s, ed));
            ed.onMouseDown.add(c.hideMenu, c);
            return c;
        },
        createColorSplitButton: function(id, s, cc) {
            var t = this, ed = t.editor, cmd, c, cls, bm;
            if (t.get(id)) return null;
            s.title = ed.translate(s.title);
            s.scope = s.scope || ed;
            if (!s.onclick) s.onclick = function(v) {
                if (tinymce.isIE) bm = ed.selection.getBookmark(1);
                ed.execCommand(s.cmd, s.ui || false, v || s.value);
            };
            if (!s.onselect) s.onselect = function(v) {
                ed.execCommand(s.cmd, s.ui || false, v || s.value);
            };
            s = extend({
                title: s.title,
                "class": "mce_" + id,
                menu_class: ed.getParam("skin") + "Skin",
                scope: s.scope,
                more_colors_title: ed.getLang("more_colors")
            }, s);
            id = t.prefix + id;
            cls = cc || t._cls.colorsplitbutton || tinymce.ui.ColorSplitButton;
            c = new cls(id, s, ed);
            ed.onMouseDown.add(c.hideMenu, c);
            ed.onRemove.add(function() {
                c.destroy();
            });
            if (tinymce.isIE) {
                c.onShowMenu.add(function() {
                    ed.focus();
                    bm = ed.selection.getBookmark(1);
                });
                c.onHideMenu.add(function() {
                    if (bm) {
                        ed.selection.moveToBookmark(bm);
                        bm = 0;
                    }
                });
            }
            return t.add(c);
        },
        createToolbar: function(id, s, cc) {
            var c, t = this, cls;
            id = t.prefix + id;
            cls = cc || t._cls.toolbar || tinymce.ui.Toolbar;
            c = new cls(id, s, t.editor);
            if (t.get(id)) return null;
            return t.add(c);
        },
        createToolbarGroup: function(id, s, cc) {
            var c, t = this, cls;
            id = t.prefix + id;
            cls = cc || this._cls.toolbarGroup || tinymce.ui.ToolbarGroup;
            c = new cls(id, s, t.editor);
            if (t.get(id)) return null;
            return t.add(c);
        },
        createSeparator: function(cc) {
            var cls = cc || this._cls.separator || tinymce.ui.Separator;
            return new cls();
        },
        setControlType: function(n, c) {
            return this._cls[n.toLowerCase()] = c;
        },
        destroy: function() {
            each(this.controls, function(c) {
                c.destroy();
            });
            this.controls = null;
        }
    });
})(tinymce);

(function(tinymce) {
    var Dispatcher = tinymce.util.Dispatcher, each = tinymce.each, isIE = tinymce.isIE, isOpera = tinymce.isOpera;
    tinymce.create("tinymce.WindowManager", {
        WindowManager: function(ed) {
            var t = this;
            t.editor = ed;
            t.onOpen = new Dispatcher(t);
            t.onClose = new Dispatcher(t);
            t.params = {};
            t.features = {};
        },
        open: function(s, p) {
            var t = this, f = "", x, y, mo = "modal" == t.editor.settings.dialog_type, w, sw, sh, vp = tinymce.DOM.getViewPort(), u;
            s = s || {};
            p = p || {};
            sw = isOpera ? vp.w : screen.width;
            sh = isOpera ? vp.h : screen.height;
            s.name = s.name || "mc_" + new Date().getTime();
            s.width = parseInt(s.width || 320);
            s.height = parseInt(s.height || 240);
            s.resizable = true;
            s.left = s.left || parseInt(sw / 2) - s.width / 2;
            s.top = s.top || parseInt(sh / 2) - s.height / 2;
            p.inline = false;
            p.mce_width = s.width;
            p.mce_height = s.height;
            p.mce_auto_focus = s.auto_focus;
            if (mo) if (isIE) {
                s.center = true;
                s.help = false;
                s.dialogWidth = s.width + "px";
                s.dialogHeight = s.height + "px";
                s.scroll = s.scrollbars || false;
            }
            each(s, function(v, k) {
                if (tinymce.is(v, "boolean")) v = v ? "yes" : "no";
                if (!/^(name|url)$/.test(k)) if (isIE && mo) f += (f ? ";" : "") + k + ":" + v; else f += (f ? "," : "") + k + "=" + v;
            });
            t.features = s;
            t.params = p;
            t.onOpen.dispatch(t, s, p);
            u = s.url || s.file;
            u = tinymce._addVer(u);
            try {
                if (isIE && mo) {
                    w = 1;
                    window.showModalDialog(u, window, f);
                } else w = window.open(u, s.name, f);
            } catch (ex) {}
            if (!w) alert(t.editor.getLang("popup_blocked"));
        },
        close: function(w) {
            w.close();
            this.onClose.dispatch(this);
        },
        createInstance: function(cl, a, b, c, d, e) {
            var f = tinymce.resolve(cl);
            return new f(a, b, c, d, e);
        },
        confirm: function(t, cb, s, w) {
            w = w || window;
            cb.call(s || this, w.confirm(this._decode(this.editor.getLang(t, t))));
        },
        alert: function(tx, cb, s, w) {
            var t = this;
            w = w || window;
            w.alert(t._decode(t.editor.getLang(tx, tx)));
            if (cb) cb.call(s || t);
        },
        resizeBy: function(dw, dh, win) {
            win.resizeBy(dw, dh);
        },
        _decode: function(s) {
            return tinymce.DOM.decode(s).replace(/\\n/g, "\n");
        }
    });
})(tinymce);

(function(tinymce) {
    tinymce.Formatter = function(ed) {
        var formats = {}, each = tinymce.each, dom = ed.dom, selection = ed.selection, TreeWalker = tinymce.dom.TreeWalker, rangeUtils = new tinymce.dom.RangeUtils(dom), isValid = ed.schema.isValidChild, isBlock = dom.isBlock, forcedRootBlock = ed.settings.forced_root_block, nodeIndex = dom.nodeIndex, INVISIBLE_CHAR = "﻿", MCE_ATTR_RE = /^(src|href|style)$/, FALSE = false, TRUE = true, formatChangeData, undef, getContentEditable = dom.getContentEditable;
        function isArray(obj) {
            return obj instanceof Array;
        }
        function getParents(node, selector) {
            return dom.getParents(node, selector, dom.getRoot());
        }
        function isCaretNode(node) {
            return 1 === node.nodeType && "_mce_caret" === node.id;
        }
        function defaultFormats() {
            register({
                alignleft: [ {
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li",
                    styles: {
                        textAlign: "left"
                    },
                    defaultBlock: "div"
                }, {
                    selector: "img,table",
                    collapsed: false,
                    styles: {
                        "float": "left"
                    }
                } ],
                aligncenter: [ {
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li",
                    styles: {
                        textAlign: "center"
                    },
                    defaultBlock: "div"
                }, {
                    selector: "img",
                    collapsed: false,
                    styles: {
                        display: "block",
                        marginLeft: "auto",
                        marginRight: "auto"
                    }
                }, {
                    selector: "table",
                    collapsed: false,
                    styles: {
                        marginLeft: "auto",
                        marginRight: "auto"
                    }
                } ],
                alignright: [ {
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li",
                    styles: {
                        textAlign: "right"
                    },
                    defaultBlock: "div"
                }, {
                    selector: "img,table",
                    collapsed: false,
                    styles: {
                        "float": "right"
                    }
                } ],
                alignfull: [ {
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li",
                    styles: {
                        textAlign: "justify"
                    },
                    defaultBlock: "div"
                } ],
                bold: [ {
                    inline: "strong",
                    remove: "all"
                }, {
                    inline: "span",
                    styles: {
                        fontWeight: "bold"
                    }
                }, {
                    inline: "b",
                    remove: "all"
                } ],
                italic: [ {
                    inline: "em",
                    remove: "all"
                }, {
                    inline: "span",
                    styles: {
                        fontStyle: "italic"
                    }
                }, {
                    inline: "i",
                    remove: "all"
                } ],
                underline: [ {
                    inline: "span",
                    styles: {
                        textDecoration: "underline"
                    },
                    exact: true
                }, {
                    inline: "u",
                    remove: "all"
                } ],
                strikethrough: [ {
                    inline: "span",
                    styles: {
                        textDecoration: "line-through"
                    },
                    exact: true
                }, {
                    inline: "strike",
                    remove: "all"
                } ],
                forecolor: {
                    inline: "span",
                    styles: {
                        color: "%value"
                    },
                    wrap_links: false
                },
                hilitecolor: {
                    inline: "span",
                    styles: {
                        backgroundColor: "%value"
                    },
                    wrap_links: false
                },
                fontname: {
                    inline: "span",
                    styles: {
                        fontFamily: "%value"
                    }
                },
                fontsize: {
                    inline: "span",
                    styles: {
                        fontSize: "%value"
                    }
                },
                fontsize_class: {
                    inline: "span",
                    attributes: {
                        "class": "%value"
                    }
                },
                blockquote: {
                    block: "blockquote",
                    wrapper: 1,
                    remove: "all"
                },
                subscript: {
                    inline: "sub"
                },
                superscript: {
                    inline: "sup"
                },
                link: {
                    inline: "a",
                    selector: "a",
                    remove: "all",
                    split: true,
                    deep: true,
                    onmatch: function(node) {
                        return true;
                    },
                    onformat: function(elm, fmt, vars) {
                        each(vars, function(value, key) {
                            dom.setAttrib(elm, key, value);
                        });
                    }
                },
                removeformat: [ {
                    selector: "b,strong,em,i,font,u,strike",
                    remove: "all",
                    split: true,
                    expand: false,
                    block_expand: true,
                    deep: true
                }, {
                    selector: "span",
                    attributes: [ "style", "class" ],
                    remove: "empty",
                    split: true,
                    expand: false,
                    deep: true
                }, {
                    selector: "*",
                    attributes: [ "style", "class" ],
                    split: false,
                    expand: false,
                    deep: true
                } ]
            });
            each("p h1 h2 h3 h4 h5 h6 div address pre div code dt dd samp".split(/\s/), function(name) {
                register(name, {
                    block: name,
                    remove: "all"
                });
            });
            register(ed.settings.formats);
        }
        function addKeyboardShortcuts() {
            ed.addShortcut("ctrl+b", "bold_desc", "Bold");
            ed.addShortcut("ctrl+i", "italic_desc", "Italic");
            ed.addShortcut("ctrl+u", "underline_desc", "Underline");
            for (var i = 1; i <= 6; i++) ed.addShortcut("ctrl+" + i, "", [ "FormatBlock", false, "h" + i ]);
            ed.addShortcut("ctrl+7", "", [ "FormatBlock", false, "p" ]);
            ed.addShortcut("ctrl+8", "", [ "FormatBlock", false, "div" ]);
            ed.addShortcut("ctrl+9", "", [ "FormatBlock", false, "address" ]);
        }
        function get(name) {
            return name ? formats[name] : formats;
        }
        function register(name, format) {
            if (name) if ("string" !== typeof name) each(name, function(format, name) {
                register(name, format);
            }); else {
                format = format.length ? format : [ format ];
                each(format, function(format) {
                    if (format.deep === undef) format.deep = !format.selector;
                    if (format.split === undef) format.split = !format.selector || format.inline;
                    if (format.remove === undef && format.selector && !format.inline) format.remove = "none";
                    if (format.selector && format.inline) {
                        format.mixed = true;
                        format.block_expand = true;
                    }
                    if ("string" === typeof format.classes) format.classes = format.classes.split(/\s+/);
                });
                formats[name] = format;
            }
        }
        var getTextDecoration = function(node) {
            var decoration;
            ed.dom.getParent(node, function(n) {
                decoration = ed.dom.getStyle(n, "text-decoration");
                return decoration && "none" !== decoration;
            });
            return decoration;
        };
        var processUnderlineAndColor = function(node) {
            var textDecoration;
            if (1 === node.nodeType && node.parentNode && 1 === node.parentNode.nodeType) {
                textDecoration = getTextDecoration(node.parentNode);
                if (ed.dom.getStyle(node, "color") && textDecoration) ed.dom.setStyle(node, "text-decoration", textDecoration); else if (ed.dom.getStyle(node, "textdecoration") === textDecoration) ed.dom.setStyle(node, "text-decoration", null);
            }
        };
        function apply(name, vars, node) {
            var formatList = get(name), format = formatList[0], bookmark, rng, i, isCollapsed = selection.isCollapsed();
            function setElementFormat(elm, fmt) {
                fmt = fmt || format;
                if (elm) {
                    if (fmt.onformat) fmt.onformat(elm, fmt, vars, node);
                    each(fmt.styles, function(value, name) {
                        dom.setStyle(elm, name, replaceVars(value, vars));
                    });
                    each(fmt.attributes, function(value, name) {
                        dom.setAttrib(elm, name, replaceVars(value, vars));
                    });
                    each(fmt.classes, function(value) {
                        value = replaceVars(value, vars);
                        if (!dom.hasClass(elm, value)) dom.addClass(elm, value);
                    });
                }
            }
            function adjustSelectionToVisibleSelection() {
                function findSelectionEnd(start, end) {
                    var walker = new TreeWalker(end);
                    for (node = walker.current(); node; node = walker.prev()) if (node.childNodes.length > 1 || node == start || "BR" == node.tagName) return node;
                }
                var rng = ed.selection.getRng();
                var start = rng.startContainer;
                var end = rng.endContainer;
                if (start != end && 0 === rng.endOffset) {
                    var newEnd = findSelectionEnd(start, end);
                    var endOffset = 3 == newEnd.nodeType ? newEnd.length : newEnd.childNodes.length;
                    rng.setEnd(newEnd, endOffset);
                }
                return rng;
            }
            function applyStyleToList(node, bookmark, wrapElm, newWrappers, process) {
                var nodes = [], listIndex = -1, list, startIndex = -1, endIndex = -1, currentWrapElm;
                each(node.childNodes, function(n, index) {
                    if ("UL" === n.nodeName || "OL" === n.nodeName) {
                        listIndex = index;
                        list = n;
                        return false;
                    }
                });
                each(node.childNodes, function(n, index) {
                    if ("SPAN" === n.nodeName && "bookmark" == dom.getAttrib(n, "data-mce-type")) if (n.id == bookmark.id + "_start") startIndex = index; else if (n.id == bookmark.id + "_end") endIndex = index;
                });
                if (listIndex <= 0 || startIndex < listIndex && endIndex > listIndex) {
                    each(tinymce.grep(node.childNodes), process);
                    return 0;
                } else {
                    currentWrapElm = dom.clone(wrapElm, FALSE);
                    each(tinymce.grep(node.childNodes), function(n, index) {
                        if (startIndex < listIndex && index < listIndex || startIndex > listIndex && index > listIndex) {
                            nodes.push(n);
                            n.parentNode.removeChild(n);
                        }
                    });
                    if (startIndex < listIndex) node.insertBefore(currentWrapElm, list); else if (startIndex > listIndex) node.insertBefore(currentWrapElm, list.nextSibling);
                    newWrappers.push(currentWrapElm);
                    each(nodes, function(node) {
                        currentWrapElm.appendChild(node);
                    });
                    return currentWrapElm;
                }
            }
            function applyRngStyle(rng, bookmark, node_specific) {
                var newWrappers = [], wrapName, wrapElm, contentEditable = true;
                wrapName = format.inline || format.block;
                wrapElm = dom.create(wrapName);
                setElementFormat(wrapElm);
                rangeUtils.walk(rng, function(nodes) {
                    var currentWrapElm;
                    function process(node) {
                        var nodeName, parentName, found, hasContentEditableState, lastContentEditable;
                        lastContentEditable = contentEditable;
                        nodeName = node.nodeName.toLowerCase();
                        parentName = node.parentNode.nodeName.toLowerCase();
                        if (1 === node.nodeType && getContentEditable(node)) {
                            lastContentEditable = contentEditable;
                            contentEditable = "true" === getContentEditable(node);
                            hasContentEditableState = true;
                        }
                        if (isEq(nodeName, "br")) {
                            currentWrapElm = 0;
                            if (format.block) dom.remove(node);
                            return;
                        }
                        if (format.wrapper && matchNode(node, name, vars)) {
                            currentWrapElm = 0;
                            return;
                        }
                        if (contentEditable && !hasContentEditableState && format.block && !format.wrapper && isTextBlock(nodeName)) {
                            node = dom.rename(node, wrapName);
                            setElementFormat(node);
                            newWrappers.push(node);
                            currentWrapElm = 0;
                            return;
                        }
                        if (format.selector) {
                            each(formatList, function(format) {
                                if ("collapsed" in format && format.collapsed !== isCollapsed) return;
                                if (dom.is(node, format.selector) && !isCaretNode(node)) {
                                    setElementFormat(node, format);
                                    found = true;
                                }
                            });
                            if (!format.inline || found) {
                                currentWrapElm = 0;
                                return;
                            }
                        }
                        if (contentEditable && !hasContentEditableState && isValid(wrapName, nodeName) && isValid(parentName, wrapName) && !(!node_specific && 3 === node.nodeType && 1 === node.nodeValue.length && 65279 === node.nodeValue.charCodeAt(0)) && !isCaretNode(node)) {
                            if (!currentWrapElm) {
                                currentWrapElm = dom.clone(wrapElm, FALSE);
                                node.parentNode.insertBefore(currentWrapElm, node);
                                newWrappers.push(currentWrapElm);
                            }
                            currentWrapElm.appendChild(node);
                        } else if ("li" == nodeName && bookmark) currentWrapElm = applyStyleToList(node, bookmark, wrapElm, newWrappers, process); else {
                            currentWrapElm = 0;
                            each(tinymce.grep(node.childNodes), process);
                            if (hasContentEditableState) contentEditable = lastContentEditable;
                            currentWrapElm = 0;
                        }
                    }
                    each(nodes, process);
                });
                if (false === format.wrap_links) each(newWrappers, function(node) {
                    function process(node) {
                        var i, currentWrapElm, children;
                        if ("A" === node.nodeName) {
                            currentWrapElm = dom.clone(wrapElm, FALSE);
                            newWrappers.push(currentWrapElm);
                            children = tinymce.grep(node.childNodes);
                            for (i = 0; i < children.length; i++) currentWrapElm.appendChild(children[i]);
                            node.appendChild(currentWrapElm);
                        }
                        each(tinymce.grep(node.childNodes), process);
                    }
                    process(node);
                });
                each(newWrappers, function(node) {
                    var childCount;
                    function getChildCount(node) {
                        var count = 0;
                        each(node.childNodes, function(node) {
                            if (!isWhiteSpaceNode(node) && !isBookmarkNode(node)) count++;
                        });
                        return count;
                    }
                    function mergeStyles(node) {
                        var child, clone;
                        each(node.childNodes, function(node) {
                            if (1 == node.nodeType && !isBookmarkNode(node) && !isCaretNode(node)) {
                                child = node;
                                return FALSE;
                            }
                        });
                        if (child && matchName(child, format)) {
                            clone = dom.clone(child, FALSE);
                            setElementFormat(clone);
                            dom.replace(clone, node, TRUE);
                            dom.remove(child, 1);
                        }
                        return clone || node;
                    }
                    childCount = getChildCount(node);
                    if ((newWrappers.length > 1 || !isBlock(node)) && 0 === childCount) {
                        dom.remove(node, 1);
                        return;
                    }
                    if (format.inline || format.wrapper) {
                        if (!format.exact && 1 === childCount) node = mergeStyles(node);
                        each(formatList, function(format) {
                            each(dom.select(format.inline, node), function(child) {
                                var parent;
                                if (false === format.wrap_links) {
                                    parent = child.parentNode;
                                    do if ("A" === parent.nodeName) return; while (parent = parent.parentNode);
                                }
                                removeFormat(format, vars, child, format.exact ? child : null);
                            });
                        });
                        if (matchNode(node.parentNode, name, vars)) {
                            dom.remove(node, 1);
                            node = 0;
                            return TRUE;
                        }
                        if (format.merge_with_parents) dom.getParent(node.parentNode, function(parent) {
                            if (matchNode(parent, name, vars)) {
                                dom.remove(node, 1);
                                node = 0;
                                return TRUE;
                            }
                        });
                        if (node && false !== format.merge_siblings) {
                            node = mergeSiblings(getNonWhiteSpaceSibling(node), node);
                            node = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));
                        }
                    }
                });
            }
            if (format) if (node) if (node.nodeType) {
                rng = dom.createRng();
                rng.setStartBefore(node);
                rng.setEndAfter(node);
                applyRngStyle(expandRng(rng, formatList), null, true);
            } else applyRngStyle(node, null, true); else if (!isCollapsed || !format.inline || dom.select("td.mceSelected,th.mceSelected").length) {
                var curSelNode = ed.selection.getNode();
                if (!forcedRootBlock && formatList[0].defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) apply(formatList[0].defaultBlock);
                ed.selection.setRng(adjustSelectionToVisibleSelection());
                bookmark = selection.getBookmark();
                applyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);
                if (format.styles && (format.styles.color || format.styles.textDecoration)) {
                    tinymce.walk(curSelNode, processUnderlineAndColor, "childNodes");
                    processUnderlineAndColor(curSelNode);
                }
                selection.moveToBookmark(bookmark);
                moveStart(selection.getRng(TRUE));
                ed.nodeChanged();
            } else performCaretAction("apply", name, vars);
        }
        function remove(name, vars, node) {
            var formatList = get(name), format = formatList[0], bookmark, i, rng, contentEditable = true;
            function process(node) {
                var children, i, l, localContentEditable, lastContentEditable, hasContentEditableState;
                if (1 === node.nodeType && getContentEditable(node)) {
                    lastContentEditable = contentEditable;
                    contentEditable = "true" === getContentEditable(node);
                    hasContentEditableState = true;
                }
                children = tinymce.grep(node.childNodes);
                if (contentEditable && !hasContentEditableState) for (i = 0, l = formatList.length; i < l; i++) if (removeFormat(formatList[i], vars, node, node)) break;
                if (format.deep) if (children.length) {
                    for (i = 0, l = children.length; i < l; i++) process(children[i]);
                    if (hasContentEditableState) contentEditable = lastContentEditable;
                }
            }
            function findFormatRoot(container) {
                var formatRoot;
                each(getParents(container.parentNode).reverse(), function(parent) {
                    var format;
                    if (!formatRoot && "_start" != parent.id && "_end" != parent.id) {
                        format = matchNode(parent, name, vars);
                        if (format && false !== format.split) formatRoot = parent;
                    }
                });
                return formatRoot;
            }
            function wrapAndSplit(format_root, container, target, split) {
                var parent, clone, lastClone, firstClone, i, formatRootParent;
                if (format_root) {
                    formatRootParent = format_root.parentNode;
                    for (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {
                        clone = dom.clone(parent, FALSE);
                        for (i = 0; i < formatList.length; i++) if (removeFormat(formatList[i], vars, clone, clone)) {
                            clone = 0;
                            break;
                        }
                        if (clone) {
                            if (lastClone) clone.appendChild(lastClone);
                            if (!firstClone) firstClone = clone;
                            lastClone = clone;
                        }
                    }
                    if (split && (!format.mixed || !isBlock(format_root))) container = dom.split(format_root, container);
                    if (lastClone) {
                        target.parentNode.insertBefore(lastClone, target);
                        firstClone.appendChild(target);
                    }
                }
                return container;
            }
            function splitToFormatRoot(container) {
                return wrapAndSplit(findFormatRoot(container), container, container, true);
            }
            function unwrap(start) {
                var node = dom.get(start ? "_start" : "_end"), out = node[start ? "firstChild" : "lastChild"];
                if (isBookmarkNode(out)) out = out[start ? "firstChild" : "lastChild"];
                dom.remove(node, true);
                return out;
            }
            function removeRngStyle(rng) {
                var startContainer, endContainer, node;
                rng = expandRng(rng, formatList, TRUE);
                if (format.split) {
                    startContainer = getContainer(rng, TRUE);
                    endContainer = getContainer(rng);
                    if (startContainer != endContainer) {
                        if (/^(TR|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) startContainer = ("TD" == startContainer.nodeName ? startContainer.firstChild : startContainer.firstChild.firstChild) || startContainer;
                        startContainer = wrap(startContainer, "span", {
                            id: "_start",
                            "data-mce-type": "bookmark"
                        });
                        endContainer = wrap(endContainer, "span", {
                            id: "_end",
                            "data-mce-type": "bookmark"
                        });
                        splitToFormatRoot(startContainer);
                        splitToFormatRoot(endContainer);
                        startContainer = unwrap(TRUE);
                        endContainer = unwrap();
                    } else startContainer = endContainer = splitToFormatRoot(startContainer);
                    rng.startContainer = startContainer.parentNode;
                    rng.startOffset = nodeIndex(startContainer);
                    rng.endContainer = endContainer.parentNode;
                    rng.endOffset = nodeIndex(endContainer) + 1;
                }
                rangeUtils.walk(rng, function(nodes) {
                    each(nodes, function(node) {
                        process(node);
                        if (1 === node.nodeType && "underline" === ed.dom.getStyle(node, "text-decoration") && node.parentNode && "underline" === getTextDecoration(node.parentNode)) removeFormat({
                            deep: false,
                            exact: true,
                            inline: "span",
                            styles: {
                                textDecoration: "underline"
                            }
                        }, null, node);
                    });
                });
            }
            if (node) {
                if (node.nodeType) {
                    rng = dom.createRng();
                    rng.setStartBefore(node);
                    rng.setEndAfter(node);
                    removeRngStyle(rng);
                } else removeRngStyle(node);
                return;
            }
            if (!selection.isCollapsed() || !format.inline || dom.select("td.mceSelected,th.mceSelected").length) {
                bookmark = selection.getBookmark();
                removeRngStyle(selection.getRng(TRUE));
                selection.moveToBookmark(bookmark);
                if (format.inline && match(name, vars, selection.getStart())) moveStart(selection.getRng(true));
                ed.nodeChanged();
            } else performCaretAction("remove", name, vars);
        }
        function toggle(name, vars, node) {
            var fmt = get(name);
            if (match(name, vars, node) && (!("toggle" in fmt[0]) || fmt[0].toggle)) remove(name, vars, node); else apply(name, vars, node);
        }
        function matchNode(node, name, vars, similar) {
            var formatList = get(name), format, i, classes;
            function matchItems(node, format, item_name) {
                var key, value, items = format[item_name], i;
                if (format.onmatch) return format.onmatch(node, format, item_name);
                if (items) if (items.length === undef) {
                    for (key in items) if (items.hasOwnProperty(key)) {
                        if ("attributes" === item_name) value = dom.getAttrib(node, key); else value = getStyle(node, key);
                        if (similar && !value && !format.exact) return;
                        if ((!similar || format.exact) && !isEq(value, replaceVars(items[key], vars))) return;
                    }
                } else for (i = 0; i < items.length; i++) if ("attributes" === item_name ? dom.getAttrib(node, items[i]) : getStyle(node, items[i])) return format;
                return format;
            }
            if (formatList && node) for (i = 0; i < formatList.length; i++) {
                format = formatList[i];
                if (matchName(node, format) && matchItems(node, format, "attributes") && matchItems(node, format, "styles")) {
                    if (classes = format.classes) for (i = 0; i < classes.length; i++) if (!dom.hasClass(node, classes[i])) return;
                    return format;
                }
            }
        }
        function match(name, vars, node) {
            var startNode;
            function matchParents(node) {
                node = dom.getParent(node, function(node) {
                    return !!matchNode(node, name, vars, true);
                });
                return matchNode(node, name, vars);
            }
            if (node) return matchParents(node);
            node = selection.getNode();
            if (matchParents(node)) return TRUE;
            startNode = selection.getStart();
            if (startNode != node) if (matchParents(startNode)) return TRUE;
            return FALSE;
        }
        function matchAll(names, vars) {
            var startElement, matchedFormatNames = [], checkedMap = {}, i, ni, name;
            startElement = selection.getStart();
            dom.getParent(startElement, function(node) {
                var i, name;
                for (i = 0; i < names.length; i++) {
                    name = names[i];
                    if (!checkedMap[name] && matchNode(node, name, vars)) {
                        checkedMap[name] = true;
                        matchedFormatNames.push(name);
                    }
                }
            }, dom.getRoot());
            return matchedFormatNames;
        }
        function canApply(name) {
            var formatList = get(name), startNode, parents, i, x, selector;
            if (formatList) {
                startNode = selection.getStart();
                parents = getParents(startNode);
                for (x = formatList.length - 1; x >= 0; x--) {
                    selector = formatList[x].selector;
                    if (!selector) return TRUE;
                    for (i = parents.length - 1; i >= 0; i--) if (dom.is(parents[i], selector)) return TRUE;
                }
            }
            return FALSE;
        }
        function formatChanged(formats, callback, similar) {
            var currentFormats;
            if (!formatChangeData) {
                formatChangeData = {};
                currentFormats = {};
                ed.onNodeChange.addToTop(function(ed, cm, node) {
                    var parents = getParents(node), matchedFormats = {};
                    each(formatChangeData, function(callbacks, format) {
                        each(parents, function(node) {
                            if (matchNode(node, format, {}, callbacks.similar)) {
                                if (!currentFormats[format]) {
                                    each(callbacks, function(callback) {
                                        callback(true, {
                                            node: node,
                                            format: format,
                                            parents: parents
                                        });
                                    });
                                    currentFormats[format] = callbacks;
                                }
                                matchedFormats[format] = callbacks;
                                return false;
                            }
                        });
                    });
                    each(currentFormats, function(callbacks, format) {
                        if (!matchedFormats[format]) {
                            delete currentFormats[format];
                            each(callbacks, function(callback) {
                                callback(false, {
                                    node: node,
                                    format: format,
                                    parents: parents
                                });
                            });
                        }
                    });
                });
            }
            each(formats.split(","), function(format) {
                if (!formatChangeData[format]) {
                    formatChangeData[format] = [];
                    formatChangeData[format].similar = similar;
                }
                formatChangeData[format].push(callback);
            });
            return this;
        }
        tinymce.extend(this, {
            get: get,
            register: register,
            apply: apply,
            remove: remove,
            toggle: toggle,
            match: match,
            matchAll: matchAll,
            matchNode: matchNode,
            canApply: canApply,
            formatChanged: formatChanged
        });
        defaultFormats();
        addKeyboardShortcuts();
        function matchName(node, format) {
            if (isEq(node, format.inline)) return TRUE;
            if (isEq(node, format.block)) return TRUE;
            if (format.selector) return dom.is(node, format.selector);
        }
        function isEq(str1, str2) {
            str1 = str1 || "";
            str2 = str2 || "";
            str1 = "" + (str1.nodeName || str1);
            str2 = "" + (str2.nodeName || str2);
            return str1.toLowerCase() == str2.toLowerCase();
        }
        function getStyle(node, name) {
            var styleVal = dom.getStyle(node, name);
            if ("color" == name || "backgroundColor" == name) styleVal = dom.toHex(styleVal);
            if ("fontWeight" == name && 700 == styleVal) styleVal = "bold";
            return "" + styleVal;
        }
        function replaceVars(value, vars) {
            if ("string" != typeof value) value = value(vars); else if (vars) value = value.replace(/%(\w+)/g, function(str, name) {
                return vars[name] || str;
            });
            return value;
        }
        function isWhiteSpaceNode(node) {
            return node && 3 === node.nodeType && /^([\t \r\n]+|)$/.test(node.nodeValue);
        }
        function wrap(node, name, attrs) {
            var wrapper = dom.create(name, attrs);
            node.parentNode.insertBefore(wrapper, node);
            wrapper.appendChild(node);
            return wrapper;
        }
        function expandRng(rng, format, remove) {
            var sibling, lastIdx, leaf, endPoint, startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
            function findParentContainer(start) {
                var container, parent, child, sibling, siblingName, root;
                container = parent = start ? startContainer : endContainer;
                siblingName = start ? "previousSibling" : "nextSibling";
                root = dom.getRoot();
                if (3 == container.nodeType && !isWhiteSpaceNode(container)) if (start ? startOffset > 0 : endOffset < container.nodeValue.length) return container;
                for (;;) {
                    if (!format[0].block_expand && isBlock(parent)) return parent;
                    for (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) if (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling)) return parent;
                    if (parent.parentNode == root) {
                        container = parent;
                        break;
                    }
                    parent = parent.parentNode;
                }
                return container;
            }
            function findLeaf(node, offset) {
                if (offset === undef) offset = 3 === node.nodeType ? node.length : node.childNodes.length;
                while (node && node.hasChildNodes()) {
                    node = node.childNodes[offset];
                    if (node) offset = 3 === node.nodeType ? node.length : node.childNodes.length;
                }
                return {
                    node: node,
                    offset: offset
                };
            }
            if (1 == startContainer.nodeType && startContainer.hasChildNodes()) {
                lastIdx = startContainer.childNodes.length - 1;
                startContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];
                if (3 == startContainer.nodeType) startOffset = 0;
            }
            if (1 == endContainer.nodeType && endContainer.hasChildNodes()) {
                lastIdx = endContainer.childNodes.length - 1;
                endContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];
                if (3 == endContainer.nodeType) endOffset = endContainer.nodeValue.length;
            }
            function findParentContentEditable(node) {
                var parent = node;
                while (parent) {
                    if (1 === parent.nodeType && getContentEditable(parent)) return "false" === getContentEditable(parent) ? parent : node;
                    parent = parent.parentNode;
                }
                return node;
            }
            function findWordEndPoint(container, offset, start) {
                var walker, node, pos, lastTextNode;
                function findSpace(node, offset) {
                    var pos, pos2, str = node.nodeValue;
                    if ("undefined" == typeof offset) offset = start ? str.length : 0;
                    if (start) {
                        pos = str.lastIndexOf(" ", offset);
                        pos2 = str.lastIndexOf(" ", offset);
                        pos = pos > pos2 ? pos : pos2;
                        if (pos !== -1 && !remove) pos++;
                    } else {
                        pos = str.indexOf(" ", offset);
                        pos2 = str.indexOf(" ", offset);
                        pos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;
                    }
                    return pos;
                }
                if (3 === container.nodeType) {
                    pos = findSpace(container, offset);
                    if (pos !== -1) return {
                        container: container,
                        offset: pos
                    };
                    lastTextNode = container;
                }
                walker = new TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());
                while (node = walker[start ? "prev" : "next"]()) if (3 === node.nodeType) {
                    lastTextNode = node;
                    pos = findSpace(node);
                    if (pos !== -1) return {
                        container: node,
                        offset: pos
                    };
                } else if (isBlock(node)) break;
                if (lastTextNode) {
                    if (start) offset = 0; else offset = lastTextNode.length;
                    return {
                        container: lastTextNode,
                        offset: offset
                    };
                }
            }
            function findSelectorEndPoint(container, sibling_name) {
                var parents, i, y, curFormat;
                if (3 == container.nodeType && 0 === container.nodeValue.length && container[sibling_name]) container = container[sibling_name];
                parents = getParents(container);
                for (i = 0; i < parents.length; i++) for (y = 0; y < format.length; y++) {
                    curFormat = format[y];
                    if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) continue;
                    if (dom.is(parents[i], curFormat.selector)) return parents[i];
                }
                return container;
            }
            function findBlockEndPoint(container, sibling_name, sibling_name2) {
                var node;
                if (!format[0].wrapper) node = dom.getParent(container, format[0].block);
                if (!node) node = dom.getParent(3 == container.nodeType ? container.parentNode : container, isBlock);
                if (node && format[0].wrapper) node = getParents(node, "ul,ol").reverse()[0] || node;
                if (!node) {
                    node = container;
                    while (node[sibling_name] && !isBlock(node[sibling_name])) {
                        node = node[sibling_name];
                        if (isEq(node, "br")) break;
                    }
                }
                return node || container;
            }
            startContainer = findParentContentEditable(startContainer);
            endContainer = findParentContentEditable(endContainer);
            if (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {
                startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
                startContainer = startContainer.nextSibling || startContainer;
                if (3 == startContainer.nodeType) startOffset = 0;
            }
            if (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {
                endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
                endContainer = endContainer.previousSibling || endContainer;
                if (3 == endContainer.nodeType) endOffset = endContainer.length;
            }
            if (format[0].inline) {
                if (rng.collapsed) {
                    endPoint = findWordEndPoint(startContainer, startOffset, true);
                    if (endPoint) {
                        startContainer = endPoint.container;
                        startOffset = endPoint.offset;
                    }
                    endPoint = findWordEndPoint(endContainer, endOffset);
                    if (endPoint) {
                        endContainer = endPoint.container;
                        endOffset = endPoint.offset;
                    }
                }
                leaf = findLeaf(endContainer, endOffset);
                if (leaf.node) {
                    while (leaf.node && 0 === leaf.offset && leaf.node.previousSibling) leaf = findLeaf(leaf.node.previousSibling);
                    if (leaf.node && leaf.offset > 0 && 3 === leaf.node.nodeType && " " === leaf.node.nodeValue.charAt(leaf.offset - 1)) if (leaf.offset > 1) {
                        endContainer = leaf.node;
                        endContainer.splitText(leaf.offset - 1);
                    }
                }
            }
            if (format[0].inline || format[0].block_expand) {
                if (!format[0].inline || 3 != startContainer.nodeType || 0 === startOffset) startContainer = findParentContainer(true);
                if (!format[0].inline || 3 != endContainer.nodeType || endOffset === endContainer.nodeValue.length) endContainer = findParentContainer();
            }
            if (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {
                startContainer = findSelectorEndPoint(startContainer, "previousSibling");
                endContainer = findSelectorEndPoint(endContainer, "nextSibling");
            }
            if (format[0].block || format[0].selector) {
                startContainer = findBlockEndPoint(startContainer, "previousSibling");
                endContainer = findBlockEndPoint(endContainer, "nextSibling");
                if (format[0].block) {
                    if (!isBlock(startContainer)) startContainer = findParentContainer(true);
                    if (!isBlock(endContainer)) endContainer = findParentContainer();
                }
            }
            if (1 == startContainer.nodeType) {
                startOffset = nodeIndex(startContainer);
                startContainer = startContainer.parentNode;
            }
            if (1 == endContainer.nodeType) {
                endOffset = nodeIndex(endContainer) + 1;
                endContainer = endContainer.parentNode;
            }
            return {
                startContainer: startContainer,
                startOffset: startOffset,
                endContainer: endContainer,
                endOffset: endOffset
            };
        }
        function removeFormat(format, vars, node, compare_node) {
            var i, attrs, stylesModified;
            if (!matchName(node, format)) return FALSE;
            if ("all" != format.remove) {
                each(format.styles, function(value, name) {
                    value = replaceVars(value, vars);
                    if ("number" === typeof name) {
                        name = value;
                        compare_node = 0;
                    }
                    if (!compare_node || isEq(getStyle(compare_node, name), value)) dom.setStyle(node, name, "");
                    stylesModified = 1;
                });
                if (stylesModified && "" == dom.getAttrib(node, "style")) {
                    node.removeAttribute("style");
                    node.removeAttribute("data-mce-style");
                }
                each(format.attributes, function(value, name) {
                    var valueOut;
                    value = replaceVars(value, vars);
                    if ("number" === typeof name) {
                        name = value;
                        compare_node = 0;
                    }
                    if (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {
                        if ("class" == name) {
                            value = dom.getAttrib(node, name);
                            if (value) {
                                valueOut = "";
                                each(value.split(/\s+/), function(cls) {
                                    if (/mce\w+/.test(cls)) valueOut += (valueOut ? " " : "") + cls;
                                });
                                if (valueOut) {
                                    dom.setAttrib(node, name, valueOut);
                                    return;
                                }
                            }
                        }
                        if ("class" == name) node.removeAttribute("className");
                        if (MCE_ATTR_RE.test(name)) node.removeAttribute("data-mce-" + name);
                        node.removeAttribute(name);
                    }
                });
                each(format.classes, function(value) {
                    value = replaceVars(value, vars);
                    if (!compare_node || dom.hasClass(compare_node, value)) dom.removeClass(node, value);
                });
                attrs = dom.getAttribs(node);
                for (i = 0; i < attrs.length; i++) if (0 !== attrs[i].nodeName.indexOf("_")) return FALSE;
            }
            if ("none" != format.remove) {
                removeNode(node, format);
                return TRUE;
            }
        }
        function removeNode(node, format) {
            var parentNode = node.parentNode, rootBlockElm;
            function find(node, next, inc) {
                node = getNonWhiteSpaceSibling(node, next, inc);
                return !node || "BR" == node.nodeName || isBlock(node);
            }
            if (format.block) if (!forcedRootBlock) {
                if (isBlock(node) && !isBlock(parentNode)) {
                    if (!find(node, FALSE) && !find(node.firstChild, TRUE, 1)) node.insertBefore(dom.create("br"), node.firstChild);
                    if (!find(node, TRUE) && !find(node.lastChild, FALSE, 1)) node.appendChild(dom.create("br"));
                }
            } else if (parentNode == dom.getRoot()) if (!format.list_block || !isEq(node, format.list_block)) each(tinymce.grep(node.childNodes), function(node) {
                if (isValid(forcedRootBlock, node.nodeName.toLowerCase())) if (!rootBlockElm) rootBlockElm = wrap(node, forcedRootBlock); else rootBlockElm.appendChild(node); else rootBlockElm = 0;
            });
            if (format.selector && format.inline && !isEq(format.inline, node)) return;
            dom.remove(node, 1);
        }
        function getNonWhiteSpaceSibling(node, next, inc) {
            if (node) {
                next = next ? "nextSibling" : "previousSibling";
                for (node = inc ? node : node[next]; node; node = node[next]) if (1 == node.nodeType || !isWhiteSpaceNode(node)) return node;
            }
        }
        function isBookmarkNode(node) {
            return node && 1 == node.nodeType && "bookmark" == node.getAttribute("data-mce-type");
        }
        function mergeSiblings(prev, next) {
            var marker, sibling, tmpSibling;
            function compareElements(node1, node2) {
                if (node1.nodeName != node2.nodeName) return FALSE;
                function getAttribs(node) {
                    var attribs = {};
                    each(dom.getAttribs(node), function(attr) {
                        var name = attr.nodeName.toLowerCase();
                        if (0 !== name.indexOf("_") && "style" !== name) attribs[name] = dom.getAttrib(node, name);
                    });
                    return attribs;
                }
                function compareObjects(obj1, obj2) {
                    var value, name;
                    for (name in obj1) if (obj1.hasOwnProperty(name)) {
                        value = obj2[name];
                        if (value === undef) return FALSE;
                        if (obj1[name] != value) return FALSE;
                        delete obj2[name];
                    }
                    for (name in obj2) if (obj2.hasOwnProperty(name)) return FALSE;
                    return TRUE;
                }
                if (!compareObjects(getAttribs(node1), getAttribs(node2))) return FALSE;
                if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, "style")), dom.parseStyle(dom.getAttrib(node2, "style")))) return FALSE;
                return TRUE;
            }
            function findElementSibling(node, sibling_name) {
                for (sibling = node; sibling; sibling = sibling[sibling_name]) {
                    if (3 == sibling.nodeType && 0 !== sibling.nodeValue.length) return node;
                    if (1 == sibling.nodeType && !isBookmarkNode(sibling)) return sibling;
                }
                return node;
            }
            if (prev && next) {
                prev = findElementSibling(prev, "previousSibling");
                next = findElementSibling(next, "nextSibling");
                if (compareElements(prev, next)) {
                    for (sibling = prev.nextSibling; sibling && sibling != next; ) {
                        tmpSibling = sibling;
                        sibling = sibling.nextSibling;
                        prev.appendChild(tmpSibling);
                    }
                    dom.remove(next);
                    each(tinymce.grep(next.childNodes), function(node) {
                        prev.appendChild(node);
                    });
                    return prev;
                }
            }
            return next;
        }
        function isTextBlock(name) {
            return /^(h[1-6]|p|div|pre|address|dl|dt|dd)$/.test(name);
        }
        function getContainer(rng, start) {
            var container, offset, lastIdx, walker;
            container = rng[start ? "startContainer" : "endContainer"];
            offset = rng[start ? "startOffset" : "endOffset"];
            if (1 == container.nodeType) {
                lastIdx = container.childNodes.length - 1;
                if (!start && offset) offset--;
                container = container.childNodes[offset > lastIdx ? lastIdx : offset];
            }
            if (3 === container.nodeType && start && offset >= container.nodeValue.length) container = new TreeWalker(container, ed.getBody()).next() || container;
            if (3 === container.nodeType && !start && 0 === offset) container = new TreeWalker(container, ed.getBody()).prev() || container;
            return container;
        }
        function performCaretAction(type, name, vars) {
            var caretContainerId = "_mce_caret", debug = ed.settings.caret_debug;
            function createCaretContainer(fill) {
                var caretContainer = dom.create("span", {
                    id: caretContainerId,
                    "data-mce-bogus": true,
                    style: debug ? "color:red" : ""
                });
                if (fill) caretContainer.appendChild(ed.getDoc().createTextNode(INVISIBLE_CHAR));
                return caretContainer;
            }
            function isCaretContainerEmpty(node, nodes) {
                while (node) {
                    if (3 === node.nodeType && node.nodeValue !== INVISIBLE_CHAR || node.childNodes.length > 1) return false;
                    if (nodes && 1 === node.nodeType) nodes.push(node);
                    node = node.firstChild;
                }
                return true;
            }
            function getParentCaretContainer(node) {
                while (node) {
                    if (node.id === caretContainerId) return node;
                    node = node.parentNode;
                }
            }
            function findFirstTextNode(node) {
                var walker;
                if (node) {
                    walker = new TreeWalker(node, node);
                    for (node = walker.current(); node; node = walker.next()) if (3 === node.nodeType) return node;
                }
            }
            function removeCaretContainer(node, move_caret) {
                var child, rng;
                if (!node) {
                    node = getParentCaretContainer(selection.getStart());
                    if (!node) while (node = dom.get(caretContainerId)) removeCaretContainer(node, false);
                } else {
                    rng = selection.getRng(true);
                    if (isCaretContainerEmpty(node)) {
                        if (false !== move_caret) {
                            rng.setStartBefore(node);
                            rng.setEndBefore(node);
                        }
                        dom.remove(node);
                    } else {
                        child = findFirstTextNode(node);
                        if (child.nodeValue.charAt(0) === INVISIBLE_CHAR) child = child.deleteData(0, 1);
                        dom.remove(node, 1);
                    }
                    selection.setRng(rng);
                }
            }
            function applyCaretFormat() {
                var rng, caretContainer, textNode, offset, bookmark, container, text;
                rng = selection.getRng(true);
                offset = rng.startOffset;
                container = rng.startContainer;
                text = container.nodeValue;
                caretContainer = getParentCaretContainer(selection.getStart());
                if (caretContainer) textNode = findFirstTextNode(caretContainer);
                if (text && offset > 0 && offset < text.length && /\w/.test(text.charAt(offset)) && /\w/.test(text.charAt(offset - 1))) {
                    bookmark = selection.getBookmark();
                    rng.collapse(true);
                    rng = expandRng(rng, get(name));
                    rng = rangeUtils.split(rng);
                    apply(name, vars, rng);
                    selection.moveToBookmark(bookmark);
                } else {
                    if (!caretContainer || textNode.nodeValue !== INVISIBLE_CHAR) {
                        caretContainer = createCaretContainer(true);
                        textNode = caretContainer.firstChild;
                        rng.insertNode(caretContainer);
                        offset = 1;
                        apply(name, vars, caretContainer);
                    } else apply(name, vars, caretContainer);
                    selection.setCursorLocation(textNode, offset);
                }
            }
            function removeCaretFormat() {
                var rng = selection.getRng(true), container, offset, bookmark, hasContentAfter, node, formatNode, parents = [], i, caretContainer;
                container = rng.startContainer;
                offset = rng.startOffset;
                node = container;
                if (3 == container.nodeType) {
                    if (offset != container.nodeValue.length || container.nodeValue === INVISIBLE_CHAR) hasContentAfter = true;
                    node = node.parentNode;
                }
                while (node) {
                    if (matchNode(node, name, vars)) {
                        formatNode = node;
                        break;
                    }
                    if (node.nextSibling) hasContentAfter = true;
                    parents.push(node);
                    node = node.parentNode;
                }
                if (!formatNode) return;
                if (hasContentAfter) {
                    bookmark = selection.getBookmark();
                    rng.collapse(true);
                    rng = expandRng(rng, get(name), true);
                    rng = rangeUtils.split(rng);
                    remove(name, vars, rng);
                    selection.moveToBookmark(bookmark);
                } else {
                    caretContainer = createCaretContainer();
                    node = caretContainer;
                    for (i = parents.length - 1; i >= 0; i--) {
                        node.appendChild(dom.clone(parents[i], false));
                        node = node.firstChild;
                    }
                    node.appendChild(dom.doc.createTextNode(INVISIBLE_CHAR));
                    node = node.firstChild;
                    dom.insertAfter(caretContainer, formatNode);
                    selection.setCursorLocation(node, 1);
                }
            }
            function unmarkBogusCaretParents() {
                var i, caretContainer, node;
                caretContainer = getParentCaretContainer(selection.getStart());
                if (caretContainer && !dom.isEmpty(caretContainer)) tinymce.walk(caretContainer, function(node) {
                    if (1 == node.nodeType && node.id !== caretContainerId && !dom.isEmpty(node)) dom.setAttrib(node, "data-mce-bogus", null);
                }, "childNodes");
            }
            if (!self._hasCaretEvents) {
                ed.onBeforeGetContent.addToTop(function() {
                    var nodes = [], i;
                    if (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {
                        i = nodes.length;
                        while (i--) dom.setAttrib(nodes[i], "data-mce-bogus", "1");
                    }
                });
                tinymce.each("onMouseUp onKeyUp".split(" "), function(name) {
                    ed[name].addToTop(function() {
                        removeCaretContainer();
                        unmarkBogusCaretParents();
                    });
                });
                ed.onKeyDown.addToTop(function(ed, e) {
                    var keyCode = e.keyCode;
                    if (8 == keyCode || 37 == keyCode || 39 == keyCode) removeCaretContainer(getParentCaretContainer(selection.getStart()));
                    unmarkBogusCaretParents();
                });
                selection.onSetContent.add(unmarkBogusCaretParents);
                self._hasCaretEvents = true;
            }
            if ("apply" == type) applyCaretFormat(); else removeCaretFormat();
        }
        function moveStart(rng) {
            var container = rng.startContainer, offset = rng.startOffset, isAtEndOfText, walker, node, nodes, tmpNode;
            if (3 == container.nodeType && offset >= container.nodeValue.length) {
                offset = nodeIndex(container);
                container = container.parentNode;
                isAtEndOfText = true;
            }
            if (1 == container.nodeType) {
                nodes = container.childNodes;
                container = nodes[Math.min(offset, nodes.length - 1)];
                walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));
                if (offset > nodes.length - 1 || isAtEndOfText) walker.next();
                for (node = walker.current(); node; node = walker.next()) if (3 == node.nodeType && !isWhiteSpaceNode(node)) {
                    tmpNode = dom.create("a", null, INVISIBLE_CHAR);
                    node.parentNode.insertBefore(tmpNode, node);
                    rng.setStart(node, 0);
                    selection.setRng(rng);
                    dom.remove(tmpNode);
                    return;
                }
            }
        }
    };
})(tinymce);

tinymce.onAddEditor.add(function(tinymce, ed) {
    var filters, fontSizes, dom, settings = ed.settings;
    function replaceWithSpan(node, styles) {
        tinymce.each(styles, function(value, name) {
            if (value) dom.setStyle(node, name, value);
        });
        dom.rename(node, "span");
    }
    function convert(editor, params) {
        dom = editor.dom;
        if (settings.convert_fonts_to_spans) tinymce.each(dom.select("font,u,strike", params.node), function(node) {
            filters[node.nodeName.toLowerCase()](ed.dom, node);
        });
    }
    if (settings.inline_styles) {
        fontSizes = tinymce.explode(settings.font_size_legacy_values);
        filters = {
            font: function(dom, node) {
                replaceWithSpan(node, {
                    backgroundColor: node.style.backgroundColor,
                    color: node.color,
                    fontFamily: node.face,
                    fontSize: fontSizes[parseInt(node.size, 10) - 1]
                });
            },
            u: function(dom, node) {
                replaceWithSpan(node, {
                    textDecoration: "underline"
                });
            },
            strike: function(dom, node) {
                replaceWithSpan(node, {
                    textDecoration: "line-through"
                });
            }
        };
        ed.onPreProcess.add(convert);
        ed.onSetContent.add(convert);
        ed.onInit.add(function() {
            ed.selection.onSetContent.add(convert);
        });
    }
});

(function(tinymce) {
    var TreeWalker = tinymce.dom.TreeWalker;
    tinymce.EnterKey = function(editor) {
        var dom = editor.dom, selection = editor.selection, settings = editor.settings, undoManager = editor.undoManager, nonEmptyElementsMap = editor.schema.getNonEmptyElements();
        function handleEnterKey(evt) {
            var rng = selection.getRng(true), tmpRng, editableRoot, container, offset, parentBlock, documentMode, shiftKey, newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;
            function canSplitBlock(node) {
                return node && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && "true" !== dom.getContentEditable(node);
            }
            function renderBlockOnIE(block) {
                var oldRng;
                if (tinymce.isIE && dom.isBlock(block)) {
                    oldRng = selection.getRng();
                    block.appendChild(dom.create("span", null, " "));
                    selection.select(block);
                    block.lastChild.outerHTML = "";
                    selection.setRng(oldRng);
                }
            }
            function trimInlineElementsOnLeftSideOfBlock(block) {
                var node = block, firstChilds = [], i;
                while (node = node.firstChild) {
                    if (dom.isBlock(node)) return;
                    if (1 == node.nodeType && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) firstChilds.push(node);
                }
                i = firstChilds.length;
                while (i--) {
                    node = firstChilds[i];
                    if (!node.hasChildNodes() || node.firstChild == node.lastChild && "" === node.firstChild.nodeValue) dom.remove(node); else if ("A" == node.nodeName && " " === (node.innerText || node.textContent)) dom.remove(node);
                }
            }
            function moveToCaretPosition(root) {
                var walker, node, rng, y, viewPort, lastNode = root, tempElm;
                rng = dom.createRng();
                if (root.hasChildNodes()) {
                    walker = new TreeWalker(root, root);
                    while (node = walker.current()) {
                        if (3 == node.nodeType) {
                            rng.setStart(node, 0);
                            rng.setEnd(node, 0);
                            break;
                        }
                        if (nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
                            rng.setStartBefore(node);
                            rng.setEndBefore(node);
                            break;
                        }
                        lastNode = node;
                        node = walker.next();
                    }
                    if (!node) {
                        rng.setStart(lastNode, 0);
                        rng.setEnd(lastNode, 0);
                    }
                } else if ("BR" == root.nodeName) if (root.nextSibling && dom.isBlock(root.nextSibling)) {
                    if (!documentMode || documentMode < 9) {
                        tempElm = dom.create("br");
                        root.parentNode.insertBefore(tempElm, root);
                    }
                    rng.setStartBefore(root);
                    rng.setEndBefore(root);
                } else {
                    rng.setStartAfter(root);
                    rng.setEndAfter(root);
                } else {
                    rng.setStart(root, 0);
                    rng.setEnd(root, 0);
                }
                selection.setRng(rng);
                dom.remove(tempElm);
                viewPort = dom.getViewPort(editor.getWin());
                y = dom.getPos(root).y;
                if (y < viewPort.y || y + 25 > viewPort.y + viewPort.h) editor.getWin().scrollTo(0, y < viewPort.y ? y : y - viewPort.h + 25);
            }
            function createNewBlock(name) {
                var node = container, block, clonedNode, caretNode;
                block = name || "TABLE" == parentBlockName ? dom.create(name || newBlockName) : parentBlock.cloneNode(false);
                caretNode = block;
                if (false !== settings.keep_styles) do if (/^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$/.test(node.nodeName)) {
                    clonedNode = node.cloneNode(false);
                    dom.setAttrib(clonedNode, "id", "");
                    if (block.hasChildNodes()) {
                        clonedNode.appendChild(block.firstChild);
                        block.appendChild(clonedNode);
                    } else {
                        caretNode = clonedNode;
                        block.appendChild(clonedNode);
                    }
                } while (node = node.parentNode);
                if (!tinymce.isIE) caretNode.innerHTML = "<br>";
                return block;
            }
            function isCaretAtStartOrEndOfBlock(start) {
                var walker, node, name;
                if (3 == container.nodeType && (start ? offset > 0 : offset < container.nodeValue.length)) return false;
                if (container.parentNode == parentBlock && isAfterLastNodeInContainer && !start) return true;
                if (start && 1 == container.nodeType && container == parentBlock.firstChild) return true;
                if ("TABLE" === container.nodeName || container.previousSibling && "TABLE" == container.previousSibling.nodeName) return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;
                walker = new TreeWalker(container, parentBlock);
                if (3 == container.nodeType) if (start && 0 == offset) walker.prev(); else if (!start && offset == container.nodeValue.length) walker.next();
                while (node = walker.current()) {
                    if (1 === node.nodeType) {
                        if (!node.getAttribute("data-mce-bogus")) {
                            name = node.nodeName.toLowerCase();
                            if (nonEmptyElementsMap[name] && "br" !== name) return false;
                        }
                    } else if (3 === node.nodeType && !/^[ \t\r\n]*$/.test(node.nodeValue)) return false;
                    if (start) walker.prev(); else walker.next();
                }
                return true;
            }
            function wrapSelfAndSiblingsInDefaultBlock(container, offset) {
                var newBlock, parentBlock, startNode, node, next, blockName = newBlockName || "P";
                parentBlock = dom.getParent(container, dom.isBlock);
                if (!parentBlock || !canSplitBlock(parentBlock)) {
                    parentBlock = parentBlock || editableRoot;
                    if (!parentBlock.hasChildNodes()) {
                        newBlock = dom.create(blockName);
                        parentBlock.appendChild(newBlock);
                        rng.setStart(newBlock, 0);
                        rng.setEnd(newBlock, 0);
                        return newBlock;
                    }
                    node = container;
                    while (node.parentNode != parentBlock) node = node.parentNode;
                    while (node && !dom.isBlock(node)) {
                        startNode = node;
                        node = node.previousSibling;
                    }
                    if (startNode) {
                        newBlock = dom.create(blockName);
                        startNode.parentNode.insertBefore(newBlock, startNode);
                        node = startNode;
                        while (node && !dom.isBlock(node)) {
                            next = node.nextSibling;
                            newBlock.appendChild(node);
                            node = next;
                        }
                        rng.setStart(container, offset);
                        rng.setEnd(container, offset);
                    }
                }
                return container;
            }
            function handleEmptyListItem() {
                function isFirstOrLastLi(first) {
                    var node = containerBlock[first ? "firstChild" : "lastChild"];
                    while (node) {
                        if (1 == node.nodeType) break;
                        node = node[first ? "nextSibling" : "previousSibling"];
                    }
                    return node === parentBlock;
                }
                newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create("BR");
                if (isFirstOrLastLi(true) && isFirstOrLastLi()) dom.replace(newBlock, containerBlock); else if (isFirstOrLastLi(true)) containerBlock.parentNode.insertBefore(newBlock, containerBlock); else if (isFirstOrLastLi()) {
                    dom.insertAfter(newBlock, containerBlock);
                    renderBlockOnIE(newBlock);
                } else {
                    tmpRng = rng.cloneRange();
                    tmpRng.setStartAfter(parentBlock);
                    tmpRng.setEndAfter(containerBlock);
                    fragment = tmpRng.extractContents();
                    dom.insertAfter(fragment, containerBlock);
                    dom.insertAfter(newBlock, containerBlock);
                }
                dom.remove(parentBlock);
                moveToCaretPosition(newBlock);
                undoManager.add();
            }
            function hasRightSideBr() {
                var walker = new TreeWalker(container, parentBlock), node;
                while (node = walker.current()) {
                    if ("BR" == node.nodeName) return true;
                    node = walker.next();
                }
            }
            function insertBr() {
                var brElm, extraBr;
                if (container && 3 == container.nodeType && offset >= container.nodeValue.length) if (!tinymce.isIE && !hasRightSideBr()) {
                    brElm = dom.create("br");
                    rng.insertNode(brElm);
                    rng.setStartAfter(brElm);
                    rng.setEndAfter(brElm);
                    extraBr = true;
                }
                brElm = dom.create("br");
                rng.insertNode(brElm);
                if (tinymce.isIE && "PRE" == parentBlockName && (!documentMode || documentMode < 8)) brElm.parentNode.insertBefore(dom.doc.createTextNode("\r"), brElm);
                if (!extraBr) {
                    rng.setStartAfter(brElm);
                    rng.setEndAfter(brElm);
                } else {
                    rng.setStartBefore(brElm);
                    rng.setEndBefore(brElm);
                }
                selection.setRng(rng);
                undoManager.add();
            }
            function trimLeadingLineBreaks(node) {
                do {
                    if (3 === node.nodeType) node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, "");
                    node = node.firstChild;
                } while (node);
            }
            function getEditableRoot(node) {
                var root = dom.getRoot(), parent, editableRoot;
                parent = node;
                while (parent !== root && "false" !== dom.getContentEditable(parent)) {
                    if ("true" === dom.getContentEditable(parent)) editableRoot = parent;
                    parent = parent.parentNode;
                }
                return parent !== root ? editableRoot : root;
            }
            function addBrToBlockIfNeeded(block) {
                var lastChild;
                if (!tinymce.isIE) {
                    block.normalize();
                    lastChild = block.lastChild;
                    if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, "float", true))) dom.add(block, "br");
                }
            }
            if (!rng.collapsed) {
                editor.execCommand("Delete");
                return;
            }
            if (evt.isDefaultPrevented()) return;
            container = rng.startContainer;
            offset = rng.startOffset;
            newBlockName = (settings.force_p_newlines ? "p" : "") || settings.forced_root_block;
            newBlockName = newBlockName ? newBlockName.toUpperCase() : "";
            documentMode = dom.doc.documentMode;
            shiftKey = evt.shiftKey;
            if (1 == container.nodeType && container.hasChildNodes()) {
                isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
                container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
                if (isAfterLastNodeInContainer && 3 == container.nodeType) offset = container.nodeValue.length; else offset = 0;
            }
            editableRoot = getEditableRoot(container);
            if (!editableRoot) return;
            undoManager.beforeChange();
            if (!dom.isBlock(editableRoot) && editableRoot != dom.getRoot()) {
                if (!newBlockName || shiftKey) insertBr();
                return;
            }
            if (newBlockName && !shiftKey || !newBlockName && shiftKey) container = wrapSelfAndSiblingsInDefaultBlock(container, offset);
            parentBlock = dom.getParent(container, dom.isBlock);
            containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
            parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
            containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
            if ("LI" == containerBlockName && !evt.ctrlKey) {
                parentBlock = containerBlock;
                parentBlockName = containerBlockName;
            }
            if ("LI" == parentBlockName) {
                if (!newBlockName && shiftKey) {
                    insertBr();
                    return;
                }
                if (dom.isEmpty(parentBlock)) {
                    if (/^(UL|OL|LI)$/.test(containerBlock.parentNode.nodeName)) return false;
                    handleEmptyListItem();
                    return;
                }
            }
            if ("PRE" == parentBlockName && false !== settings.br_in_pre) {
                if (!shiftKey) {
                    insertBr();
                    return;
                }
            } else if (!newBlockName && !shiftKey && "LI" != parentBlockName || newBlockName && shiftKey) {
                insertBr();
                return;
            }
            newBlockName = newBlockName || "P";
            if (isCaretAtStartOrEndOfBlock()) {
                if (/^(H[1-6]|PRE)$/.test(parentBlockName) && "HGROUP" != containerBlockName) newBlock = createNewBlock(newBlockName); else newBlock = createNewBlock();
                if (settings.end_container_on_empty_block && canSplitBlock(containerBlock) && dom.isEmpty(parentBlock)) newBlock = dom.split(containerBlock, parentBlock); else dom.insertAfter(newBlock, parentBlock);
                moveToCaretPosition(newBlock);
            } else if (isCaretAtStartOrEndOfBlock(true)) {
                newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
                renderBlockOnIE(newBlock);
            } else {
                tmpRng = rng.cloneRange();
                tmpRng.setEndAfter(parentBlock);
                fragment = tmpRng.extractContents();
                trimLeadingLineBreaks(fragment);
                newBlock = fragment.firstChild;
                dom.insertAfter(fragment, parentBlock);
                trimInlineElementsOnLeftSideOfBlock(newBlock);
                addBrToBlockIfNeeded(parentBlock);
                moveToCaretPosition(newBlock);
            }
            dom.setAttrib(newBlock, "id", "");
            undoManager.add();
        }
        editor.onKeyDown.add(function(ed, evt) {
            if (13 == evt.keyCode) if (false !== handleEnterKey(evt)) evt.preventDefault();
        });
    };
})(tinymce);

(function() {
    var each = tinymce.each, defs = {
        paste_auto_cleanup_on_paste: true,
        paste_enable_default_filters: true,
        paste_block_drop: false,
        paste_retain_style_properties: "none",
        paste_strip_class_attributes: "mso",
        paste_remove_word_images: true,
        paste_remove_spans: false,
        paste_remove_styles: false,
        paste_remove_styles_if_webkit: true,
        paste_convert_middot_lists: true,
        paste_convert_headers_to_strong: false,
        paste_dialog_width: "450",
        paste_dialog_height: "400",
        paste_text_use_dialog: false,
        paste_text_sticky: false,
        paste_text_sticky_default: false,
        paste_text_notifyalways: false,
        paste_text_linebreaktype: "combined",
        paste_text_replacements: [ [ /\u2026/g, "..." ], [ /[\x93\x94\u201c\u201d]/g, '"' ], [ /[\x60\x91\x92\u2018\u2019]/g, "'" ] ]
    };
    function getParam(ed, name) {
        return ed.getParam(name, defs[name]);
    }
    tinymce.create("tinymce.plugins.PastePlugin", {
        init: function(ed, url) {
            var t = this;
            t.editor = ed;
            t.url = url;
            t.onPreProcess = new tinymce.util.Dispatcher(t);
            t.onPostProcess = new tinymce.util.Dispatcher(t);
            t.onPreProcess.add(t._preProcess);
            t.onPostProcess.add(t._postProcess);
            t.onPreProcess.add(function(pl, o) {
                ed.execCallback("paste_preprocess", pl, o);
            });
            t.onPostProcess.add(function(pl, o) {
                ed.execCallback("paste_postprocess", pl, o);
            });
            ed.onKeyDown.addToTop(function(ed, e) {
                if ((tinymce.isMac ? e.metaKey : e.ctrlKey) && 86 == e.keyCode || e.shiftKey && 45 == e.keyCode) return false;
            });
            ed.pasteAsPlainText = getParam(ed, "paste_text_sticky_default");
            function process(o, force_rich) {
                var dom = ed.dom, rng;
                t.onPreProcess.dispatch(t, o);
                o.node = dom.create("div", 0, o.content);
                if (tinymce.isGecko) {
                    rng = ed.selection.getRng(true);
                    if (rng.startContainer == rng.endContainer && 3 == rng.startContainer.nodeType) if (1 === o.node.childNodes.length && /^(p|h[1-6]|pre)$/i.test(o.node.firstChild.nodeName) && o.content.indexOf("__MCE_ITEM__") === -1) dom.remove(o.node.firstChild, true);
                }
                t.onPostProcess.dispatch(t, o);
                o.content = ed.serializer.serialize(o.node, {
                    getInner: 1,
                    forced_root_block: ""
                });
                if (!force_rich && ed.pasteAsPlainText) {
                    t._insertPlainText(o.content);
                    if (!getParam(ed, "paste_text_sticky")) {
                        ed.pasteAsPlainText = false;
                        ed.controlManager.setActive("pastetext", false);
                    }
                } else t._insert(o.content);
            }
            ed.addCommand("mceInsertClipboardContent", function(u, o) {
                process(o, true);
            });
            if (!getParam(ed, "paste_text_use_dialog")) ed.addCommand("mcePasteText", function(u, v) {
                var cookie = tinymce.util.Cookie;
                ed.pasteAsPlainText = !ed.pasteAsPlainText;
                ed.controlManager.setActive("pastetext", ed.pasteAsPlainText);
                if (ed.pasteAsPlainText && !cookie.get("tinymcePasteText")) {
                    if (getParam(ed, "paste_text_sticky")) ed.windowManager.alert(ed.translate("paste.plaintext_mode_sticky")); else ed.windowManager.alert(ed.translate("paste.plaintext_mode"));
                    if (!getParam(ed, "paste_text_notifyalways")) cookie.set("tinymcePasteText", "1", new Date(new Date().getFullYear() + 1, 12, 31));
                }
            });
            ed.addButton("pastetext", {
                title: "paste.paste_text_desc",
                cmd: "mcePasteText"
            });
            ed.addButton("selectall", {
                title: "paste.selectall_desc",
                cmd: "selectall"
            });
            function grabContent(e) {
                var n, or, rng, oldRng, sel = ed.selection, dom = ed.dom, body = ed.getBody(), posY, textContent;
                if (e.clipboardData || dom.doc.dataTransfer) {
                    textContent = (e.clipboardData || dom.doc.dataTransfer).getData("Text");
                    if (ed.pasteAsPlainText) {
                        e.preventDefault();
                        process({
                            content: dom.encode(textContent).replace(/\r?\n/g, "<br />")
                        });
                        return;
                    }
                }
                if (dom.get("_mcePaste")) return;
                n = dom.add(body, "div", {
                    id: "_mcePaste",
                    "class": "mcePaste",
                    "data-mce-bogus": "1"
                }, "﻿﻿");
                if (body != ed.getDoc().body) posY = dom.getPos(ed.selection.getStart(), body).y; else {
                    var vp = dom.getViewPort(ed.getWin());
                    posY = vp.y + vp.h / 2;
                }
                dom.setStyles(n, {
                    position: "absolute",
                    left: tinymce.isGecko ? -40 : 0,
                    top: posY - 25,
                    width: 1,
                    height: 1,
                    overflow: "hidden"
                });
                if (tinymce.isIE) {
                    oldRng = sel.getRng();
                    rng = dom.doc.body.createTextRange();
                    rng.moveToElementText(n);
                    rng.execCommand("Paste");
                    dom.remove(n);
                    if ("﻿﻿" === n.innerHTML) {
                        ed.execCommand("mcePasteWord");
                        e.preventDefault();
                        return;
                    }
                    sel.setRng(oldRng);
                    sel.setContent("");
                    setTimeout(function() {
                        process({
                            content: n.innerHTML
                        });
                    }, 0);
                    return tinymce.dom.Event.cancel(e);
                } else {
                    function block(e) {
                        e.preventDefault();
                    }
                    dom.bind(ed.getDoc(), "mousedown", block);
                    dom.bind(ed.getDoc(), "keydown", block);
                    or = ed.selection.getRng();
                    n = n.firstChild;
                    rng = ed.getDoc().createRange();
                    rng.setStart(n, 0);
                    rng.setEnd(n, 2);
                    sel.setRng(rng);
                    window.setTimeout(function() {
                        var h = "", nl;
                        if (!dom.select("div.mcePaste > div.mcePaste").length) {
                            nl = dom.select("div.mcePaste");
                            each(nl, function(n) {
                                var child = n.firstChild;
                                if (child && "DIV" == child.nodeName && child.style.marginTop && child.style.backgroundColor) dom.remove(child, 1);
                                each(dom.select("span.Apple-style-span", n), function(n) {
                                    dom.remove(n, 1);
                                });
                                each(dom.select("br[data-mce-bogus]", n), function(n) {
                                    dom.remove(n);
                                });
                                if ("mcePaste" != n.parentNode.className) h += n.innerHTML;
                            });
                        } else h = "<p>" + dom.encode(textContent).replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br />") + "</p>";
                        each(dom.select("div.mcePaste"), function(n) {
                            dom.remove(n);
                        });
                        if (or) sel.setRng(or);
                        process({
                            content: h
                        });
                        dom.unbind(ed.getDoc(), "mousedown", block);
                        dom.unbind(ed.getDoc(), "keydown", block);
                    }, 0);
                }
            }
            if (getParam(ed, "paste_auto_cleanup_on_paste")) if (tinymce.isOpera || /Firefox\/2/.test(navigator.userAgent)) ed.onKeyDown.addToTop(function(ed, e) {
                if ((tinymce.isMac ? e.metaKey : e.ctrlKey) && 86 == e.keyCode || e.shiftKey && 45 == e.keyCode) grabContent(e);
            }); else ed.onPaste.addToTop(function(ed, e) {
                return grabContent(e);
            });
            ed.onInit.add(function() {
                ed.controlManager.setActive("pastetext", ed.pasteAsPlainText);
                if (getParam(ed, "paste_block_drop")) ed.dom.bind(ed.getBody(), [ "dragend", "dragover", "draggesture", "dragdrop", "drop", "drag" ], function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                });
            });
            t._legacySupport();
        },
        getInfo: function() {
            return {
                longname: "Paste text/word",
                author: "Moxiecode Systems AB",
                authorurl: "http://tinymce.moxiecode.com",
                infourl: "http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/paste",
                version: tinymce.majorVersion + "." + tinymce.minorVersion
            };
        },
        _preProcess: function(pl, o) {
            var ed = this.editor, h = o.content, grep = tinymce.grep, explode = tinymce.explode, trim = tinymce.trim, len, stripClass;
            function process(items) {
                each(items, function(v) {
                    if (v.constructor == RegExp) h = h.replace(v, ""); else h = h.replace(v[0], v[1]);
                });
            }
            if (false == ed.settings.paste_enable_default_filters) return;
            if (tinymce.isIE && document.documentMode >= 9 && /<(h[1-6r]|p|div|address|pre|form|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|caption|blockquote|center|dl|dt|dd|dir|fieldset)/.test(o.content)) {
                process([ [ /(?:<br>&nbsp;[\s\r\n]+|<br>)*(<\/?(h[1-6r]|p|div|address|pre|form|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|caption|blockquote|center|dl|dt|dd|dir|fieldset)[^>]*>)(?:<br>&nbsp;[\s\r\n]+|<br>)*/g, "$1" ] ]);
                process([ [ /<br><br>/g, "<BR><BR>" ], [ /<br>/g, " " ], [ /<BR><BR>/g, "<br>" ] ]);
            }
            if (/class="?Mso|style="[^"]*\bmso-|w:WordDocument/i.test(h) || o.wordContent) {
                o.wordContent = true;
                process([ /^\s*(&nbsp;)+/gi, /(&nbsp;|<br[^>]*>)+\s*$/gi ]);
                if (getParam(ed, "paste_convert_headers_to_strong")) h = h.replace(/<p [^>]*class="?MsoHeading"?[^>]*>(.*?)<\/p>/gi, "<p><strong>$1</strong></p>");
                if (getParam(ed, "paste_convert_middot_lists")) process([ [ /<!--\[if !supportLists\]-->/gi, "$&__MCE_ITEM__" ], [ /(<span[^>]+(?:mso-list:|:\s*symbol)[^>]+>)/gi, "$1__MCE_ITEM__" ], [ /(<p[^>]+(?:MsoListParagraph)[^>]+>)/gi, "$1__MCE_ITEM__" ] ]);
                if (getParam(ed, "paste_remove_word_images")) process([ /<img[^>]*>/gi ]);
                process([ /<!--[\s\S]+?-->/gi, /<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, [ /<(\/?)s>/gi, "<$1strike>" ], [ /&nbsp;/gi, " " ] ]);
                do {
                    len = h.length;
                    h = h.replace(/(<[a-z][^>]*\s)(?:id|name|language|type|on\w+|\w+:\w+)=(?:"[^"]*"|\w+)\s?/gi, "$1");
                } while (len != h.length);
                if (0 == getParam(ed, "paste_retain_style_properties").replace(/^none$/i, "").length) h = h.replace(/<\/?span[^>]*>/gi, ""); else process([ [ /<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function(str, spaces) {
                    return spaces.length > 0 ? spaces.replace(/./, " ").slice(Math.floor(spaces.length / 2)).split("").join(" ") : "";
                } ], [ /(<[a-z][^>]*)\sstyle="([^"]*)"/gi, function(str, tag, style) {
                    var n = [], i = 0, s = explode(trim(style).replace(/&quot;/gi, "'"), ";");
                    each(s, function(v) {
                        var name, value, parts = explode(v, ":");
                        function ensureUnits(v) {
                            return v + ("0" !== v && /\d$/.test(v)) ? "px" : "";
                        }
                        if (2 == parts.length) {
                            name = parts[0].toLowerCase();
                            value = parts[1].toLowerCase();
                            switch (name) {
                              case "mso-padding-alt":
                              case "mso-padding-top-alt":
                              case "mso-padding-right-alt":
                              case "mso-padding-bottom-alt":
                              case "mso-padding-left-alt":
                              case "mso-margin-alt":
                              case "mso-margin-top-alt":
                              case "mso-margin-right-alt":
                              case "mso-margin-bottom-alt":
                              case "mso-margin-left-alt":
                              case "mso-table-layout-alt":
                              case "mso-height":
                              case "mso-width":
                              case "mso-vertical-align-alt":
                                n[i++] = name.replace(/^mso-|-alt$/g, "") + ":" + ensureUnits(value);
                                return;

                              case "horiz-align":
                                n[i++] = "text-align:" + value;
                                return;

                              case "vert-align":
                                n[i++] = "vertical-align:" + value;
                                return;

                              case "font-color":
                              case "mso-foreground":
                                n[i++] = "color:" + value;
                                return;

                              case "mso-background":
                              case "mso-highlight":
                                n[i++] = "background:" + value;
                                return;

                              case "mso-default-height":
                                n[i++] = "min-height:" + ensureUnits(value);
                                return;

                              case "mso-default-width":
                                n[i++] = "min-width:" + ensureUnits(value);
                                return;

                              case "mso-padding-between-alt":
                                n[i++] = "border-collapse:separate;border-spacing:" + ensureUnits(value);
                                return;

                              case "text-line-through":
                                if ("single" == value || "double" == value) n[i++] = "text-decoration:line-through";
                                return;

                              case "mso-zero-height":
                                if ("yes" == value) n[i++] = "display:none";
                                return;
                            }
                            if (/^(mso|column|font-emph|lang|layout|line-break|list-image|nav|panose|punct|row|ruby|sep|size|src|tab-|table-border|text-(?!align|decor|indent|trans)|top-bar|version|vnd|word-break)/.test(name)) return;
                            n[i++] = name + ":" + parts[1];
                        }
                    });
                    if (i > 0) return tag + ' style="' + n.join(";") + '"'; else return tag;
                } ] ]);
            }
            if (getParam(ed, "paste_convert_headers_to_strong")) process([ [ /<h[1-6][^>]*>/gi, "<p><strong>" ], [ /<\/h[1-6][^>]*>/gi, "</strong></p>" ] ]);
            process([ [ /Version:[\d.]+\nStartHTML:\d+\nEndHTML:\d+\nStartFragment:\d+\nEndFragment:\d+/gi, "" ] ]);
            stripClass = getParam(ed, "paste_strip_class_attributes");
            if ("none" !== stripClass) {
                function removeClasses(match, g1) {
                    if ("all" === stripClass) return "";
                    var cls = grep(explode(g1.replace(/^(["'])(.*)\1$/, "$2"), " "), function(v) {
                        return /^(?!mso)/i.test(v);
                    });
                    return cls.length ? ' class="' + cls.join(" ") + '"' : "";
                }
                h = h.replace(/ class="([^"]+)"/gi, removeClasses);
                h = h.replace(/ class=([\-\w]+)/gi, removeClasses);
            }
            if (getParam(ed, "paste_remove_spans")) h = h.replace(/<\/?span[^>]*>/gi, "");
            o.content = h;
        },
        _postProcess: function(pl, o) {
            var t = this, ed = t.editor, dom = ed.dom, styleProps;
            if (false == ed.settings.paste_enable_default_filters) return;
            if (o.wordContent) {
                each(dom.select("a", o.node), function(a) {
                    if (!a.href || a.href.indexOf("#_Toc") != -1) dom.remove(a, 1);
                });
                if (getParam(ed, "paste_convert_middot_lists")) t._convertLists(pl, o);
                styleProps = getParam(ed, "paste_retain_style_properties");
                if (tinymce.is(styleProps, "string") && "all" !== styleProps && "*" !== styleProps) {
                    styleProps = tinymce.explode(styleProps.replace(/^none$/i, ""));
                    each(dom.select("*", o.node), function(el) {
                        var newStyle = {}, npc = 0, i, sp, sv;
                        if (styleProps) for (i = 0; i < styleProps.length; i++) {
                            sp = styleProps[i];
                            sv = dom.getStyle(el, sp);
                            if (sv) {
                                newStyle[sp] = sv;
                                npc++;
                            }
                        }
                        dom.setAttrib(el, "style", "");
                        if (styleProps && npc > 0) dom.setStyles(el, newStyle); else if ("SPAN" == el.nodeName && !el.className) dom.remove(el, true);
                    });
                }
            }
            if (getParam(ed, "paste_remove_styles") || getParam(ed, "paste_remove_styles_if_webkit") && tinymce.isWebKit) each(dom.select("*[style]", o.node), function(el) {
                el.removeAttribute("style");
                el.removeAttribute("data-mce-style");
            }); else if (tinymce.isWebKit) each(dom.select("*", o.node), function(el) {
                el.removeAttribute("data-mce-style");
            });
        },
        _convertLists: function(pl, o) {
            var dom = pl.editor.dom, listElm, li, lastMargin = -1, margin, levels = [], lastType, html;
            each(dom.select("p", o.node), function(p) {
                var sib, val = "", type, html, idx, parents;
                for (sib = p.firstChild; sib && 3 == sib.nodeType; sib = sib.nextSibling) val += sib.nodeValue;
                val = p.innerHTML.replace(/<\/?\w+[^>]*>/gi, "").replace(/&nbsp;/g, " ");
                if (/^(__MCE_ITEM__)+[\u2022\u00b7\u00a7\u00d8o\u25CF]\s*\u00a0*/.test(val)) type = "ul";
                if (/^__MCE_ITEM__\s*\w+\.\s*\u00a0+/.test(val)) type = "ol";
                if (type) {
                    margin = parseFloat(p.style.marginLeft || 0);
                    if (margin > lastMargin) levels.push(margin);
                    if (!listElm || type != lastType) {
                        listElm = dom.create(type);
                        dom.insertAfter(listElm, p);
                    } else if (margin > lastMargin) listElm = li.appendChild(dom.create(type)); else if (margin < lastMargin) {
                        idx = tinymce.inArray(levels, margin);
                        parents = dom.getParents(listElm.parentNode, type);
                        listElm = parents[parents.length - 1 - idx] || listElm;
                    }
                    each(dom.select("span", p), function(span) {
                        var html = span.innerHTML.replace(/<\/?\w+[^>]*>/gi, "");
                        if ("ul" == type && /^__MCE_ITEM__[\u2022\u00b7\u00a7\u00d8o\u25CF]/.test(html)) dom.remove(span); else if (/^__MCE_ITEM__[\s\S]*\w+\.(&nbsp;|\u00a0)*\s*/.test(html)) dom.remove(span);
                    });
                    html = p.innerHTML;
                    if ("ul" == type) html = p.innerHTML.replace(/__MCE_ITEM__/g, "").replace(/^[\u2022\u00b7\u00a7\u00d8o\u25CF]\s*(&nbsp;|\u00a0)+\s*/, ""); else html = p.innerHTML.replace(/__MCE_ITEM__/g, "").replace(/^\s*\w+\.(&nbsp;|\u00a0)+\s*/, "");
                    li = listElm.appendChild(dom.create("li", 0, html));
                    dom.remove(p);
                    lastMargin = margin;
                    lastType = type;
                } else listElm = lastMargin = 0;
            });
            html = o.node.innerHTML;
            if (html.indexOf("__MCE_ITEM__") != -1) o.node.innerHTML = html.replace(/__MCE_ITEM__/g, "");
        },
        _insert: function(h, skip_undo) {
            var ed = this.editor, r = ed.selection.getRng();
            if (!ed.selection.isCollapsed() && r.startContainer != r.endContainer) ed.getDoc().execCommand("Delete", false, null);
            ed.execCommand("mceInsertContent", false, h, {
                skip_undo: skip_undo
            });
        },
        _insertPlainText: function(content) {
            var ed = this.editor, linebr = getParam(ed, "paste_text_linebreaktype"), rl = getParam(ed, "paste_text_replacements"), is = tinymce.is;
            function process(items) {
                each(items, function(v) {
                    if (v.constructor == RegExp) content = content.replace(v, ""); else content = content.replace(v[0], v[1]);
                });
            }
            if ("string" === typeof content && content.length > 0) {
                if (/<(?:p|br|h[1-6]|ul|ol|dl|table|t[rdh]|div|blockquote|fieldset|pre|address|center)[^>]*>/i.test(content)) process([ /[\n\r]+/g ]); else process([ /\r+/g ]);
                process([ [ /<\/(?:p|h[1-6]|ul|ol|dl|table|div|blockquote|fieldset|pre|address|center)>/gi, "\n\n" ], [ /<br[^>]*>|<\/tr>/gi, "\n" ], [ /<\/t[dh]>\s*<t[dh][^>]*>/gi, "	" ], /<[a-z!\/?][^>]*>/gi, [ /&nbsp;/gi, " " ], [ /(?:(?!\n)\s)*(\n+)(?:(?!\n)\s)*/gi, "$1" ], [ /\n{3,}/g, "\n\n" ] ]);
                content = ed.dom.decode(tinymce.html.Entities.encodeRaw(content));
                if (is(rl, "array")) process(rl); else if (is(rl, "string")) process(new RegExp(rl, "gi"));
                if ("none" == linebr) process([ [ /\n+/g, " " ] ]); else if ("br" == linebr) process([ [ /\n/g, "<br />" ] ]); else if ("p" == linebr) process([ [ /\n+/g, "</p><p>" ], [ /^(.*<\/p>)(<p>)$/, "<p>$1" ] ]); else process([ [ /\n\n/g, "</p><p>" ], [ /^(.*<\/p>)(<p>)$/, "<p>$1" ], [ /\n/g, "<br />" ] ]);
                ed.execCommand("mceInsertContent", false, content);
            }
        },
        _legacySupport: function() {
            var t = this, ed = t.editor;
            ed.addCommand("mcePasteWord", function() {
                ed.windowManager.open({
                    file: t.url + "/pasteword.htm",
                    width: parseInt(getParam(ed, "paste_dialog_width")),
                    height: parseInt(getParam(ed, "paste_dialog_height")),
                    inline: 1
                });
            });
            if (getParam(ed, "paste_text_use_dialog")) ed.addCommand("mcePasteText", function() {
                ed.windowManager.open({
                    file: t.url + "/pastetext.htm",
                    width: parseInt(getParam(ed, "paste_dialog_width")),
                    height: parseInt(getParam(ed, "paste_dialog_height")),
                    inline: 1
                });
            });
            ed.addButton("pasteword", {
                title: "paste.paste_word_desc",
                cmd: "mcePasteWord"
            });
        }
    });
    tinymce.PluginManager.add("paste", tinymce.plugins.PastePlugin);
})();

(function($) {
    $.fn.farbtastic = function(options) {
        $.farbtastic(this, options);
        return this;
    };
    $.farbtastic = function(container, callback) {
        var container = $(container).get(0);
        return container.farbtastic || (container.farbtastic = new $._farbtastic(container, callback));
    };
    $._farbtastic = function(container, callback) {
        var fb = this;
        $(container).html('<div class="farbtastic"><div class="color"></div><div class="wheel"></div><div class="overlay"></div><div class="h-marker marker"></div><div class="sl-marker marker"></div></div>');
        var e = $(".farbtastic", container);
        fb.wheel = $(".wheel", container).get(0);
        fb.radius = 84;
        fb.square = 100;
        fb.width = 194;
        fb.firstClick = true;
        if (navigator.appVersion.match(/MSIE [0-6]\./)) $("*", e).each(function() {
            if ("none" != this.currentStyle.backgroundImage) {
                var image = this.currentStyle.backgroundImage;
                image = this.currentStyle.backgroundImage.substring(5, image.length - 2);
                $(this).css({
                    backgroundImage: "none",
                    filter: "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=crop, src='" + image + "')"
                });
            }
        });
        fb.linkTo = function(callback) {
            if ("object" == typeof fb.callback) $(fb.callback).unbind("keyup", fb.updateValue);
            fb.color = null;
            if ("function" == typeof callback) fb.callback = callback; else if ("object" == typeof callback || "string" == typeof callback) {
                fb.callback = $(callback);
                fb.callback.bind("keyup", fb.updateValue);
                if (fb.callback.get(0).value) fb.setColor(fb.callback.get(0).value);
            }
            return this;
        };
        fb.updateValue = function(event) {
            if (this.value && this.value != fb.color) fb.setColor(this.value);
        };
        fb.setColor = function(color) {
            var unpack = fb.unpack(color);
            if (fb.color != color && unpack) {
                fb.color = color;
                fb.rgb = unpack;
                fb.hsl = fb.RGBToHSL(fb.rgb);
                fb.updateDisplay();
            }
            return this;
        };
        fb.setHSL = function(hsl) {
            fb.hsl = hsl;
            fb.rgb = fb.HSLToRGB(hsl);
            fb.color = fb.pack(fb.rgb);
            fb.updateDisplay();
            return this;
        };
        fb.widgetCoords = function(event) {
            var offset = $(fb.wheel).offset();
            return {
                x: event.pageX - offset.left - fb.width / 2,
                y: event.pageY - offset.top - fb.width / 2
            };
        };
        fb.mousedown = function(event) {
            if (!document.dragging) {
                $(document).bind("mousemove", fb.mousemove).bind("mouseup", fb.mouseup);
                document.dragging = true;
            }
            var pos = fb.widgetCoords(event);
            fb.circleDrag = 2 * Math.max(Math.abs(pos.x), Math.abs(pos.y)) > fb.square;
            fb.mousemove(event);
            return false;
        };
        fb.mousemove = function(event) {
            var pos = fb.widgetCoords(event);
            if (fb.circleDrag) {
                var hue = Math.atan2(pos.x, -pos.y) / 6.28;
                if (hue < 0) hue += 1;
                if (fb.firstClick && (0 == fb.hsl[2] || 1 == fb.hsl[2])) {
                    fb.firstClick = false;
                    fb.setHSL([ hue, 1, .5 ]);
                } else fb.setHSL([ hue, fb.hsl[1], fb.hsl[2] ]);
            } else {
                var sat = Math.max(0, Math.min(1, -(pos.x / fb.square) + .5));
                var lum = Math.max(0, Math.min(1, -(pos.y / fb.square) + .5));
                fb.setHSL([ fb.hsl[0], sat, lum ]);
            }
            return false;
        };
        fb.mouseup = function() {
            $(document).unbind("mousemove", fb.mousemove);
            $(document).unbind("mouseup", fb.mouseup);
            document.dragging = false;
        };
        fb.updateDisplay = function() {
            var angle = 6.28 * fb.hsl[0];
            $(".h-marker", e).css({
                left: Math.round(Math.sin(angle) * fb.radius + fb.width / 2) + "px",
                top: Math.round(-Math.cos(angle) * fb.radius + fb.width / 2) + "px"
            });
            $(".sl-marker", e).css({
                left: Math.round(fb.square * (.5 - fb.hsl[1]) + fb.width / 2) + "px",
                top: Math.round(fb.square * (.5 - fb.hsl[2]) + fb.width / 2) + "px"
            });
            $(".color", e).css("backgroundColor", fb.pack(fb.HSLToRGB([ fb.hsl[0], 1, .5 ])));
            if ("object" == typeof fb.callback) {
                $(fb.callback).css({
                    backgroundColor: fb.color,
                    color: fb.hsl[2] > .5 ? "#000" : "#fff"
                });
                $(fb.callback).each(function() {
                    if (this.value && this.value != fb.color) this.value = fb.color;
                });
            } else if ("function" == typeof fb.callback) fb.callback.call(fb, fb.color);
        };
        fb.pack = function(rgb) {
            var r = Math.round(255 * rgb[0]);
            var g = Math.round(255 * rgb[1]);
            var b = Math.round(255 * rgb[2]);
            return "#" + (r < 16 ? "0" : "") + r.toString(16) + (g < 16 ? "0" : "") + g.toString(16) + (b < 16 ? "0" : "") + b.toString(16);
        };
        fb.unpack = function(color) {
            if (7 == color.length) return [ parseInt("0x" + color.substring(1, 3)) / 255, parseInt("0x" + color.substring(3, 5)) / 255, parseInt("0x" + color.substring(5, 7)) / 255 ]; else if (4 == color.length) return [ parseInt("0x" + color.substring(1, 2)) / 15, parseInt("0x" + color.substring(2, 3)) / 15, parseInt("0x" + color.substring(3, 4)) / 15 ];
        };
        fb.HSLToRGB = function(hsl) {
            var m1, m2, r, g, b;
            var h = hsl[0], s = hsl[1], l = hsl[2];
            m2 = l <= .5 ? l * (s + 1) : l + s - l * s;
            m1 = 2 * l - m2;
            return [ this.hueToRGB(m1, m2, h + .33333), this.hueToRGB(m1, m2, h), this.hueToRGB(m1, m2, h - .33333) ];
        };
        fb.hueToRGB = function(m1, m2, h) {
            h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
            if (6 * h < 1) return m1 + 6 * (m2 - m1) * h;
            if (2 * h < 1) return m2;
            if (3 * h < 2) return m1 + 6 * (m2 - m1) * (.66666 - h);
            return m1;
        };
        fb.RGBToHSL = function(rgb) {
            var min, max, delta, h, s, l;
            var r = rgb[0], g = rgb[1], b = rgb[2];
            min = Math.min(r, Math.min(g, b));
            max = Math.max(r, Math.max(g, b));
            delta = max - min;
            l = (min + max) / 2;
            s = 0;
            if (l > 0 && l < 1) s = delta / (l < .5 ? 2 * l : 2 - 2 * l);
            h = 0;
            if (delta > 0) {
                if (max == r && max != g) h += (g - b) / delta;
                if (max == g && max != b) h += 2 + (b - r) / delta;
                if (max == b && max != r) h += 4 + (r - g) / delta;
                h /= 6;
            }
            return [ h, s, l ];
        };
        $("*", e).mousedown(fb.mousedown);
        fb.setColor("#000000");
        if (callback) fb.linkTo(callback);
    };
})(jQuery);

(function() {
    var count = 0, runtimes = [], i18n = {}, mimes = {}, xmlEncodeChars = {
        "<": "lt",
        ">": "gt",
        "&": "amp",
        '"': "quot",
        "'": "#39"
    }, xmlEncodeRegExp = /[<>&\"\']/g, undef, delay = window.setTimeout, eventhash = {}, uid;
    function preventDefault() {
        this.returnValue = false;
    }
    function stopPropagation() {
        this.cancelBubble = true;
    }
    (function(mime_data) {
        var items = mime_data.split(/,/), i, y, ext;
        for (i = 0; i < items.length; i += 2) {
            ext = items[i + 1].split(/ /);
            for (y = 0; y < ext.length; y++) mimes[ext[y]] = items[i];
        }
    })("application/msword,doc dot," + "application/pdf,pdf," + "application/pgp-signature,pgp," + "application/postscript,ps ai eps," + "application/rtf,rtf," + "application/vnd.ms-excel,xls xlb," + "application/vnd.ms-powerpoint,ppt pps pot," + "application/zip,zip," + "application/x-shockwave-flash,swf swfl," + "application/vnd.openxmlformats-officedocument.wordprocessingml.document,docx," + "application/vnd.openxmlformats-officedocument.wordprocessingml.template,dotx," + "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,xlsx," + "application/vnd.openxmlformats-officedocument.presentationml.presentation,pptx," + "application/vnd.openxmlformats-officedocument.presentationml.template,potx," + "application/vnd.openxmlformats-officedocument.presentationml.slideshow,ppsx," + "application/x-javascript,js," + "application/json,json," + "audio/mpeg,mpga mpega mp2 mp3," + "audio/x-wav,wav," + "audio/mp4,m4a," + "image/bmp,bmp," + "image/gif,gif," + "image/jpeg,jpeg jpg jpe," + "image/photoshop,psd," + "image/png,png," + "image/svg+xml,svg svgz," + "image/tiff,tiff tif," + "text/plain,asc txt text diff log," + "text/html,htm html xhtml," + "text/css,css," + "text/csv,csv," + "text/rtf,rtf," + "video/mpeg,mpeg mpg mpe," + "video/quicktime,qt mov," + "video/mp4,mp4," + "video/x-m4v,m4v," + "video/x-flv,flv," + "video/x-ms-wmv,wmv," + "video/avi,avi," + "video/webm,webm," + "video/vnd.rn-realvideo,rv," + "application/vnd.oasis.opendocument.formula-template,otf," + "application/octet-stream,exe");
    var plupload = {
        VERSION: "@@version@@",
        STOPPED: 1,
        STARTED: 2,
        QUEUED: 1,
        UPLOADING: 2,
        FAILED: 4,
        DONE: 5,
        GENERIC_ERROR: -100,
        HTTP_ERROR: -200,
        IO_ERROR: -300,
        SECURITY_ERROR: -400,
        INIT_ERROR: -500,
        FILE_SIZE_ERROR: -600,
        FILE_EXTENSION_ERROR: -601,
        IMAGE_FORMAT_ERROR: -700,
        IMAGE_MEMORY_ERROR: -701,
        IMAGE_DIMENSIONS_ERROR: -702,
        mimeTypes: mimes,
        ua: function() {
            var nav = navigator, userAgent = nav.userAgent, vendor = nav.vendor, webkit, opera, safari;
            webkit = /WebKit/.test(userAgent);
            safari = webkit && vendor.indexOf("Apple") !== -1;
            opera = window.opera && window.opera.buildNumber;
            return {
                windows: navigator.platform.indexOf("Win") !== -1,
                ie: !webkit && !opera && /MSIE/gi.test(userAgent) && /Explorer/gi.test(nav.appName),
                webkit: webkit,
                gecko: !webkit && /Gecko/.test(userAgent),
                safari: safari,
                opera: !!opera
            };
        }(),
        typeOf: function(o) {
            return {}.toString.call(o).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
        },
        extend: function(target) {
            plupload.each(arguments, function(arg, i) {
                if (i > 0) plupload.each(arg, function(value, key) {
                    target[key] = value;
                });
            });
            return target;
        },
        cleanName: function(name) {
            var i, lookup;
            lookup = [ /[\300-\306]/g, "A", /[\340-\346]/g, "a", /\307/g, "C", /\347/g, "c", /[\310-\313]/g, "E", /[\350-\353]/g, "e", /[\314-\317]/g, "I", /[\354-\357]/g, "i", /\321/g, "N", /\361/g, "n", /[\322-\330]/g, "O", /[\362-\370]/g, "o", /[\331-\334]/g, "U", /[\371-\374]/g, "u" ];
            for (i = 0; i < lookup.length; i += 2) name = name.replace(lookup[i], lookup[i + 1]);
            name = name.replace(/\s+/g, "_");
            name = name.replace(/[^a-z0-9_\-\.]+/gi, "");
            return name;
        },
        addRuntime: function(name, runtime) {
            runtime.name = name;
            runtimes[name] = runtime;
            runtimes.push(runtime);
            return runtime;
        },
        guid: function() {
            var guid = new Date().getTime().toString(32), i;
            for (i = 0; i < 5; i++) guid += Math.floor(65535 * Math.random()).toString(32);
            return (plupload.guidPrefix || "p") + guid + (count++).toString(32);
        },
        buildUrl: function(url, items) {
            var query = "";
            plupload.each(items, function(value, name) {
                query += (query ? "&" : "") + encodeURIComponent(name) + "=" + encodeURIComponent(value);
            });
            if (query) url += (url.indexOf("?") > 0 ? "&" : "?") + query;
            return url;
        },
        each: function(obj, callback) {
            var length, key, i;
            if (obj) {
                length = obj.length;
                if (length === undef) {
                    for (key in obj) if (obj.hasOwnProperty(key)) if (false === callback(obj[key], key)) return;
                } else for (i = 0; i < length; i++) if (false === callback(obj[i], i)) return;
            }
        },
        formatSize: function(size) {
            if (size === undef || /\D/.test(size)) return plupload.translate("N/A");
            if (size > 1073741824) return Math.round(size / 1073741824, 1) + " GB";
            if (size > 1048576) return Math.round(size / 1048576, 1) + " MB";
            if (size > 1024) return Math.round(size / 1024, 1) + " KB";
            return size + " b";
        },
        getPos: function(node, root) {
            var x = 0, y = 0, parent, doc = document, nodeRect, rootRect;
            node = node;
            root = root || doc.body;
            function getIEPos(node) {
                var bodyElm, rect, x = 0, y = 0;
                if (node) {
                    rect = node.getBoundingClientRect();
                    bodyElm = "CSS1Compat" === doc.compatMode ? doc.documentElement : doc.body;
                    x = rect.left + bodyElm.scrollLeft;
                    y = rect.top + bodyElm.scrollTop;
                }
                return {
                    x: x,
                    y: y
                };
            }
            if (node && node.getBoundingClientRect && navigator.userAgent.indexOf("MSIE") > 0 && doc.documentMode < 8) {
                nodeRect = getIEPos(node);
                rootRect = getIEPos(root);
                return {
                    x: nodeRect.x - rootRect.x,
                    y: nodeRect.y - rootRect.y
                };
            }
            parent = node;
            while (parent && parent != root && parent.nodeType) {
                x += parent.offsetLeft || 0;
                y += parent.offsetTop || 0;
                parent = parent.offsetParent;
            }
            parent = node.parentNode;
            while (parent && parent != root && parent.nodeType) {
                x -= parent.scrollLeft || 0;
                y -= parent.scrollTop || 0;
                parent = parent.parentNode;
            }
            return {
                x: x,
                y: y
            };
        },
        getSize: function(node) {
            return {
                w: node.offsetWidth || node.clientWidth,
                h: node.offsetHeight || node.clientHeight
            };
        },
        parseSize: function(size) {
            var mul;
            if ("string" == typeof size) {
                size = /^([0-9]+)([mgk]?)$/.exec(size.toLowerCase().replace(/[^0-9mkg]/g, ""));
                mul = size[2];
                size = +size[1];
                if ("g" == mul) size *= 1073741824;
                if ("m" == mul) size *= 1048576;
                if ("k" == mul) size *= 1024;
            }
            return size;
        },
        xmlEncode: function(str) {
            return str ? ("" + str).replace(xmlEncodeRegExp, function(chr) {
                return xmlEncodeChars[chr] ? "&" + xmlEncodeChars[chr] + ";" : chr;
            }) : str;
        },
        toArray: function(obj) {
            var i, arr = [];
            for (i = 0; i < obj.length; i++) arr[i] = obj[i];
            return arr;
        },
        inArray: function(needle, array) {
            if (array) {
                if (Array.prototype.indexOf) return Array.prototype.indexOf.call(array, needle);
                for (var i = 0, length = array.length; i < length; i++) if (array[i] === needle) return i;
            }
            return -1;
        },
        addI18n: function(pack) {
            return plupload.extend(i18n, pack);
        },
        translate: function(str) {
            return i18n[str] || str;
        },
        isEmptyObj: function(obj) {
            if (obj === undef) return true;
            for (var prop in obj) return false;
            return true;
        },
        hasClass: function(obj, name) {
            var regExp;
            if ("" == obj.className) return false;
            regExp = new RegExp("(^|\\s+)" + name + "(\\s+|$)");
            return regExp.test(obj.className);
        },
        addClass: function(obj, name) {
            if (!plupload.hasClass(obj, name)) obj.className = "" == obj.className ? name : obj.className.replace(/\s+$/, "") + " " + name;
        },
        removeClass: function(obj, name) {
            var regExp = new RegExp("(^|\\s+)" + name + "(\\s+|$)");
            obj.className = obj.className.replace(regExp, function($0, $1, $2) {
                return " " === $1 && " " === $2 ? " " : "";
            });
        },
        getStyle: function(obj, name) {
            if (obj.currentStyle) return obj.currentStyle[name]; else if (window.getComputedStyle) {
                var style = window.getComputedStyle(obj, null);
                return style ? style[name] : void 0;
            }
        },
        addEvent: function(obj, name, callback) {
            var func, events, types, key;
            key = arguments[3];
            name = name.toLowerCase();
            if (uid === undef) uid = "Plupload_" + plupload.guid();
            if (obj.addEventListener) {
                func = callback;
                obj.addEventListener(name, func, false);
            } else if (obj.attachEvent) {
                func = function() {
                    var evt = window.event;
                    if (!evt.target) evt.target = evt.srcElement;
                    evt.preventDefault = preventDefault;
                    evt.stopPropagation = stopPropagation;
                    callback(evt);
                };
                obj.attachEvent("on" + name, func);
            }
            if (obj[uid] === undef) obj[uid] = plupload.guid();
            if (!eventhash.hasOwnProperty(obj[uid])) eventhash[obj[uid]] = {};
            events = eventhash[obj[uid]];
            if (!events.hasOwnProperty(name)) events[name] = [];
            events[name].push({
                func: func,
                orig: callback,
                key: key
            });
        },
        removeEvent: function(obj, name) {
            var type, callback, key;
            if ("function" == typeof arguments[2]) callback = arguments[2]; else key = arguments[2];
            name = name.toLowerCase();
            if (obj[uid] && eventhash[obj[uid]] && eventhash[obj[uid]][name]) type = eventhash[obj[uid]][name]; else return;
            for (var i = type.length - 1; i >= 0; i--) if (type[i].key === key || type[i].orig === callback) {
                if (obj.removeEventListener) obj.removeEventListener(name, type[i].func, false); else if (obj.detachEvent) obj.detachEvent("on" + name, type[i].func);
                type[i].orig = null;
                type[i].func = null;
                type.splice(i, 1);
                if (callback !== undef) break;
            }
            if (!type.length) delete eventhash[obj[uid]][name];
            if (plupload.isEmptyObj(eventhash[obj[uid]])) {
                delete eventhash[obj[uid]];
                try {
                    delete obj[uid];
                } catch (e) {
                    obj[uid] = undef;
                }
            }
        },
        removeAllEvents: function(obj) {
            var key = arguments[1];
            if (obj[uid] === undef || !obj[uid]) return;
            plupload.each(eventhash[obj[uid]], function(events, name) {
                plupload.removeEvent(obj, name, key);
            });
        }
    };
    plupload.Uploader = function(settings) {
        var events = {}, total, files = [], startTime, disabled = false;
        total = new plupload.QueueProgress();
        settings = plupload.extend({
            chunk_size: 0,
            multipart: true,
            multi_selection: true,
            file_data_name: "file",
            filters: []
        }, settings);
        function uploadNext() {
            var file, count = 0, i;
            if (this.state == plupload.STARTED) {
                for (i = 0; i < files.length; i++) if (!file && files[i].status == plupload.QUEUED) {
                    file = files[i];
                    file.status = plupload.UPLOADING;
                    if (this.trigger("BeforeUpload", file)) this.trigger("UploadFile", file);
                } else count++;
                if (count == files.length) {
                    this.stop();
                    this.trigger("UploadComplete", files);
                }
            }
        }
        function calc() {
            var i, file;
            total.reset();
            for (i = 0; i < files.length; i++) {
                file = files[i];
                if (file.size !== undef) {
                    total.size += file.size;
                    total.loaded += file.loaded;
                } else total.size = undef;
                if (file.status == plupload.DONE) total.uploaded++; else if (file.status == plupload.FAILED) total.failed++; else total.queued++;
            }
            if (total.size === undef) total.percent = files.length > 0 ? Math.ceil(100 * (total.uploaded / files.length)) : 0; else {
                total.bytesPerSec = Math.ceil(total.loaded / ((+new Date() - startTime || 1) / 1e3));
                total.percent = total.size > 0 ? Math.ceil(100 * (total.loaded / total.size)) : 0;
            }
        }
        plupload.extend(this, {
            state: plupload.STOPPED,
            runtime: "",
            features: {},
            files: files,
            settings: settings,
            total: total,
            id: plupload.guid(),
            init: function() {
                var self = this, i, runtimeList, a, runTimeIndex = 0, items;
                if ("function" == typeof settings.preinit) settings.preinit(self); else plupload.each(settings.preinit, function(func, name) {
                    self.bind(name, func);
                });
                settings.page_url = settings.page_url || document.location.pathname.replace(/\/[^\/]+$/g, "/");
                if (!/^(\w+:\/\/|\/)/.test(settings.url)) settings.url = settings.page_url + settings.url;
                settings.chunk_size = plupload.parseSize(settings.chunk_size);
                settings.max_file_size = plupload.parseSize(settings.max_file_size);
                self.bind("FilesAdded", function(up, selected_files) {
                    var i, file, count = 0, extensionsRegExp, filters = settings.filters;
                    if (filters && filters.length) {
                        extensionsRegExp = [];
                        plupload.each(filters, function(filter) {
                            plupload.each(filter.extensions.split(/,/), function(ext) {
                                if (/^\s*\*\s*$/.test(ext)) extensionsRegExp.push("\\.*"); else extensionsRegExp.push("\\." + ext.replace(new RegExp("[" + "/^$.*+?|()[]{}\\".replace(/./g, "\\$&") + "]", "g"), "\\$&"));
                            });
                        });
                        extensionsRegExp = new RegExp(extensionsRegExp.join("|") + "$", "i");
                    }
                    for (i = 0; i < selected_files.length; i++) {
                        file = selected_files[i];
                        file.loaded = 0;
                        file.percent = 0;
                        file.status = plupload.QUEUED;
                        if (extensionsRegExp && !extensionsRegExp.test(file.name)) {
                            up.trigger("Error", {
                                code: plupload.FILE_EXTENSION_ERROR,
                                message: plupload.translate("File extension error."),
                                file: file
                            });
                            continue;
                        }
                        if (file.size !== undef && file.size > settings.max_file_size) {
                            up.trigger("Error", {
                                code: plupload.FILE_SIZE_ERROR,
                                message: plupload.translate("File size error."),
                                file: file
                            });
                            continue;
                        }
                        files.push(file);
                        count++;
                    }
                    if (count) delay(function() {
                        self.trigger("QueueChanged");
                        self.refresh();
                    }, 1); else return false;
                });
                if (settings.unique_names) self.bind("UploadFile", function(up, file) {
                    var matches = file.name.match(/\.([^.]+)$/), ext = "tmp";
                    if (matches) ext = matches[1];
                    file.target_name = file.id + "." + ext;
                });
                self.bind("UploadProgress", function(up, file) {
                    file.percent = file.size > 0 ? Math.ceil(100 * (file.loaded / file.size)) : 100;
                    calc();
                });
                self.bind("StateChanged", function(up) {
                    if (up.state == plupload.STARTED) startTime = +new Date(); else if (up.state == plupload.STOPPED) for (i = up.files.length - 1; i >= 0; i--) if (up.files[i].status == plupload.UPLOADING) {
                        up.files[i].status = plupload.QUEUED;
                        calc();
                    }
                });
                self.bind("QueueChanged", calc);
                self.bind("Error", function(up, err) {
                    if (err.file) {
                        err.file.status = plupload.FAILED;
                        calc();
                        if (up.state == plupload.STARTED) delay(function() {
                            uploadNext.call(self);
                        }, 1);
                    }
                });
                self.bind("FileUploaded", function(up, file) {
                    file.status = plupload.DONE;
                    file.loaded = file.size;
                    up.trigger("UploadProgress", file);
                    delay(function() {
                        uploadNext.call(self);
                    }, 1);
                });
                if (settings.runtimes) {
                    runtimeList = [];
                    items = settings.runtimes.split(/\s?,\s?/);
                    for (i = 0; i < items.length; i++) if (runtimes[items[i]]) runtimeList.push(runtimes[items[i]]);
                } else runtimeList = runtimes;
                function callNextInit() {
                    var runtime = runtimeList[runTimeIndex++], features, requiredFeatures, i;
                    if (runtime) {
                        features = runtime.getFeatures();
                        requiredFeatures = self.settings.required_features;
                        if (requiredFeatures) {
                            requiredFeatures = requiredFeatures.split(",");
                            for (i = 0; i < requiredFeatures.length; i++) if (!features[requiredFeatures[i]]) {
                                callNextInit();
                                return;
                            }
                        }
                        runtime.init(self, function(res) {
                            if (res && res.success) {
                                self.features = features;
                                self.runtime = runtime.name;
                                self.trigger("Init", {
                                    runtime: runtime.name
                                });
                                self.trigger("PostInit");
                                self.refresh();
                            } else callNextInit();
                        });
                    } else self.trigger("Error", {
                        code: plupload.INIT_ERROR,
                        message: plupload.translate("Init error.")
                    });
                }
                callNextInit();
                if ("function" == typeof settings.init) settings.init(self); else plupload.each(settings.init, function(func, name) {
                    self.bind(name, func);
                });
            },
            refresh: function() {
                this.trigger("Refresh");
            },
            start: function() {
                if (files.length && this.state != plupload.STARTED) {
                    this.state = plupload.STARTED;
                    this.trigger("StateChanged");
                    uploadNext.call(this);
                }
            },
            stop: function() {
                if (this.state != plupload.STOPPED) {
                    this.state = plupload.STOPPED;
                    this.trigger("CancelUpload");
                    this.trigger("StateChanged");
                }
            },
            disableBrowse: function() {
                disabled = arguments[0] !== undef ? arguments[0] : true;
                this.trigger("DisableBrowse", disabled);
            },
            getFile: function(id) {
                var i;
                for (i = files.length - 1; i >= 0; i--) if (files[i].id === id) return files[i];
            },
            removeFile: function(file) {
                var i;
                for (i = files.length - 1; i >= 0; i--) if (files[i].id === file.id) return this.splice(i, 1)[0];
            },
            splice: function(start, length) {
                var removed;
                removed = files.splice(start === undef ? 0 : start, length === undef ? files.length : length);
                this.trigger("FilesRemoved", removed);
                this.trigger("QueueChanged");
                return removed;
            },
            trigger: function(name) {
                var list = events[name.toLowerCase()], i, args;
                if (list) {
                    args = Array.prototype.slice.call(arguments);
                    args[0] = this;
                    for (i = 0; i < list.length; i++) if (false === list[i].func.apply(list[i].scope, args)) return false;
                }
                return true;
            },
            hasEventListener: function(name) {
                return !!events[name.toLowerCase()];
            },
            bind: function(name, func, scope) {
                var list;
                name = name.toLowerCase();
                list = events[name] || [];
                list.push({
                    func: func,
                    scope: scope || this
                });
                events[name] = list;
            },
            unbind: function(name) {
                name = name.toLowerCase();
                var list = events[name], i, func = arguments[1];
                if (list) {
                    if (func !== undef) {
                        for (i = list.length - 1; i >= 0; i--) if (list[i].func === func) {
                            list.splice(i, 1);
                            break;
                        }
                    } else list = [];
                    if (!list.length) delete events[name];
                }
            },
            unbindAll: function() {
                var self = this;
                plupload.each(events, function(list, name) {
                    self.unbind(name);
                });
            },
            destroy: function() {
                this.stop();
                this.trigger("Destroy");
                this.unbindAll();
            }
        });
    };
    plupload.File = function(id, name, size) {
        var self = this;
        self.id = id;
        self.name = name;
        self.size = size;
        self.loaded = 0;
        self.percent = 0;
        self.status = 0;
    };
    plupload.Runtime = function() {
        this.getFeatures = function() {};
        this.init = function(uploader, callback) {};
    };
    plupload.QueueProgress = function() {
        var self = this;
        self.size = 0;
        self.loaded = 0;
        self.uploaded = 0;
        self.failed = 0;
        self.queued = 0;
        self.percent = 0;
        self.bytesPerSec = 0;
        self.reset = function() {
            self.size = self.loaded = self.uploaded = self.failed = self.queued = self.percent = self.bytesPerSec = 0;
        };
    };
    plupload.runtimes = {};
    window.plupload = plupload;
})();

(function(window, document, plupload, undef) {
    var uploadInstances = {}, initialized = {};
    function jsonSerialize(obj) {
        var value, type = typeof obj, isArray, i, key;
        if (obj === undef || null === obj) return "null";
        if ("string" === type) {
            value = "\bb	t\nn\ff\rr\"\"''\\\\";
            return '"' + obj.replace(/([\u0080-\uFFFF\x00-\x1f\"])/g, function(a, b) {
                var idx = value.indexOf(b);
                if (idx + 1) return "\\" + value.charAt(idx + 1);
                a = b.charCodeAt().toString(16);
                return "\\u" + "0000".substring(a.length) + a;
            }) + '"';
        }
        if ("object" == type) {
            isArray = obj.length !== undef;
            value = "";
            if (isArray) {
                for (i = 0; i < obj.length; i++) {
                    if (value) value += ",";
                    value += jsonSerialize(obj[i]);
                }
                value = "[" + value + "]";
            } else {
                for (key in obj) if (obj.hasOwnProperty(key)) {
                    if (value) value += ",";
                    value += jsonSerialize(key) + ":" + jsonSerialize(obj[key]);
                }
                value = "{" + value + "}";
            }
            return value;
        }
        return "" + obj;
    }
    function isInstalled(version) {
        var isVersionSupported = false, container = null, control = null, actualVer, actualVerArray, reqVerArray, requiredVersionPart, actualVersionPart, index = 0;
        try {
            try {
                control = new ActiveXObject("AgControl.AgControl");
                if (control.IsVersionSupported(version)) isVersionSupported = true;
                control = null;
            } catch (e) {
                var plugin = navigator.plugins["Silverlight Plug-In"];
                if (plugin) {
                    actualVer = plugin.description;
                    if ("1.0.30226.2" === actualVer) actualVer = "2.0.30226.2";
                    actualVerArray = actualVer.split(".");
                    while (actualVerArray.length > 3) actualVerArray.pop();
                    while (actualVerArray.length < 4) actualVerArray.push(0);
                    reqVerArray = version.split(".");
                    while (reqVerArray.length > 4) reqVerArray.pop();
                    do {
                        requiredVersionPart = parseInt(reqVerArray[index], 10);
                        actualVersionPart = parseInt(actualVerArray[index], 10);
                        index++;
                    } while (index < reqVerArray.length && requiredVersionPart === actualVersionPart);
                    if (requiredVersionPart <= actualVersionPart && !isNaN(requiredVersionPart)) isVersionSupported = true;
                }
            }
        } catch (e2) {
            isVersionSupported = false;
        }
        return isVersionSupported;
    }
    plupload.silverlight = {
        trigger: function(id, name) {
            var uploader = uploadInstances[id], i, args;
            if (uploader) {
                args = plupload.toArray(arguments).slice(1);
                args[0] = "Silverlight:" + name;
                setTimeout(function() {
                    uploader.trigger.apply(uploader, args);
                }, 0);
            }
        }
    };
    plupload.runtimes.Silverlight = plupload.addRuntime("silverlight", {
        getFeatures: function() {
            return {
                jpgresize: true,
                pngresize: true,
                chunks: true,
                progress: true,
                multipart: true,
                multi_selection: true
            };
        },
        init: function(uploader, callback) {
            var silverlightContainer, filter = "", filters = uploader.settings.filters, i, container = document.body;
            if (!isInstalled("2.0.31005.0") || window.opera && window.opera.buildNumber) {
                callback({
                    success: false
                });
                return;
            }
            initialized[uploader.id] = false;
            uploadInstances[uploader.id] = uploader;
            silverlightContainer = document.createElement("div");
            silverlightContainer.id = uploader.id + "_silverlight_container";
            plupload.extend(silverlightContainer.style, {
                position: "absolute",
                top: "0px",
                background: uploader.settings.shim_bgcolor || "transparent",
                zIndex: 99999,
                width: "100px",
                height: "100px",
                overflow: "hidden",
                opacity: uploader.settings.shim_bgcolor || document.documentMode > 8 ? "" : .01
            });
            silverlightContainer.className = "plupload silverlight";
            if (uploader.settings.container) {
                container = document.getElementById(uploader.settings.container);
                if ("static" === plupload.getStyle(container, "position")) container.style.position = "relative";
            }
            container.appendChild(silverlightContainer);
            for (i = 0; i < filters.length; i++) filter += ("" != filter ? "|" : "") + filters[i].title + " | *." + filters[i].extensions.replace(/,/g, ";*.");
            silverlightContainer.innerHTML = '<object id="' + uploader.id + '_silverlight" data="data:application/x-silverlight," type="application/x-silverlight-2" style="outline:none;" width="1024" height="1024">' + '<param name="source" value="' + uploader.settings.silverlight_xap_url + '"/>' + '<param name="background" value="Transparent"/>' + '<param name="windowless" value="true"/>' + '<param name="enablehtmlaccess" value="true"/>' + '<param name="initParams" value="id=' + uploader.id + ",filter=" + filter + ",multiselect=" + uploader.settings.multi_selection + '"/>' + "</object>";
            function getSilverlightObj() {
                return document.getElementById(uploader.id + "_silverlight").content.Upload;
            }
            uploader.bind("Silverlight:Init", function() {
                var selectedFiles, lookup = {};
                if (initialized[uploader.id]) return;
                initialized[uploader.id] = true;
                uploader.bind("Silverlight:StartSelectFiles", function(up) {
                    selectedFiles = [];
                });
                uploader.bind("Silverlight:SelectFile", function(up, sl_id, name, size) {
                    var id;
                    id = plupload.guid();
                    lookup[id] = sl_id;
                    lookup[sl_id] = id;
                    selectedFiles.push(new plupload.File(id, name, size));
                });
                uploader.bind("Silverlight:SelectSuccessful", function() {
                    if (selectedFiles.length) uploader.trigger("FilesAdded", selectedFiles);
                });
                uploader.bind("Silverlight:UploadChunkError", function(up, file_id, chunk, chunks, message) {
                    uploader.trigger("Error", {
                        code: plupload.IO_ERROR,
                        message: "IO Error.",
                        details: message,
                        file: up.getFile(lookup[file_id])
                    });
                });
                uploader.bind("Silverlight:UploadFileProgress", function(up, sl_id, loaded, total) {
                    var file = up.getFile(lookup[sl_id]);
                    if (file.status != plupload.FAILED) {
                        file.size = total;
                        file.loaded = loaded;
                        up.trigger("UploadProgress", file);
                    }
                });
                uploader.bind("Refresh", function(up) {
                    var browseButton, browsePos, browseSize;
                    browseButton = document.getElementById(up.settings.browse_button);
                    if (browseButton) {
                        browsePos = plupload.getPos(browseButton, document.getElementById(up.settings.container));
                        browseSize = plupload.getSize(browseButton);
                        plupload.extend(document.getElementById(up.id + "_silverlight_container").style, {
                            top: browsePos.y + "px",
                            left: browsePos.x + "px",
                            width: browseSize.w + "px",
                            height: browseSize.h + "px"
                        });
                    }
                });
                uploader.bind("Silverlight:UploadChunkSuccessful", function(up, sl_id, chunk, chunks, text) {
                    var chunkArgs, file = up.getFile(lookup[sl_id]);
                    chunkArgs = {
                        chunk: chunk,
                        chunks: chunks,
                        response: text
                    };
                    up.trigger("ChunkUploaded", file, chunkArgs);
                    if (file.status != plupload.FAILED && up.state !== plupload.STOPPED) getSilverlightObj().UploadNextChunk();
                    if (chunk == chunks - 1) {
                        file.status = plupload.DONE;
                        up.trigger("FileUploaded", file, {
                            response: text
                        });
                    }
                });
                uploader.bind("Silverlight:UploadSuccessful", function(up, sl_id, response) {
                    var file = up.getFile(lookup[sl_id]);
                    file.status = plupload.DONE;
                    up.trigger("FileUploaded", file, {
                        response: response
                    });
                });
                uploader.bind("FilesRemoved", function(up, files) {
                    var i;
                    for (i = 0; i < files.length; i++) getSilverlightObj().RemoveFile(lookup[files[i].id]);
                });
                uploader.bind("UploadFile", function(up, file) {
                    var settings = up.settings, resize = settings.resize || {};
                    getSilverlightObj().UploadFile(lookup[file.id], up.settings.url, jsonSerialize({
                        name: file.target_name || file.name,
                        mime: plupload.mimeTypes[file.name.replace(/^.+\.([^.]+)/, "$1").toLowerCase()] || "application/octet-stream",
                        chunk_size: settings.chunk_size,
                        image_width: resize.width,
                        image_height: resize.height,
                        image_quality: resize.quality || 90,
                        multipart: !!settings.multipart,
                        multipart_params: settings.multipart_params || {},
                        file_data_name: settings.file_data_name,
                        headers: settings.headers
                    }));
                });
                uploader.bind("CancelUpload", function() {
                    getSilverlightObj().CancelUpload();
                });
                uploader.bind("Silverlight:MouseEnter", function(up) {
                    var browseButton, hoverClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    hoverClass = up.settings.browse_button_hover;
                    if (browseButton && hoverClass) plupload.addClass(browseButton, hoverClass);
                });
                uploader.bind("Silverlight:MouseLeave", function(up) {
                    var browseButton, hoverClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    hoverClass = up.settings.browse_button_hover;
                    if (browseButton && hoverClass) plupload.removeClass(browseButton, hoverClass);
                });
                uploader.bind("Silverlight:MouseLeftButtonDown", function(up) {
                    var browseButton, activeClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    activeClass = up.settings.browse_button_active;
                    if (browseButton && activeClass) {
                        plupload.addClass(browseButton, activeClass);
                        plupload.addEvent(document.body, "mouseup", function() {
                            plupload.removeClass(browseButton, activeClass);
                        });
                    }
                });
                uploader.bind("Sliverlight:StartSelectFiles", function(up) {
                    var browseButton, activeClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    activeClass = up.settings.browse_button_active;
                    if (browseButton && activeClass) plupload.removeClass(browseButton, activeClass);
                });
                uploader.bind("DisableBrowse", function(up, disabled) {
                    getSilverlightObj().DisableBrowse(disabled);
                });
                uploader.bind("Destroy", function(up) {
                    var silverlightContainer;
                    plupload.removeAllEvents(document.body, up.id);
                    delete initialized[up.id];
                    delete uploadInstances[up.id];
                    silverlightContainer = document.getElementById(up.id + "_silverlight_container");
                    if (silverlightContainer) container.removeChild(silverlightContainer);
                });
                callback({
                    success: true
                });
            });
        }
    });
})(window, document, plupload);

(function(window, document, plupload, undef) {
    var uploadInstances = {}, initialized = {};
    function getFlashVersion() {
        var version;
        try {
            version = navigator.plugins["Shockwave Flash"];
            version = version.description;
        } catch (e1) {
            try {
                version = new ActiveXObject("ShockwaveFlash.ShockwaveFlash").GetVariable("$version");
            } catch (e2) {
                version = "0.0";
            }
        }
        version = version.match(/\d+/g);
        return parseFloat(version[0] + "." + version[1]);
    }
    plupload.flash = {
        trigger: function(id, name, obj) {
            setTimeout(function() {
                var uploader = uploadInstances[id], i, args;
                if (uploader) uploader.trigger("Flash:" + name, obj);
            }, 0);
        }
    };
    plupload.runtimes.Flash = plupload.addRuntime("flash", {
        getFeatures: function() {
            return {
                jpgresize: true,
                pngresize: true,
                maxWidth: 8091,
                maxHeight: 8091,
                chunks: true,
                progress: true,
                multipart: true,
                multi_selection: true
            };
        },
        init: function(uploader, callback) {
            var browseButton, flashContainer, waitCount = 0, container = document.body;
            if (getFlashVersion() < 10) {
                callback({
                    success: false
                });
                return;
            }
            initialized[uploader.id] = false;
            uploadInstances[uploader.id] = uploader;
            browseButton = document.getElementById(uploader.settings.browse_button);
            flashContainer = document.createElement("div");
            flashContainer.id = uploader.id + "_flash_container";
            plupload.extend(flashContainer.style, {
                position: "absolute",
                top: "0px",
                background: uploader.settings.shim_bgcolor || "transparent",
                zIndex: 99999,
                width: "100%",
                height: "100%"
            });
            flashContainer.className = "plupload flash";
            if (uploader.settings.container) {
                container = document.getElementById(uploader.settings.container);
                if ("static" === plupload.getStyle(container, "position")) container.style.position = "relative";
            }
            container.appendChild(flashContainer);
            (function() {
                var html, el;
                html = '<object id="' + uploader.id + '_flash" type="application/x-shockwave-flash" data="' + uploader.settings.flash_swf_url + '" ';
                if (plupload.ua.ie) html += 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" ';
                html += 'width="100%" height="100%" style="outline:0">' + '<param name="movie" value="' + uploader.settings.flash_swf_url + '" />' + '<param name="flashvars" value="id=' + escape(uploader.id) + '" />' + '<param name="wmode" value="transparent" />' + '<param name="allowscriptaccess" value="always" />' + "</object>";
                if (plupload.ua.ie) {
                    el = document.createElement("div");
                    flashContainer.appendChild(el);
                    el.outerHTML = html;
                    el = null;
                } else flashContainer.innerHTML = html;
            })();
            function getFlashObj() {
                return document.getElementById(uploader.id + "_flash");
            }
            function waitLoad() {
                if (waitCount++ > 5e3) {
                    callback({
                        success: false
                    });
                    return;
                }
                if (false === initialized[uploader.id]) setTimeout(waitLoad, 1);
            }
            waitLoad();
            browseButton = flashContainer = null;
            uploader.bind("Destroy", function(up) {
                var flashContainer;
                plupload.removeAllEvents(document.body, up.id);
                delete initialized[up.id];
                delete uploadInstances[up.id];
                flashContainer = document.getElementById(up.id + "_flash_container");
                if (flashContainer) container.removeChild(flashContainer);
            });
            uploader.bind("Flash:Init", function() {
                var lookup = {}, i;
                try {
                    getFlashObj().setFileFilters(uploader.settings.filters, uploader.settings.multi_selection);
                } catch (ex) {
                    callback({
                        success: false
                    });
                    return;
                }
                if (initialized[uploader.id]) return;
                initialized[uploader.id] = true;
                uploader.bind("UploadFile", function(up, file) {
                    var settings = up.settings, resize = uploader.settings.resize || {};
                    getFlashObj().uploadFile(lookup[file.id], settings.url, {
                        name: file.target_name || file.name,
                        mime: plupload.mimeTypes[file.name.replace(/^.+\.([^.]+)/, "$1").toLowerCase()] || "application/octet-stream",
                        chunk_size: settings.chunk_size,
                        width: resize.width,
                        height: resize.height,
                        quality: resize.quality,
                        multipart: settings.multipart,
                        multipart_params: settings.multipart_params || {},
                        file_data_name: settings.file_data_name,
                        format: /\.(jpg|jpeg)$/i.test(file.name) ? "jpg" : "png",
                        headers: settings.headers,
                        urlstream_upload: settings.urlstream_upload
                    });
                });
                uploader.bind("CancelUpload", function() {
                    getFlashObj().cancelUpload();
                });
                uploader.bind("Flash:UploadProcess", function(up, flash_file) {
                    var file = up.getFile(lookup[flash_file.id]);
                    if (file.status != plupload.FAILED) {
                        file.loaded = flash_file.loaded;
                        file.size = flash_file.size;
                        up.trigger("UploadProgress", file);
                    }
                });
                uploader.bind("Flash:UploadChunkComplete", function(up, info) {
                    var chunkArgs, file = up.getFile(lookup[info.id]);
                    chunkArgs = {
                        chunk: info.chunk,
                        chunks: info.chunks,
                        response: info.text
                    };
                    up.trigger("ChunkUploaded", file, chunkArgs);
                    if (file.status !== plupload.FAILED && up.state !== plupload.STOPPED) getFlashObj().uploadNextChunk();
                    if (info.chunk == info.chunks - 1) {
                        file.status = plupload.DONE;
                        up.trigger("FileUploaded", file, {
                            response: info.text
                        });
                    }
                });
                uploader.bind("Flash:SelectFiles", function(up, selected_files) {
                    var file, i, files = [], id;
                    for (i = 0; i < selected_files.length; i++) {
                        file = selected_files[i];
                        id = plupload.guid();
                        lookup[id] = file.id;
                        lookup[file.id] = id;
                        files.push(new plupload.File(id, file.name, file.size));
                    }
                    if (files.length) uploader.trigger("FilesAdded", files);
                });
                uploader.bind("Flash:SecurityError", function(up, err) {
                    uploader.trigger("Error", {
                        code: plupload.SECURITY_ERROR,
                        message: plupload.translate("Security error."),
                        details: err.message,
                        file: uploader.getFile(lookup[err.id])
                    });
                });
                uploader.bind("Flash:GenericError", function(up, err) {
                    uploader.trigger("Error", {
                        code: plupload.GENERIC_ERROR,
                        message: plupload.translate("Generic error."),
                        details: err.message,
                        file: uploader.getFile(lookup[err.id])
                    });
                });
                uploader.bind("Flash:IOError", function(up, err) {
                    uploader.trigger("Error", {
                        code: plupload.IO_ERROR,
                        message: plupload.translate("IO error."),
                        details: err.message,
                        file: uploader.getFile(lookup[err.id])
                    });
                });
                uploader.bind("Flash:ImageError", function(up, err) {
                    uploader.trigger("Error", {
                        code: parseInt(err.code, 10),
                        message: plupload.translate("Image error."),
                        file: uploader.getFile(lookup[err.id])
                    });
                });
                uploader.bind("Flash:StageEvent:rollOver", function(up) {
                    var browseButton, hoverClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    hoverClass = up.settings.browse_button_hover;
                    if (browseButton && hoverClass) plupload.addClass(browseButton, hoverClass);
                });
                uploader.bind("Flash:StageEvent:rollOut", function(up) {
                    var browseButton, hoverClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    hoverClass = up.settings.browse_button_hover;
                    if (browseButton && hoverClass) plupload.removeClass(browseButton, hoverClass);
                });
                uploader.bind("Flash:StageEvent:mouseDown", function(up) {
                    var browseButton, activeClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    activeClass = up.settings.browse_button_active;
                    if (browseButton && activeClass) {
                        plupload.addClass(browseButton, activeClass);
                        plupload.addEvent(document.body, "mouseup", function() {
                            plupload.removeClass(browseButton, activeClass);
                        }, up.id);
                    }
                });
                uploader.bind("Flash:StageEvent:mouseUp", function(up) {
                    var browseButton, activeClass;
                    browseButton = document.getElementById(uploader.settings.browse_button);
                    activeClass = up.settings.browse_button_active;
                    if (browseButton && activeClass) plupload.removeClass(browseButton, activeClass);
                });
                uploader.bind("Flash:ExifData", function(up, obj) {
                    uploader.trigger("ExifData", uploader.getFile(lookup[obj.id]), obj.data);
                });
                uploader.bind("Flash:GpsData", function(up, obj) {
                    uploader.trigger("GpsData", uploader.getFile(lookup[obj.id]), obj.data);
                });
                uploader.bind("QueueChanged", function(up) {
                    uploader.refresh();
                });
                uploader.bind("FilesRemoved", function(up, files) {
                    var i;
                    for (i = 0; i < files.length; i++) getFlashObj().removeFile(lookup[files[i].id]);
                });
                uploader.bind("StateChanged", function(up) {
                    uploader.refresh();
                });
                uploader.bind("Refresh", function(up) {
                    var browseButton, browsePos, browseSize;
                    getFlashObj().setFileFilters(uploader.settings.filters, uploader.settings.multi_selection);
                    browseButton = document.getElementById(up.settings.browse_button);
                    if (browseButton) {
                        browsePos = plupload.getPos(browseButton, document.getElementById(up.settings.container));
                        browseSize = plupload.getSize(browseButton);
                        plupload.extend(document.getElementById(up.id + "_flash_container").style, {
                            top: browsePos.y + "px",
                            left: browsePos.x + "px",
                            width: browseSize.w + "px",
                            height: browseSize.h + "px"
                        });
                    }
                });
                uploader.bind("DisableBrowse", function(up, disabled) {
                    getFlashObj().disableBrowse(disabled);
                });
                callback({
                    success: true
                });
            });
        }
    });
})(window, document, plupload);

(function(window, document, plupload, undef) {
    var html5files = {}, fakeSafariDragDrop;
    function readFileAsDataURL(file, callback) {
        var reader;
        if ("FileReader" in window) {
            reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = function() {
                callback(reader.result);
            };
        } else return callback(file.getAsDataURL());
    }
    function readFileAsBinary(file, callback) {
        var reader;
        if ("FileReader" in window) {
            reader = new FileReader();
            reader.readAsBinaryString(file);
            reader.onload = function() {
                callback(reader.result);
            };
        } else return callback(file.getAsBinary());
    }
    function scaleImage(file, resize, mime, callback) {
        var canvas, context, img, scale, up = this;
        readFileAsDataURL(html5files[file.id], function(data) {
            canvas = document.createElement("canvas");
            canvas.style.display = "none";
            document.body.appendChild(canvas);
            context = canvas.getContext("2d");
            img = new Image();
            img.onerror = img.onabort = function() {
                callback({
                    success: false
                });
            };
            img.onload = function() {
                var width, height, percentage, jpegHeaders, exifParser;
                if (!resize["width"]) resize["width"] = img.width;
                if (!resize["height"]) resize["height"] = img.height;
                scale = Math.min(resize.width / img.width, resize.height / img.height);
                if (scale < 1 || 1 === scale && "image/jpeg" === mime) {
                    width = Math.round(img.width * scale);
                    height = Math.round(img.height * scale);
                    canvas.width = width;
                    canvas.height = height;
                    context.drawImage(img, 0, 0, width, height);
                    if ("image/jpeg" === mime) {
                        jpegHeaders = new JPEG_Headers(atob(data.substring(data.indexOf("base64,") + 7)));
                        if (jpegHeaders["headers"] && jpegHeaders["headers"].length) {
                            exifParser = new ExifParser();
                            if (exifParser.init(jpegHeaders.get("exif")[0])) {
                                exifParser.setExif("PixelXDimension", width);
                                exifParser.setExif("PixelYDimension", height);
                                jpegHeaders.set("exif", exifParser.getBinary());
                                if (up.hasEventListener("ExifData")) up.trigger("ExifData", file, exifParser.EXIF());
                                if (up.hasEventListener("GpsData")) up.trigger("GpsData", file, exifParser.GPS());
                            }
                        }
                        if (resize["quality"]) try {
                            data = canvas.toDataURL(mime, resize["quality"] / 100);
                        } catch (e) {
                            data = canvas.toDataURL(mime);
                        }
                    } else data = canvas.toDataURL(mime);
                    data = data.substring(data.indexOf("base64,") + 7);
                    data = atob(data);
                    if (jpegHeaders && jpegHeaders["headers"] && jpegHeaders["headers"].length) {
                        data = jpegHeaders.restore(data);
                        jpegHeaders.purge();
                    }
                    canvas.parentNode.removeChild(canvas);
                    callback({
                        success: true,
                        data: data
                    });
                } else callback({
                    success: false
                });
            };
            img.src = data;
        });
    }
    plupload.runtimes.Html5 = plupload.addRuntime("html5", {
        getFeatures: function() {
            var xhr, hasXhrSupport, hasProgress, canSendBinary, dataAccessSupport, sliceSupport;
            hasXhrSupport = hasProgress = dataAccessSupport = sliceSupport = false;
            if (window.XMLHttpRequest) {
                xhr = new XMLHttpRequest();
                hasProgress = !!xhr.upload;
                hasXhrSupport = !!(xhr.sendAsBinary || xhr.upload);
            }
            if (hasXhrSupport) {
                canSendBinary = !!(xhr.sendAsBinary || window.Uint8Array && window.ArrayBuffer);
                dataAccessSupport = !!(File && (File.prototype.getAsDataURL || window.FileReader) && canSendBinary);
                sliceSupport = !!(File && (File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice));
            }
            fakeSafariDragDrop = plupload.ua.safari && plupload.ua.windows;
            return {
                html5: hasXhrSupport,
                dragdrop: function() {
                    var div = document.createElement("div");
                    return "draggable" in div || "ondragstart" in div && "ondrop" in div;
                }(),
                jpgresize: dataAccessSupport,
                pngresize: dataAccessSupport,
                multipart: dataAccessSupport || !!window.FileReader || !!window.FormData,
                canSendBinary: canSendBinary,
                cantSendBlobInFormData: !!(plupload.ua.gecko && window.FormData && window.FileReader && !FileReader.prototype.readAsArrayBuffer),
                progress: hasProgress,
                chunks: sliceSupport,
                multi_selection: !(plupload.ua.safari && plupload.ua.windows),
                triggerDialog: plupload.ua.gecko && window.FormData || plupload.ua.webkit
            };
        },
        init: function(uploader, callback) {
            var features, xhr;
            function addSelectedFiles(native_files) {
                var file, i, files = [], id, fileNames = {};
                for (i = 0; i < native_files.length; i++) {
                    file = native_files[i];
                    if (fileNames[file.name]) continue;
                    fileNames[file.name] = true;
                    id = plupload.guid();
                    html5files[id] = file;
                    files.push(new plupload.File(id, file.fileName || file.name, file.fileSize || file.size));
                }
                if (files.length) uploader.trigger("FilesAdded", files);
            }
            features = this.getFeatures();
            if (!features.html5) {
                callback({
                    success: false
                });
                return;
            }
            uploader.bind("Init", function(up) {
                var inputContainer, browseButton, mimes = [], i, y, filters = up.settings.filters, ext, type, container = document.body, inputFile;
                inputContainer = document.createElement("div");
                inputContainer.id = up.id + "_html5_container";
                plupload.extend(inputContainer.style, {
                    position: "absolute",
                    background: uploader.settings.shim_bgcolor || "transparent",
                    width: "100px",
                    height: "100px",
                    overflow: "hidden",
                    zIndex: 99999,
                    opacity: uploader.settings.shim_bgcolor ? "" : 0
                });
                inputContainer.className = "plupload html5";
                if (uploader.settings.container) {
                    container = document.getElementById(uploader.settings.container);
                    if ("static" === plupload.getStyle(container, "position")) container.style.position = "relative";
                }
                container.appendChild(inputContainer);
                no_type_restriction: for (i = 0; i < filters.length; i++) {
                    ext = filters[i].extensions.split(/,/);
                    for (y = 0; y < ext.length; y++) {
                        if ("*" === ext[y]) {
                            mimes = [];
                            break no_type_restriction;
                        }
                        type = plupload.mimeTypes[ext[y]];
                        if (type && plupload.inArray(type, mimes) === -1) mimes.push(type);
                    }
                }
                inputContainer.innerHTML = '<input id="' + uploader.id + '_html5" ' + ' style="font-size:999px"' + ' type="file" accept="' + mimes.join(",") + '" ' + (uploader.settings.multi_selection && uploader.features.multi_selection ? 'multiple="multiple"' : "") + " />";
                inputContainer.scrollTop = 100;
                inputFile = document.getElementById(uploader.id + "_html5");
                if (up.features.triggerDialog) plupload.extend(inputFile.style, {
                    position: "absolute",
                    width: "100%",
                    height: "100%"
                }); else plupload.extend(inputFile.style, {
                    cssFloat: "right",
                    styleFloat: "right"
                });
                inputFile.onchange = function() {
                    addSelectedFiles(this.files);
                    this.value = "";
                };
                browseButton = document.getElementById(up.settings.browse_button);
                if (browseButton) {
                    var hoverClass = up.settings.browse_button_hover, activeClass = up.settings.browse_button_active, topElement = up.features.triggerDialog ? browseButton : inputContainer;
                    if (hoverClass) {
                        plupload.addEvent(topElement, "mouseover", function() {
                            plupload.addClass(browseButton, hoverClass);
                        }, up.id);
                        plupload.addEvent(topElement, "mouseout", function() {
                            plupload.removeClass(browseButton, hoverClass);
                        }, up.id);
                    }
                    if (activeClass) {
                        plupload.addEvent(topElement, "mousedown", function() {
                            plupload.addClass(browseButton, activeClass);
                        }, up.id);
                        plupload.addEvent(document.body, "mouseup", function() {
                            plupload.removeClass(browseButton, activeClass);
                        }, up.id);
                    }
                    if (up.features.triggerDialog) plupload.addEvent(browseButton, "click", function(e) {
                        var input = document.getElementById(up.id + "_html5");
                        if (input && !input.disabled) input.click();
                        e.preventDefault();
                    }, up.id);
                }
            });
            uploader.bind("PostInit", function() {
                var dropElm = document.getElementById(uploader.settings.drop_element);
                if (dropElm) {
                    if (fakeSafariDragDrop) {
                        plupload.addEvent(dropElm, "dragenter", function(e) {
                            var dropInputElm, dropPos, dropSize;
                            dropInputElm = document.getElementById(uploader.id + "_drop");
                            if (!dropInputElm) {
                                dropInputElm = document.createElement("input");
                                dropInputElm.setAttribute("type", "file");
                                dropInputElm.setAttribute("id", uploader.id + "_drop");
                                dropInputElm.setAttribute("multiple", "multiple");
                                plupload.addEvent(dropInputElm, "change", function() {
                                    addSelectedFiles(this.files);
                                    plupload.removeEvent(dropInputElm, "change", uploader.id);
                                    dropInputElm.parentNode.removeChild(dropInputElm);
                                }, uploader.id);
                                dropElm.appendChild(dropInputElm);
                            }
                            dropPos = plupload.getPos(dropElm, document.getElementById(uploader.settings.container));
                            dropSize = plupload.getSize(dropElm);
                            if ("static" === plupload.getStyle(dropElm, "position")) plupload.extend(dropElm.style, {
                                position: "relative"
                            });
                            plupload.extend(dropInputElm.style, {
                                position: "absolute",
                                display: "block",
                                top: 0,
                                left: 0,
                                width: dropSize.w + "px",
                                height: dropSize.h + "px",
                                opacity: 0
                            });
                        }, uploader.id);
                        return;
                    }
                    plupload.addEvent(dropElm, "dragover", function(e) {
                        e.preventDefault();
                    }, uploader.id);
                    plupload.addEvent(dropElm, "drop", function(e) {
                        var dataTransfer = e.dataTransfer;
                        if (dataTransfer && dataTransfer.files) addSelectedFiles(dataTransfer.files);
                        e.preventDefault();
                    }, uploader.id);
                }
            });
            uploader.bind("Refresh", function(up) {
                var browseButton, browsePos, browseSize, inputContainer, zIndex;
                browseButton = document.getElementById(uploader.settings.browse_button);
                if (browseButton) {
                    browsePos = plupload.getPos(browseButton, document.getElementById(up.settings.container));
                    browseSize = plupload.getSize(browseButton);
                    inputContainer = document.getElementById(uploader.id + "_html5_container");
                    plupload.extend(inputContainer.style, {
                        top: browsePos.y + "px",
                        left: browsePos.x + "px",
                        width: browseSize.w + "px",
                        height: browseSize.h + "px"
                    });
                    if (uploader.features.triggerDialog) {
                        if ("static" === plupload.getStyle(browseButton, "position")) plupload.extend(browseButton.style, {
                            position: "relative"
                        });
                        zIndex = parseInt(plupload.getStyle(browseButton, "zIndex"), 10);
                        if (isNaN(zIndex)) zIndex = 0;
                        plupload.extend(browseButton.style, {
                            zIndex: zIndex
                        });
                        plupload.extend(inputContainer.style, {
                            zIndex: zIndex - 1
                        });
                    }
                }
            });
            uploader.bind("DisableBrowse", function(up, disabled) {
                var input = document.getElementById(up.id + "_html5");
                if (input) input.disabled = disabled;
            });
            uploader.bind("CancelUpload", function() {
                if (xhr && xhr.abort) xhr.abort();
            });
            uploader.bind("UploadFile", function(up, file) {
                var settings = up.settings, nativeFile, resize;
                function w3cBlobSlice(blob, start, end) {
                    var blobSlice;
                    if (File.prototype.slice) try {
                        blob.slice();
                        return blob.slice(start, end);
                    } catch (e) {
                        return blob.slice(start, end - start);
                    } else if (blobSlice = File.prototype.webkitSlice || File.prototype.mozSlice) return blobSlice.call(blob, start, end); else return null;
                }
                function sendBinaryBlob(blob) {
                    var chunk = 0, loaded = 0, fr = "FileReader" in window ? new FileReader() : null;
                    function uploadNextChunk() {
                        var chunkBlob, br, chunks, args, chunkSize, curChunkSize, mimeType, url = up.settings.url;
                        function prepareAndSend(bin) {
                            var multipartDeltaSize = 0, boundary = "----pluploadboundary" + plupload.guid(), formData, dashdash = "--", crlf = "\r\n", multipartBlob = "";
                            xhr = new XMLHttpRequest();
                            if (xhr.upload) xhr.upload.onprogress = function(e) {
                                file.loaded = Math.min(file.size, loaded + e.loaded - multipartDeltaSize);
                                up.trigger("UploadProgress", file);
                            };
                            xhr.onreadystatechange = function() {
                                var httpStatus, chunkArgs;
                                if (4 == xhr.readyState && up.state !== plupload.STOPPED) {
                                    try {
                                        httpStatus = xhr.status;
                                    } catch (ex) {
                                        httpStatus = 0;
                                    }
                                    if (httpStatus >= 400) up.trigger("Error", {
                                        code: plupload.HTTP_ERROR,
                                        message: plupload.translate("HTTP Error."),
                                        file: file,
                                        status: httpStatus
                                    }); else {
                                        if (chunks) {
                                            chunkArgs = {
                                                chunk: chunk,
                                                chunks: chunks,
                                                response: xhr.responseText,
                                                status: httpStatus
                                            };
                                            up.trigger("ChunkUploaded", file, chunkArgs);
                                            loaded += curChunkSize;
                                            if (chunkArgs.cancelled) {
                                                file.status = plupload.FAILED;
                                                return;
                                            }
                                            file.loaded = Math.min(file.size, (chunk + 1) * chunkSize);
                                        } else file.loaded = file.size;
                                        up.trigger("UploadProgress", file);
                                        bin = chunkBlob = formData = multipartBlob = null;
                                        if (!chunks || ++chunk >= chunks) {
                                            file.status = plupload.DONE;
                                            up.trigger("FileUploaded", file, {
                                                response: xhr.responseText,
                                                status: httpStatus
                                            });
                                        } else uploadNextChunk();
                                    }
                                }
                            };
                            if (up.settings.multipart && features.multipart) {
                                args.name = file.target_name || file.name;
                                xhr.open("post", url, true);
                                plupload.each(up.settings.headers, function(value, name) {
                                    xhr.setRequestHeader(name, value);
                                });
                                if ("string" !== typeof bin && !!window.FormData) {
                                    formData = new FormData();
                                    plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
                                        formData.append(name, value);
                                    });
                                    formData.append(up.settings.file_data_name, bin);
                                    xhr.send(formData);
                                    return;
                                }
                                if ("string" === typeof bin) {
                                    xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
                                    plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
                                        multipartBlob += dashdash + boundary + crlf + 'Content-Disposition: form-data; name="' + name + '"' + crlf + crlf;
                                        multipartBlob += unescape(encodeURIComponent(value)) + crlf;
                                    });
                                    mimeType = plupload.mimeTypes[file.name.replace(/^.+\.([^.]+)/, "$1").toLowerCase()] || "application/octet-stream";
                                    multipartBlob += dashdash + boundary + crlf + 'Content-Disposition: form-data; name="' + up.settings.file_data_name + '"; filename="' + unescape(encodeURIComponent(file.name)) + '"' + crlf + "Content-Type: " + mimeType + crlf + crlf + bin + crlf + dashdash + boundary + dashdash + crlf;
                                    multipartDeltaSize = multipartBlob.length - bin.length;
                                    bin = multipartBlob;
                                    if (xhr.sendAsBinary) xhr.sendAsBinary(bin); else if (features.canSendBinary) {
                                        var ui8a = new Uint8Array(bin.length);
                                        for (var i = 0; i < bin.length; i++) ui8a[i] = 255 & bin.charCodeAt(i);
                                        xhr.send(ui8a.buffer);
                                    }
                                    return;
                                }
                            }
                            url = plupload.buildUrl(up.settings.url, plupload.extend(args, up.settings.multipart_params));
                            xhr.open("post", url, true);
                            xhr.setRequestHeader("Content-Type", "application/octet-stream");
                            plupload.each(up.settings.headers, function(value, name) {
                                xhr.setRequestHeader(name, value);
                            });
                            xhr.send(bin);
                        }
                        if (file.status == plupload.DONE || file.status == plupload.FAILED || up.state == plupload.STOPPED) return;
                        args = {
                            name: file.target_name || file.name
                        };
                        if (settings.chunk_size && file.size > settings.chunk_size && (features.chunks || "string" == typeof blob)) {
                            chunkSize = settings.chunk_size;
                            chunks = Math.ceil(file.size / chunkSize);
                            curChunkSize = Math.min(chunkSize, file.size - chunk * chunkSize);
                            if ("string" == typeof blob) chunkBlob = blob.substring(chunk * chunkSize, chunk * chunkSize + curChunkSize); else chunkBlob = w3cBlobSlice(blob, chunk * chunkSize, chunk * chunkSize + curChunkSize);
                            args.chunk = chunk;
                            args.chunks = chunks;
                        } else {
                            curChunkSize = file.size;
                            chunkBlob = blob;
                        }
                        if (up.settings.multipart && features.multipart && "string" !== typeof chunkBlob && fr && features.cantSendBlobInFormData && features.chunks && up.settings.chunk_size) {
                            fr.onload = function() {
                                prepareAndSend(fr.result);
                            };
                            fr.readAsBinaryString(chunkBlob);
                        } else prepareAndSend(chunkBlob);
                    }
                    uploadNextChunk();
                }
                nativeFile = html5files[file.id];
                if (features.jpgresize && up.settings.resize && /\.(png|jpg|jpeg)$/i.test(file.name)) scaleImage.call(up, file, up.settings.resize, /\.png$/i.test(file.name) ? "image/png" : "image/jpeg", function(res) {
                    if (res.success) {
                        file.size = res.data.length;
                        sendBinaryBlob(res.data);
                    } else if (features.chunks) sendBinaryBlob(nativeFile); else readFileAsBinary(nativeFile, sendBinaryBlob);
                }); else if (!features.chunks && features.jpgresize) readFileAsBinary(nativeFile, sendBinaryBlob); else sendBinaryBlob(nativeFile);
            });
            uploader.bind("Destroy", function(up) {
                var name, element, container = document.body, elements = {
                    inputContainer: up.id + "_html5_container",
                    inputFile: up.id + "_html5",
                    browseButton: up.settings.browse_button,
                    dropElm: up.settings.drop_element
                };
                for (name in elements) {
                    element = document.getElementById(elements[name]);
                    if (element) plupload.removeAllEvents(element, up.id);
                }
                plupload.removeAllEvents(document.body, up.id);
                if (up.settings.container) container = document.getElementById(up.settings.container);
                container.removeChild(document.getElementById(elements.inputContainer));
            });
            callback({
                success: true
            });
        }
    });
    function BinaryReader() {
        var II = false, bin;
        function read(idx, size) {
            var mv = II ? 0 : -8 * (size - 1), sum = 0, i;
            for (i = 0; i < size; i++) sum |= bin.charCodeAt(idx + i) << Math.abs(mv + 8 * i);
            return sum;
        }
        function putstr(segment, idx, length) {
            var length = 3 === arguments.length ? length : bin.length - idx - 1;
            bin = bin.substr(0, idx) + segment + bin.substr(length + idx);
        }
        function write(idx, num, size) {
            var str = "", mv = II ? 0 : -8 * (size - 1), i;
            for (i = 0; i < size; i++) str += String.fromCharCode(255 & num >> Math.abs(mv + 8 * i));
            putstr(str, idx, size);
        }
        return {
            II: function(order) {
                if (order === undef) return II; else II = order;
            },
            init: function(binData) {
                II = false;
                bin = binData;
            },
            SEGMENT: function(idx, length, segment) {
                switch (arguments.length) {
                  case 1:
                    return bin.substr(idx, bin.length - idx - 1);

                  case 2:
                    return bin.substr(idx, length);

                  case 3:
                    putstr(segment, idx, length);
                    break;

                  default:
                    return bin;
                }
            },
            BYTE: function(idx) {
                return read(idx, 1);
            },
            SHORT: function(idx) {
                return read(idx, 2);
            },
            LONG: function(idx, num) {
                if (num === undef) return read(idx, 4); else write(idx, num, 4);
            },
            SLONG: function(idx) {
                var num = read(idx, 4);
                return num > 2147483647 ? num - 4294967296 : num;
            },
            STRING: function(idx, size) {
                var str = "";
                for (size += idx; idx < size; idx++) str += String.fromCharCode(read(idx, 1));
                return str;
            }
        };
    }
    function JPEG_Headers(data) {
        var markers = {
            65505: {
                app: "EXIF",
                name: "APP1",
                signature: "Exif\0"
            },
            65506: {
                app: "ICC",
                name: "APP2",
                signature: "ICC_PROFILE\0"
            },
            65517: {
                app: "IPTC",
                name: "APP13",
                signature: "Photoshop 3.0\0"
            }
        }, headers = [], read, idx, marker = undef, length = 0, limit;
        read = new BinaryReader();
        read.init(data);
        if (65496 !== read.SHORT(0)) return;
        idx = 2;
        limit = Math.min(1048576, data.length);
        while (idx <= limit) {
            marker = read.SHORT(idx);
            if (marker >= 65488 && marker <= 65495) {
                idx += 2;
                continue;
            }
            if (65498 === marker || 65497 === marker) break;
            length = read.SHORT(idx + 2) + 2;
            if (markers[marker] && read.STRING(idx + 4, markers[marker].signature.length) === markers[marker].signature) headers.push({
                hex: marker,
                app: markers[marker].app.toUpperCase(),
                name: markers[marker].name.toUpperCase(),
                start: idx,
                length: length,
                segment: read.SEGMENT(idx, length)
            });
            idx += length;
        }
        read.init(null);
        return {
            headers: headers,
            restore: function(data) {
                read.init(data);
                var jpegHeaders = new JPEG_Headers(data);
                if (!jpegHeaders["headers"]) return false;
                for (var i = jpegHeaders["headers"].length; i > 0; i--) {
                    var hdr = jpegHeaders["headers"][i - 1];
                    read.SEGMENT(hdr.start, hdr.length, "");
                }
                jpegHeaders.purge();
                idx = 65504 == read.SHORT(2) ? 4 + read.SHORT(4) : 2;
                for (var i = 0, max = headers.length; i < max; i++) {
                    read.SEGMENT(idx, 0, headers[i].segment);
                    idx += headers[i].length;
                }
                return read.SEGMENT();
            },
            get: function(app) {
                var array = [];
                for (var i = 0, max = headers.length; i < max; i++) if (headers[i].app === app.toUpperCase()) array.push(headers[i].segment);
                return array;
            },
            set: function(app, segment) {
                var array = [];
                if ("string" === typeof segment) array.push(segment); else array = segment;
                for (var i = ii = 0, max = headers.length; i < max; i++) {
                    if (headers[i].app === app.toUpperCase()) {
                        headers[i].segment = array[ii];
                        headers[i].length = array[ii].length;
                        ii++;
                    }
                    if (ii >= array.length) break;
                }
            },
            purge: function() {
                headers = [];
                read.init(null);
            }
        };
    }
    function ExifParser() {
        var data, tags, offsets = {}, tagDescs;
        data = new BinaryReader();
        tags = {
            tiff: {
                274: "Orientation",
                34665: "ExifIFDPointer",
                34853: "GPSInfoIFDPointer"
            },
            exif: {
                36864: "ExifVersion",
                40961: "ColorSpace",
                40962: "PixelXDimension",
                40963: "PixelYDimension",
                36867: "DateTimeOriginal",
                33434: "ExposureTime",
                33437: "FNumber",
                34855: "ISOSpeedRatings",
                37377: "ShutterSpeedValue",
                37378: "ApertureValue",
                37383: "MeteringMode",
                37384: "LightSource",
                37385: "Flash",
                41986: "ExposureMode",
                41987: "WhiteBalance",
                41990: "SceneCaptureType",
                41988: "DigitalZoomRatio",
                41992: "Contrast",
                41993: "Saturation",
                41994: "Sharpness"
            },
            gps: {
                0: "GPSVersionID",
                1: "GPSLatitudeRef",
                2: "GPSLatitude",
                3: "GPSLongitudeRef",
                4: "GPSLongitude"
            }
        };
        tagDescs = {
            ColorSpace: {
                1: "sRGB",
                0: "Uncalibrated"
            },
            MeteringMode: {
                0: "Unknown",
                1: "Average",
                2: "CenterWeightedAverage",
                3: "Spot",
                4: "MultiSpot",
                5: "Pattern",
                6: "Partial",
                255: "Other"
            },
            LightSource: {
                1: "Daylight",
                2: "Fliorescent",
                3: "Tungsten",
                4: "Flash",
                9: "Fine weather",
                10: "Cloudy weather",
                11: "Shade",
                12: "Daylight fluorescent (D 5700 - 7100K)",
                13: "Day white fluorescent (N 4600 -5400K)",
                14: "Cool white fluorescent (W 3900 - 4500K)",
                15: "White fluorescent (WW 3200 - 3700K)",
                17: "Standard light A",
                18: "Standard light B",
                19: "Standard light C",
                20: "D55",
                21: "D65",
                22: "D75",
                23: "D50",
                24: "ISO studio tungsten",
                255: "Other"
            },
            Flash: {
                0: "Flash did not fire.",
                1: "Flash fired.",
                5: "Strobe return light not detected.",
                7: "Strobe return light detected.",
                9: "Flash fired, compulsory flash mode",
                13: "Flash fired, compulsory flash mode, return light not detected",
                15: "Flash fired, compulsory flash mode, return light detected",
                16: "Flash did not fire, compulsory flash mode",
                24: "Flash did not fire, auto mode",
                25: "Flash fired, auto mode",
                29: "Flash fired, auto mode, return light not detected",
                31: "Flash fired, auto mode, return light detected",
                32: "No flash function",
                65: "Flash fired, red-eye reduction mode",
                69: "Flash fired, red-eye reduction mode, return light not detected",
                71: "Flash fired, red-eye reduction mode, return light detected",
                73: "Flash fired, compulsory flash mode, red-eye reduction mode",
                77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
                79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
                89: "Flash fired, auto mode, red-eye reduction mode",
                93: "Flash fired, auto mode, return light not detected, red-eye reduction mode",
                95: "Flash fired, auto mode, return light detected, red-eye reduction mode"
            },
            ExposureMode: {
                0: "Auto exposure",
                1: "Manual exposure",
                2: "Auto bracket"
            },
            WhiteBalance: {
                0: "Auto white balance",
                1: "Manual white balance"
            },
            SceneCaptureType: {
                0: "Standard",
                1: "Landscape",
                2: "Portrait",
                3: "Night scene"
            },
            Contrast: {
                0: "Normal",
                1: "Soft",
                2: "Hard"
            },
            Saturation: {
                0: "Normal",
                1: "Low saturation",
                2: "High saturation"
            },
            Sharpness: {
                0: "Normal",
                1: "Soft",
                2: "Hard"
            },
            GPSLatitudeRef: {
                N: "North latitude",
                S: "South latitude"
            },
            GPSLongitudeRef: {
                E: "East longitude",
                W: "West longitude"
            }
        };
        function extractTags(IFD_offset, tags2extract) {
            var length = data.SHORT(IFD_offset), i, ii, tag, type, count, tagOffset, offset, value, values = [], hash = {};
            for (i = 0; i < length; i++) {
                offset = tagOffset = IFD_offset + 12 * i + 2;
                tag = tags2extract[data.SHORT(offset)];
                if (tag === undef) continue;
                type = data.SHORT(offset += 2);
                count = data.LONG(offset += 2);
                offset += 4;
                values = [];
                switch (type) {
                  case 1:
                  case 7:
                    if (count > 4) offset = data.LONG(offset) + offsets.tiffHeader;
                    for (ii = 0; ii < count; ii++) values[ii] = data.BYTE(offset + ii);
                    break;

                  case 2:
                    if (count > 4) offset = data.LONG(offset) + offsets.tiffHeader;
                    hash[tag] = data.STRING(offset, count - 1);
                    continue;

                  case 3:
                    if (count > 2) offset = data.LONG(offset) + offsets.tiffHeader;
                    for (ii = 0; ii < count; ii++) values[ii] = data.SHORT(offset + 2 * ii);
                    break;

                  case 4:
                    if (count > 1) offset = data.LONG(offset) + offsets.tiffHeader;
                    for (ii = 0; ii < count; ii++) values[ii] = data.LONG(offset + 4 * ii);
                    break;

                  case 5:
                    offset = data.LONG(offset) + offsets.tiffHeader;
                    for (ii = 0; ii < count; ii++) values[ii] = data.LONG(offset + 4 * ii) / data.LONG(offset + 4 * ii + 4);
                    break;

                  case 9:
                    offset = data.LONG(offset) + offsets.tiffHeader;
                    for (ii = 0; ii < count; ii++) values[ii] = data.SLONG(offset + 4 * ii);
                    break;

                  case 10:
                    offset = data.LONG(offset) + offsets.tiffHeader;
                    for (ii = 0; ii < count; ii++) values[ii] = data.SLONG(offset + 4 * ii) / data.SLONG(offset + 4 * ii + 4);
                    break;

                  default:
                    continue;
                }
                value = 1 == count ? values[0] : values;
                if (tagDescs.hasOwnProperty(tag) && "object" != typeof value) hash[tag] = tagDescs[tag][value]; else hash[tag] = value;
            }
            return hash;
        }
        function getIFDOffsets() {
            var Tiff = undef, idx = offsets.tiffHeader;
            data.II(18761 == data.SHORT(idx));
            if (42 !== data.SHORT(idx += 2)) return false;
            offsets["IFD0"] = offsets.tiffHeader + data.LONG(idx += 2);
            Tiff = extractTags(offsets["IFD0"], tags.tiff);
            offsets["exifIFD"] = "ExifIFDPointer" in Tiff ? offsets.tiffHeader + Tiff.ExifIFDPointer : undef;
            offsets["gpsIFD"] = "GPSInfoIFDPointer" in Tiff ? offsets.tiffHeader + Tiff.GPSInfoIFDPointer : undef;
            return true;
        }
        function setTag(ifd, tag, value) {
            var offset, length, tagOffset, valueOffset = 0;
            if ("string" === typeof tag) {
                var tmpTags = tags[ifd.toLowerCase()];
                for (hex in tmpTags) if (tmpTags[hex] === tag) {
                    tag = hex;
                    break;
                }
            }
            offset = offsets[ifd.toLowerCase() + "IFD"];
            length = data.SHORT(offset);
            for (i = 0; i < length; i++) {
                tagOffset = offset + 12 * i + 2;
                if (data.SHORT(tagOffset) == tag) {
                    valueOffset = tagOffset + 8;
                    break;
                }
            }
            if (!valueOffset) return false;
            data.LONG(valueOffset, value);
            return true;
        }
        return {
            init: function(segment) {
                offsets = {
                    tiffHeader: 10
                };
                if (segment === undef || !segment.length) return false;
                data.init(segment);
                if (65505 === data.SHORT(0) && "EXIF\0" === data.STRING(4, 5).toUpperCase()) return getIFDOffsets();
                return false;
            },
            EXIF: function() {
                var Exif;
                Exif = extractTags(offsets.exifIFD, tags.exif);
                if (Exif.ExifVersion && "array" === plupload.typeOf(Exif.ExifVersion)) {
                    for (var i = 0, exifVersion = ""; i < Exif.ExifVersion.length; i++) exifVersion += String.fromCharCode(Exif.ExifVersion[i]);
                    Exif.ExifVersion = exifVersion;
                }
                return Exif;
            },
            GPS: function() {
                var GPS;
                GPS = extractTags(offsets.gpsIFD, tags.gps);
                if (GPS.GPSVersionID) GPS.GPSVersionID = GPS.GPSVersionID.join(".");
                return GPS;
            },
            setExif: function(tag, value) {
                if ("PixelXDimension" !== tag && "PixelYDimension" !== tag) return false;
                return setTag("exif", tag, value);
            },
            getBinary: function() {
                return data.SEGMENT();
            }
        };
    }
})(window, document, plupload);

(function(window, document, plupload, undef) {
    function getById(id) {
        return document.getElementById(id);
    }
    plupload.runtimes.Html4 = plupload.addRuntime("html4", {
        getFeatures: function() {
            return {
                multipart: true,
                triggerDialog: plupload.ua.gecko && window.FormData || plupload.ua.webkit
            };
        },
        init: function(uploader, callback) {
            uploader.bind("Init", function(up) {
                var container = document.body, iframe, url = "javascript", currentFile, input, currentFileId, fileIds = [], IE = /MSIE/.test(navigator.userAgent), mimes = [], filters = up.settings.filters, i, ext, type, y;
                no_type_restriction: for (i = 0; i < filters.length; i++) {
                    ext = filters[i].extensions.split(/,/);
                    for (y = 0; y < ext.length; y++) {
                        if ("*" === ext[y]) {
                            mimes = [];
                            break no_type_restriction;
                        }
                        type = plupload.mimeTypes[ext[y]];
                        if (type && plupload.inArray(type, mimes) === -1) mimes.push(type);
                    }
                }
                mimes = mimes.join(",");
                function createForm() {
                    var form, input, bgcolor, browseButton;
                    currentFileId = plupload.guid();
                    fileIds.push(currentFileId);
                    form = document.createElement("form");
                    form.setAttribute("id", "form_" + currentFileId);
                    form.setAttribute("method", "post");
                    form.setAttribute("enctype", "multipart/form-data");
                    form.setAttribute("encoding", "multipart/form-data");
                    form.setAttribute("target", up.id + "_iframe");
                    form.style.position = "absolute";
                    input = document.createElement("input");
                    input.setAttribute("id", "input_" + currentFileId);
                    input.setAttribute("type", "file");
                    input.setAttribute("accept", mimes);
                    input.setAttribute("size", 1);
                    browseButton = getById(up.settings.browse_button);
                    if (up.features.triggerDialog && browseButton) plupload.addEvent(getById(up.settings.browse_button), "click", function(e) {
                        if (!input.disabled) input.click();
                        e.preventDefault();
                    }, up.id);
                    plupload.extend(input.style, {
                        width: "100%",
                        height: "100%",
                        opacity: 0,
                        fontSize: "99px",
                        cursor: "pointer"
                    });
                    plupload.extend(form.style, {
                        overflow: "hidden"
                    });
                    bgcolor = up.settings.shim_bgcolor;
                    if (bgcolor) form.style.background = bgcolor;
                    if (IE) plupload.extend(input.style, {
                        filter: "alpha(opacity=0)"
                    });
                    plupload.addEvent(input, "change", function(e) {
                        var element = e.target, name, files = [], topElement;
                        if (element.value) {
                            getById("form_" + currentFileId).style.top = -1048575 + "px";
                            name = element.value.replace(/\\/g, "/");
                            name = name.substring(name.length, name.lastIndexOf("/") + 1);
                            files.push(new plupload.File(currentFileId, name));
                            if (!up.features.triggerDialog) plupload.removeAllEvents(form, up.id); else plupload.removeEvent(browseButton, "click", up.id);
                            plupload.removeEvent(input, "change", up.id);
                            createForm();
                            if (files.length) uploader.trigger("FilesAdded", files);
                        }
                    }, up.id);
                    form.appendChild(input);
                    container.appendChild(form);
                    up.refresh();
                }
                function createIframe() {
                    var temp = document.createElement("div");
                    temp.innerHTML = '<iframe id="' + up.id + '_iframe" name="' + up.id + '_iframe" src="' + url + ':&quot;&quot;" style="display:none"></iframe>';
                    iframe = temp.firstChild;
                    container.appendChild(iframe);
                    plupload.addEvent(iframe, "load", function(e) {
                        var n = e.target, el, result;
                        if (!currentFile) return;
                        try {
                            el = n.contentWindow.document || n.contentDocument || window.frames[n.id].document;
                        } catch (ex) {
                            up.trigger("Error", {
                                code: plupload.SECURITY_ERROR,
                                message: plupload.translate("Security error."),
                                file: currentFile
                            });
                            return;
                        }
                        result = el.body.innerHTML;
                        if (result.match(/success/)) {
                            currentFile.status = plupload.DONE;
                            currentFile.loaded = 1025;
                            currentFile.percent = 100;
                            up.trigger("UploadProgress", currentFile);
                            up.trigger("FileUploaded", currentFile, {
                                response: result
                            });
                        } else up.trigger("Error", {
                            code: plupload.GENERIC_ERROR,
                            message: result,
                            file: currentFile
                        });
                    }, up.id);
                }
                if (up.settings.container) {
                    container = getById(up.settings.container);
                    if ("static" === plupload.getStyle(container, "position")) container.style.position = "relative";
                }
                up.bind("UploadFile", function(up, file) {
                    var form, input;
                    if (file.status == plupload.DONE || file.status == plupload.FAILED || up.state == plupload.STOPPED) return;
                    form = getById("form_" + file.id);
                    input = getById("input_" + file.id);
                    input.setAttribute("name", up.settings.file_data_name);
                    form.setAttribute("action", up.settings.url);
                    plupload.each(plupload.extend({
                        name: file.target_name || file.name
                    }, up.settings.multipart_params), function(value, name) {
                        var hidden = document.createElement("input");
                        plupload.extend(hidden, {
                            type: "hidden",
                            name: name,
                            value: value
                        });
                        form.insertBefore(hidden, form.firstChild);
                    });
                    currentFile = file;
                    getById("form_" + currentFileId).style.top = -1048575 + "px";
                    form.submit();
                });
                up.bind("FileUploaded", function(up) {
                    up.refresh();
                });
                up.bind("StateChanged", function(up) {
                    if (up.state == plupload.STARTED) createIframe(); else if (up.state == plupload.STOPPED) window.setTimeout(function() {
                        plupload.removeEvent(iframe, "load", up.id);
                        if (iframe.parentNode) iframe.parentNode.removeChild(iframe);
                    }, 0);
                    plupload.each(up.files, function(file, i) {
                        if (file.status === plupload.DONE || file.status === plupload.FAILED) {
                            var form = getById("form_" + file.id);
                            if (form) form.parentNode.removeChild(form);
                        }
                    });
                });
                up.bind("Refresh", function(up) {
                    var browseButton, topElement, hoverClass, activeClass, browsePos, browseSize, inputContainer, inputFile, zIndex;
                    browseButton = getById(up.settings.browse_button);
                    if (browseButton) {
                        browsePos = plupload.getPos(browseButton, getById(up.settings.container));
                        browseSize = plupload.getSize(browseButton);
                        inputContainer = getById("form_" + currentFileId);
                        inputFile = getById("input_" + currentFileId);
                        plupload.extend(inputContainer.style, {
                            top: browsePos.y + "px",
                            left: browsePos.x + "px",
                            width: browseSize.w + "px",
                            height: browseSize.h + "px"
                        });
                        if (up.features.triggerDialog) {
                            if ("static" === plupload.getStyle(browseButton, "position")) plupload.extend(browseButton.style, {
                                position: "relative"
                            });
                            zIndex = parseInt(browseButton.style.zIndex, 10);
                            if (isNaN(zIndex)) zIndex = 0;
                            plupload.extend(browseButton.style, {
                                zIndex: zIndex
                            });
                            plupload.extend(inputContainer.style, {
                                zIndex: zIndex - 1
                            });
                        }
                        hoverClass = up.settings.browse_button_hover;
                        activeClass = up.settings.browse_button_active;
                        topElement = up.features.triggerDialog ? browseButton : inputContainer;
                        if (hoverClass) {
                            plupload.addEvent(topElement, "mouseover", function() {
                                plupload.addClass(browseButton, hoverClass);
                            }, up.id);
                            plupload.addEvent(topElement, "mouseout", function() {
                                plupload.removeClass(browseButton, hoverClass);
                            }, up.id);
                        }
                        if (activeClass) {
                            plupload.addEvent(topElement, "mousedown", function() {
                                plupload.addClass(browseButton, activeClass);
                            }, up.id);
                            plupload.addEvent(document.body, "mouseup", function() {
                                plupload.removeClass(browseButton, activeClass);
                            }, up.id);
                        }
                    }
                });
                uploader.bind("FilesRemoved", function(up, files) {
                    var i, n;
                    for (i = 0; i < files.length; i++) {
                        n = getById("form_" + files[i].id);
                        if (n) n.parentNode.removeChild(n);
                    }
                });
                uploader.bind("DisableBrowse", function(up, disabled) {
                    var input = document.getElementById("input_" + currentFileId);
                    if (input) input.disabled = disabled;
                });
                uploader.bind("Destroy", function(up) {
                    var name, element, form, elements = {
                        inputContainer: "form_" + currentFileId,
                        inputFile: "input_" + currentFileId,
                        browseButton: up.settings.browse_button
                    };
                    for (name in elements) {
                        element = getById(elements[name]);
                        if (element) plupload.removeAllEvents(element, up.id);
                    }
                    plupload.removeAllEvents(document.body, up.id);
                    plupload.each(fileIds, function(id, i) {
                        form = getById("form_" + id);
                        if (form) container.removeChild(form);
                    });
                });
                createForm();
            });
            callback({
                success: true
            });
        }
    });
})(window, document, plupload);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.AssessmentPlugin", {
        data: {},
        init: function(ed, url) {
            var me = this;
            var plugin = this;
            this.editor = ed;
            ed.onKeyPress.addToTop(function(ed, e) {
                me.add("characters", 1);
            });
            ed.onInit.add(function(ed) {
                var editCallback = function(date) {
                    return me.getScore(date);
                };
                ws.assessment.schedule("edit", editCallback);
            });
        },
        add: function(category, count) {
            var bucket = this.getBucket();
            if (void 0 === bucket[category]) bucket[category] = 0;
            bucket[category] += count;
        },
        clearBucket: function(date) {
            if (date >= ws.assessment.getCurrentDate()) return;
            delete this.data[date];
        },
        getBucket: function(date) {
            if (!date) date = ws.assessment.getCurrentDate();
            if (!this.data[date]) this.data[date] = {};
            return this.data[date];
        },
        getData: function() {
            return this.data;
        },
        getScore: function(date) {
            var score = 0;
            if (!date) date = ws.assessment.getCurrentDate();
            if (!this.data[date]) return 0;
            jQuery.each(this.data[date], function(category, count) {
                switch (category) {
                  case "characters":
                    score += count;
                }
            });
            return score;
        },
        getInfo: function() {
            return {
                longname: "Wikispaces assessment",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.PluginManager.add("wsassessment", wikispaces.plugins.AssessmentPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.AutoloadPlugin", {
        init: function(ed, url) {
            this.editor = ed;
            var me = this;
            ed.onInit.add(function(ed) {
                if (ed.onInitSubEditor) ed.onInitSubEditor.add(function(subEditor) {
                    subEditor.onChange.add(function() {
                        tinymce.mainEditor.plugins.wsautosave.autosaveDelayed();
                    });
                });
                if (me.editor.plugins.wscommon.getOption("contentPresent")) {
                    me.loadVersionFromForm();
                    var autosaveForm = jQuery("#autosaveData").get(0);
                    if (autosaveForm) {
                        var autosaveContent = autosaveForm.autosaveContent.value;
                        var autosavePageComments = JSON.parse(autosaveForm.autosavePageComments.value);
                        var autosaveDate = autosaveForm.autosaveDate.value;
                        var autosaveVersion = autosaveForm.autosaveVersion.value;
                        var autosaveCleanup = autosaveForm.autosaveCleanup.value;
                        var autosaveAge = autosaveForm.autosaveAge.value;
                        var autosaveConflict = autosaveForm.autosaveConflict.value;
                        me.autoload(autosaveContent, autosavePageComments, autosaveDate, autosaveVersion, autosaveCleanup, autosaveAge, autosaveConflict);
                    }
                    me.editorLoaded();
                } else {
                    jQuery("#wsMainEditor_container").hide();
                    jQuery.ajax({
                        url: ws.common.pathFor("page", "dump", wikispaces_page, wikispaces_page_version),
                        type: "GET",
                        cache: false,
                        data: {
                            mode: ed.plugins.wscommon.getOption("mode"),
                            format: ed.plugins.wscommon.getOption("mode")
                        },
                        global: false,
                        error: function(request, errorString, errorException) {
                            me.error(request, errorString, errorException);
                        },
                        success: function(xml, textStatus, request) {
                            me.loadData(xml);
                            jQuery("#content_view").hide();
                            me.editorLoaded();
                        },
                        complete: function() {
                            jQuery("#wsMainEditor_container").show();
                            ed.plugins.wstoolbarscroll.moveScroller();
                        }
                    });
                }
            });
        },
        convertHtml: function() {
            jQuery("#contentEditButton").remove();
            jQuery("#content_view").contents().filter(function() {
                return 8 == this.nodeType && "ws:" != jQuery.trim(this.data).substring(0, 3);
            }).remove();
            return jQuery.trim(jQuery("#content_view").html().replace(/<!-- ws:start:WikiText[a-zA-Z]+Rule:(\d+):([\s\S]*?) -->[\s\S]*?<!-- ws:end:WikiText[a-zA-Z]+Rule:\1 -->/g, function() {
                if (arguments[2]) return jQuery("<div>").html(arguments[2]).text(); else return "";
            }));
        },
        getInfo: function() {
            return {
                longname: "Wikispaces autoload",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        error: function(request, errorString, errorException) {
            ws.common.track("Editor", "Start", "Inline Failure");
            ws.editor._editorDeferred.reject();
            document.location = ws.common.pathFor("page", "edit", wikispaces_page);
        },
        loadData: function(xml) {
            var me = this;
            var jXml = jQuery(xml);
            try {
                var checkoutStatus = jXml.find("checkout checkoutStatus").text();
                var checkoutUser = jXml.find("checkout checkoutUser").text();
                var checkoutDate = jXml.find("checkout checkoutDate").text();
                var checkoutRefreshDate = jXml.find("checkout checkoutRefreshDate").text();
                this.checkout(checkoutStatus, checkoutUser, checkoutDate, checkoutRefreshDate);
                var wikiPageData;
                var wikiPageDataChanged = parseInt(jXml.find("dump contentChanged").text());
                if (wikiPageDataChanged) wikiPageData = jXml.find("dump content").text(); else wikiPageData = this.convertHtml();
                var version = jXml.find("dump version").text();
                var editorCleanup = jXml.find("dump editorCleanup").text();
                var pageComments = JSON.parse(jXml.find("dump pageComments").text());
                this.loadVersion(wikiPageData, pageComments, version, editorCleanup);
                var autosaveContent = jXml.find("dump autosave autosaveContent").text();
                var autosaveDate = jXml.find("dump autosave autosaveDate").text();
                var autosaveVersion = jXml.find("dump autosave autosaveVersion").text();
                var autosaveCleanup = jXml.find("dump autosave autosaveCleanup").text();
                var autosaveAge = jXml.find("dump autosave autosaveAge").text();
                var autosaveConflict = jXml.find("dump autosave autosaveConflict").text();
                var pageComments = jXml.find("dump autosave autosavePageComments").text();
                var autosavePageComments = pageComments ? JSON.parse(pageComments) : {};
                this.autoload(autosaveContent, autosavePageComments, autosaveDate, autosaveVersion, autosaveCleanup, autosaveAge, autosaveConflict);
                ws.common.track("Editor", "Start", "Inline");
            } catch (e) {
                this.error();
            }
        },
        checkout: function(checkoutStatus, checkoutUser, checkoutDate, checkoutRefreshDate) {
            if ("locked" == checkoutStatus && (!wikispaces_isUserLoggedIn || checkoutUser != wikispaces_username)) {
                var checkoutMessage = "This page was locked for editing by " + checkoutUser + " on " + checkoutDate + ".  The page will be available for editing after the changes have been saved.";
                alert(this.checkoutMessage);
                document.location = ws.common.pathFor(wikispaces_page);
                return;
            }
        },
        loadVersionFromForm: function() {
            var content = jQuery("#wsMainEditor").val();
            var pageComments = JSON.parse(this.editor.plugins.wscommon.getOption("pageComments"));
            var version = this.editor.plugins.wscommon.getOption("version");
            var editorCleanup = this.editor.plugins.wscommon.getOption("editorCleanup");
            this.loadVersion(content, pageComments, version, editorCleanup);
        },
        loadVersion: function(wikiPageData, pageComments, version, cleanup) {
            var me = this;
            jQuery("html, body").animate({
                scrollTop: 0
            }, "fast");
            this.editor.plugins.wscommon.setOption("version", version);
            this.editor.plugins.wscommon.setOption("editorCleanup", cleanup);
            if ("plain" == this.editor.plugins.wscommon.getOption("mode")) this.editor.plugins.wstext.flipToText(wikiPageData); else {
                this.editor.setContent(wikiPageData, {
                    wsautoload: true
                });
                if (tinymce.isIE) cleanup += ",brTable";
                wikispaces.util.Cleanup.cleanup(this.editor, cleanup, false);
                this.editor.undoManager.clear();
                this.editor.setClean();
                this.editor.onModeSwitch.dispatch("visual");
                setTimeout(function() {
                    me.editor.focus();
                    me.editor.wsselection.ensureCursor();
                    me.editor.onNeedsResize.dispatch();
                }, 100);
                jQuery("img", this.editor.getBody()).load(function() {
                    me.editor.onNeedsResize.dispatch();
                }).each(function() {
                    this.src = this.src;
                });
            }
            this.editor.plugins.wscomment.loadComments(pageComments);
        },
        editorForm: function() {
            return jQuery(this.editor.getContainer()).closest("form").get(0);
        },
        autoload: function(autosaveContent, autosavePageComments, autosaveDate, autosaveVersion, autosaveCleanup, autosaveAge, autosaveConflict) {
            var me = this;
            if (autosaveDate) if (parseInt(autosaveConflict) && autosaveAge >= 60 * 24 * 60) {
                tinymce.mainEditor.plugins.wspopup.show("expiredDraft");
                jQuery("#expiredDraftDate").text(autosaveDate);
                jQuery("#expiredDraftContent").html(autosaveContent);
            } else {
                this.autosaveContent = autosaveContent;
                this.autosavePageComments = autosavePageComments;
                this.autosaveVersion = autosaveVersion;
                this.autosaveCleanup = autosaveCleanup;
                tinymce.mainEditor.plugins.wspopup.show("draftRecovered");
                jQuery("#recoveredDraftDate").text(autosaveDate);
                var version = this.editor.plugins.wscommon.getOption("version");
                if (autosaveVersion != version) {
                    jQuery("#outOfDateDraft").show();
                    var url = ws.common.pathFor("page", "diff", wikispaces_page) + "?v1=" + encodeURIComponent(autosaveVersion) + "&v2=" + encodeURIComponent(version);
                    jQuery("#outOfDateDraft a").attr("href", url);
                }
            }
            this.editor.onChange.add(function(ed, l, um) {
                me.editor.plugins.wsautosave.autosaveDelayed();
            });
        },
        editorLoaded: function() {
            window.setTimeout(function() {
                ws.editor._editorDeferred.resolve();
            }, 1e3);
        }
    });
    tinymce.PluginManager.add("wsautoload", wikispaces.plugins.AutoloadPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.AutosavePlugin", {
        AUTOSAVE_INTERVAL: 3e4,
        concurrentEditors: new Array(),
        savedVersions: new Array(),
        init: function(ed, url) {
            this.editor = ed;
            this.autosaveEnabled = tinymce.activeEditor.getParam("wsautosave_enabled");
            var plugin = this;
            ed.addCommand("wsautosave", function() {
                plugin.autosave();
            });
            ed.onInit.add(function() {
                if (!ws.editor.content.isLoaded) {
                    jQuery("#concurrentEditorDetails").prop("disabled", true);
                    ws.editor.content.add(function() {
                        jQuery("#concurrentEditorDetails").prop("disabled", false);
                    });
                }
                setInterval(function() {
                    tinymce.activeEditor.undoManager.add();
                }, 61e3);
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces autosave",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        autosaveDelayed: function() {
            var me = this;
            if (!this.autosaveDelayedHandle) this.autosaveDelayedHandle = setTimeout(function() {
                me.autosave(true);
            }, this.AUTOSAVE_INTERVAL);
        },
        autosave: function(async, content) {
            clearTimeout(this.autosaveDelayedHandle);
            delete this.autosaveDelayedHandle;
            if (!this.autosaveEnabled) {
                ws.common.log("not autosaving (disabled)", async);
                return;
            }
            ws.common.log("autosave", async);
            var me = this;
            if ("undefined" == typeof async) async = true;
            this.setStatus("Saving Draft...");
            if ("undefined" == typeof content) content = this.editor.plugins.wscommon.fullContent(false);
            ws.common.ajaxPost({
                queueName: "autosave",
                url: this.getAutosaveUrl(),
                type: "POST",
                iframe: false,
                async: async,
                dataType: "xml",
                data: {
                    content: content,
                    pageComments: this.editor.plugins.wscomment.newComments()
                }
            }).fail(function() {
                ws.session.reloadSession(function() {
                    me.autosave(async);
                }, 500, function() {
                    me.editor.plugins.wscommon.sessionReloadFailed();
                });
            }).done(function(data) {
                me.autosaveProcessResponse(data);
            });
            ws.common.log("autosave finished");
        },
        getAutosaveUrl: function() {
            var mode = this.editor.plugins.wscommon.getOption("mode");
            var version = this.editor.plugins.wscommon.getOption("version");
            return ws.common.pathFor("page", "autosave", wikispaces_page, version) + "?mode=" + encodeURIComponent(mode);
        },
        setStatus: function(status, error) {
            jQuery("#autosaveStatus").hide().html(status).fadeIn(2e3);
            if (error) jQuery("#autosaveStatus").css("color", "red");
        },
        autosaveProcessResponse: function(xml) {
            ws.common.log("autosaveProcessResponse", xml);
            var me = this;
            var jXml = jQuery(xml);
            var statusChanged = false;
            var time = jXml.find("autosave save").text();
            var error = jXml.find("autosave error").attr("message");
            if (time) this.setStatus("Draft Saved at " + time, false); else if (error) this.setStatus(error, true); else this.setStatus("");
            var savedVersionCount = this.savedVersions.length;
            if ("changed" == jXml.find("status").attr("type")) {
                this.savedVersions = new Array();
                var revisions = jXml.find("status revision").each(function() {
                    var user = jQuery(this).find("user").text();
                    var date = jQuery(this).find("date").text();
                    var versionId = jQuery(this).attr("id");
                    me.savedVersions.push({
                        id: versionId,
                        editor: user,
                        time: date
                    });
                });
            }
            if (this.savedVersions.length > savedVersionCount) {
                ws.common.track("Editor", "Concurrent Editing", "Concurrent Save");
                statusChanged = true;
            }
            var concurrentOn = this.concurrentEditors.length > 0;
            this.concurrentEditors = new Array();
            jXml.find("concurrent editor").each(function() {
                var user = jQuery(this).find("user").text();
                var date = jQuery(this).find("date").text();
                me.concurrentEditors.push({
                    editor: user,
                    time: date
                });
            });
            if (!concurrentOn && this.concurrentEditors.length) {
                ws.common.track("Editor", "Concurrent Editing", "Start");
                statusChanged = true;
            }
            if (concurrentOn && 0 == this.concurrentEditors.length) ws.common.track("Editor", "Concurrent Editing", "End");
            if (this.concurrentEditors.length) ws.common.track("Editor", "Concurrent Editing", "Editor Count", this.concurrentEditors.length);
            var mergeStatus = jQuery.trim(jXml.find("autosave merge mergeStatus").text());
            this.mergeResult = "";
            if ("failed" == mergeStatus) ws.common.track("Editor", "Concurrent Editing", "Merge Failed"); else if ("success" == mergeStatus) {
                ws.common.track("Editor", "Concurrent Editing", "Merge Success");
                this.mergeResult = jXml.find("autosave merge mergeResult").text();
            }
            this.mergeStatus = mergeStatus;
            if (statusChanged) this.statusUpdated();
        },
        showConcurrentEditorPopup: function() {
            tinymce.mainEditor.plugins.wspopup.show("concurrentEditor");
            if (this.savedVersions.length) {
                var version = this.editor.plugins.wscommon.getOption("version");
                jQuery("#concurrentEditor_savedVersions").empty();
                jQuery.each(this.savedVersions, function(index, revision) {
                    var element = jQuery('<li><img src="/user/pic/' + revision.editor + '-sm.jpg" height="16" width="16" style="vertical-align: text-top;"/> ' + revision.editor + " saved a new version at " + revision.time + '.  <a href="' + ws.common.pathFor("page", "diff", wikispaces_page) + "/" + revision.id + '" target="_new">View the changes</a></li>');
                    jQuery("#concurrentEditor_savedVersions").append(element);
                });
                if (this.savedVersions.length > 1) {
                    var latestRevision = this.savedVersions[this.savedVersions.length - 1].id;
                    jQuery("#concurrentEditor_savedVersion_viewChanges").html('<a href="' + ws.common.pathFor("page", "diff", wikispaces_page) + "?v1=" + version + "&v2=" + latestRevision + '" target="_new">View all changes since I started editing</a>').show();
                }
                jQuery("#concurrentEditor_savedVersion_heading").show();
            }
            if (this.concurrentEditors.length) {
                jQuery("#concurrentEditor_otherEditors").empty();
                jQuery.each(this.concurrentEditors, function(index, data) {
                    var element = jQuery('<li><img src="/user/pic/' + data.editor + '-sm.jpg" height="16" width="16" style="vertical-align: text-top"/> ' + data.editor + " started editing this page at " + data.time + "</li>");
                    jQuery("#concurrentEditor_otherEditors").append(element);
                });
                jQuery("#concurrentEditor_otherEditor_heading").show();
                jQuery("#concurrentEditor_noEditors").hide();
            } else {
                jQuery("#concurrentEditor_otherEditor_heading").hide();
                jQuery("#concurrentEditor_noEditors").show();
            }
            tinymce.mainEditor.plugins.wspopup.resize("concurrentEditor");
        },
        statusUpdated: function() {
            var me = this;
            var message = "";
            if (1 == this.savedVersions.length && !this.concurrentEditors.length) {
                var editor = this.savedVersions[0].editor;
                message = '<img src="/user/pic/' + editor + '-sm.jpg" height="16" width="16" style="vertical-align: text-top;"/> ' + editor + " saved this page.";
            } else if (this.savedVersions.length > 1 && !this.concurrentEditors.length) message = this.savedVersions.length + " people have saved this page."; else if (!this.savedVersions.length && 1 == this.concurrentEditors.length) {
                var editor = this.concurrentEditors[0].editor;
                message = '<img src="/user/pic/' + editor + '-sm.jpg" height="16" width="16" style="vertical-align: text-top;"/> ' + editor + " is editing.";
            } else if (!this.savedVersions.length && this.concurrentEditors.length > 1) message = this.concurrentEditors.length + " people are editing."; else if (this.savedVersions.length && this.concurrentEditors.length) message = "This page is being edited and has been saved."; else return;
            var notice = jQuery("#concurrentEditorNotice");
            if (!notice.get(0)) {
                notice = jQuery('<div id="concurrentEditorNotice" class="mceToolbar">').hide();
                var messageHolder = jQuery('<div id="concurrentEditorNoticeMessage" style="display: inline;">');
                messageHolder.html(message);
                var show = jQuery('<button class="wsbtn" id="concurrentEditorDetails">Details</button>');
                show.click(function(e) {
                    me.showConcurrentEditorPopup();
                    notice.hide();
                    e.preventDefault();
                    return false;
                });
                var hide = jQuery('<button class="wsbtn">Hide</button>');
                hide.click(function(e) {
                    notice.hide();
                    e.preventDefault();
                    return false;
                });
                notice.append(messageHolder).append(show).append(hide);
                jQuery(".mceExternalToolbar").append(notice);
            } else jQuery("#concurrentEditorNoticeMessage").html(message);
            if (!notice.is(":visible")) notice.slideDown();
        }
    });
    tinymce.PluginManager.add("wsautosave", wikispaces.plugins.AutosavePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.BlockFormatPlugin", {
        init: function(ed, url) {
            var me = this;
            this.editor = ed;
            ed.addCommand("wsFormatBlock", function(ui, v) {
                if (!tinymce.isIE) {
                    ed.undoManager.begin();
                    var bookmark = ed.selection.getBookmark(2);
                    if (jQuery(tinymce.activeEditor.selection.getNode()).closest("li").length > 0) {
                        ed.execCommand("FormatBlock", ui, "p");
                        ed.execCommand("FormatBlock", ui, v);
                        jQuery(tinymce.activeEditor.selection.getNode()).closest("li").find("p").each(function(i, elem) {
                            jQuery(elem).replaceWith(elem.childNodes);
                        });
                    } else {
                        ed.execCommand("FormatBlock", ui, v);
                        jQuery(ed.plugins.wscommon.getSiblingOfElement(ed.theme.getHeaderParent(ed.selection.getNode()), "previous")).filter("br").after("<br>");
                    }
                    ed.selection.moveToBookmark(bookmark);
                    ed.undoManager.end();
                } else {
                    var sel = jQuery(ed.selection.getNode());
                    if (sel.is("p") && 0 == sel.contents().length) sel.append("﻿");
                    ed.execCommand("FormatBlock", ui, v);
                }
            });
            ed.onKeyDown.add(function(ed, e) {
                if (13 == e.keyCode && e.shiftKey && jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6").length > 0 && !ed.wsselection.isAtTheEndOf("h1,h2,h3,h4,h5,h6")) {
                    var header = jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6").get(0);
                    ed.selection.setContent("<span id='_ws_tmp'></span>");
                    var span = jQuery("#_ws_tmp", ed.getDoc()).get(0);
                    ed.dom.split(header, span);
                    ed.plugins.wscommon.cursorToAndRemoveElement(jQuery("<span>", ed.getDoc()).prependTo(jQuery(span).next()));
                    jQuery(span).remove();
                    tinymce.dom.Event.cancel(e);
                }
            });
            if (tinymce.isWebKit) {
                var enterInHeading = false;
                ed.onKeyDown.add(function(ed, e) {
                    enterInHeading = 13 == e.keyCode && jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6").length > 0;
                });
                ed.onKeyUp.add(function(ed, e) {
                    if (enterInHeading && jQuery(ed.selection.getNode()).closest("div").length > 0) {
                        var span = jQuery("<span>", ed.getDoc()).replaceAll(jQuery(ed.selection.getNode()).closest("div")).after("<br/>");
                        ed.plugins.wscommon.cursorToAndRemoveElement(span);
                    }
                });
            }
            if (tinymce.isGecko) ed.onKeyUp.add(function(ed, e) {
                if (9 == e.keyCode) {
                    var p = jQuery(ed.selection.getNode()).closest("p");
                    if (/padding-left/.test(p.attr("style"))) {
                        p.css("padding-left", "");
                        if (ed.undoManager.add()) ed.undoManager.remove();
                    }
                }
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces block Format",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.PluginManager.add("wsblockformat", wikispaces.plugins.BlockFormatPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.BrToP", {
        init: function(ed, url) {
            var plugin = this;
            plugin.editor = ed;
            ed.onBeforeSetContent.add(function(ed, o) {
                if ("raw" != o.format && "visual" == ed.plugins.wscommon.getOption("mode")) o.content = plugin.processContent(o.content);
            });
            if (ed.plugins["paste"]) ed.plugins["paste"].onPostProcess.add(function(pl, o) {
                if (jQuery.browser.msie) {
                    jQuery("span[style]", o.node).each(function() {
                        var span = jQuery(this);
                        if ("left" == span.css("text-align")) span.css("text-align", "");
                    });
                    jQuery("span:empty", o.node).remove();
                    jQuery("p br", o.node).remove();
                    jQuery("li br", o.node).remove();
                }
                var content = jQuery(o.node).html();
                jQuery(o.node).html(plugin.processContent(content));
            });
            ed.onKeyDown.add(function(ed, e) {
                if (e.shiftKey && 13 == e.keyCode) {
                    var blockParent = jQuery(ed.selection.getNode()).closest("li,td,th,p,pre,code");
                    if (blockParent.is("pre,code")) return;
                    e.stopPropagation();
                    e.preventDefault();
                    ed.undoManager.begin();
                    ed.selection.setContent('<span id="wsTemp">﻿</span>');
                    if (!blockParent.is("p")) {
                        blockParent.wrapInner('<p id="wsHolder">');
                        blockParent = jQuery(blockParent).find("#wsHolder").removeAttr("id");
                    }
                    if (blockParent.children().last().is("br")) blockParent.children().last().remove();
                    var isFirst = true;
                    var isLast = true;
                    var foundTemp = false;
                    jQuery(blockParent).contents().each(function(i, elem) {
                        if (foundTemp && (1 == elem.nodeType || !ed.plugins.wscommon.isTextEmpty(elem.nodeValue))) isLast = false;
                        if (jQuery(elem).is("#wsTemp")) foundTemp = true;
                        if (!foundTemp && (1 == elem.nodeType || !ed.plugins.wscommon.isTextEmpty(elem.nodeValue))) isFirst = false;
                    });
                    if (!foundTemp) {
                        isFirst = false;
                        var node = jQuery(blockParent).contents().get(0);
                        while (!foundTemp && node) {
                            var i = 1;
                            while (node && 3 == node.nodeType && ed.plugins.wscommon.isTextEmpty(node.nodeValue)) node = jQuery(node).parent().contents().get(i++);
                            if (jQuery(node).is("#wsTemp")) {
                                foundTemp = true;
                                isFirst = true;
                            } else node = jQuery(node).contents().get(0);
                        }
                        isLast = false;
                        node = jQuery(blockParent).contents().last().get(0);
                        while (!foundTemp && node) {
                            var i = jQuery(node).parent().contents().length - 2;
                            while (node && 3 == node.nodeType && ed.plugins.wscommon.isTextEmpty(node.nodeValue)) node = jQuery(node).parent().contents().get(i--);
                            if (jQuery(node).is("#wsTemp")) {
                                foundTemp = true;
                                isLast = true;
                            } else node = jQuery(node).contents().last().get(0);
                        }
                    }
                    if (!isFirst && !isLast) {
                        ed.dom.split(blockParent.get(0), jQuery("#wsTemp", ed.getDoc()).get(0));
                        ed.selection.select(jQuery("#wsTemp", ed.getDoc()).next("p").get(0), true);
                        ed.selection.collapse(true);
                    } else if (isLast) {
                        jQuery("#wsTemp", ed.getDoc()).closest("p").after("<p><br/></p>");
                        if (ed.plugins.wscommon.isNodeEmpty(jQuery("#wsTemp", ed.getDoc()).closest("p")) && 0 == jQuery("#wsTemp", ed.getDoc()).closest("p").children().not("#wsTemp").length) jQuery("#wsTemp", ed.getDoc()).after("<br/>");
                        ed.selection.select(jQuery("#wsTemp", ed.getDoc()).closest("p").next("p").get(0), true);
                        ed.selection.collapse(true);
                    } else if (isFirst) {
                        jQuery("#wsTemp", ed.getDoc()).closest("p").before("<p><br/></p>");
                        ed.selection.select(jQuery("#wsTemp", ed.getDoc()).closest("p").get(0), true);
                        ed.selection.collapse(true);
                    }
                    jQuery("#wsTemp", ed.getDoc()).remove();
                    ed.undoManager.end();
                    return false;
                }
            });
        },
        processContent: function(content) {
            var div = jQuery("<div>", this.editor.getDoc()).html(content);
            this.convertDisplayBlockToDiv(div);
            this.convertBrToP(div);
            return div.html();
        },
        convertDisplayBlockToDiv: function(content) {
            var ed = this.editor;
            jQuery("span", content).each(function(i, elem) {
                var t = jQuery(elem);
                var textAlign = t.css("text-align"), style = t.attr("style");
                if ("block" == t.css("display") || style && style.match(/text-align/i) && ("left" == textAlign || "right" == textAlign || "center" == textAlign || "justify" == textAlign)) {
                    t.css("display", "");
                    var div = jQuery("<div>", ed.getDoc()).html(t.html());
                    if (t.attr("style")) div.attr("style", t.attr("style"));
                    t.replaceWith(div);
                }
            });
        },
        convertBrToP: function(div) {
            var plugin = this;
            this.splitOnBr(div);
            this.convertBrToPElements(div);
            var emptyCell = jQuery.browser.msie ? "<BR>" : "<br>\n";
            jQuery(div).find("th,td").each(function(i, elem) {
                if (elem.innerHTML == emptyCell) elem.innerHTML = "&nbsp;"; else plugin.convertBrToPElements(jQuery(elem));
            });
        },
        splitOnBr: function(div) {
            var ed = this.editor;
            jQuery(div).find("br").each(function(i, elem) {
                while (!jQuery(elem).parent().is("td,th,li,pre,code,div,body")) ed.dom.split(elem.parentNode, elem);
            });
        },
        convertBrToPElements: function(div) {
            var ed = this.editor;
            var currentP = null;
            jQuery(div).contents().each(function(i, elem) {
                if (1 == elem.nodeType && "br" == elem.nodeName.toLowerCase()) {
                    if (!currentP) {
                        currentP = jQuery("<p>", ed.getDoc()).insertBefore(elem);
                        currentP = null;
                    } else currentP = null;
                    jQuery(elem).remove();
                } else if (3 == elem.nodeType || 1 == elem.nodeType && !ed.dom.isBlock(elem)) {
                    if (!currentP) {
                        if (3 == elem.nodeType && ed.plugins.wscommon.isTextEmpty(elem.nodeValue)) return;
                        currentP = jQuery("<p>", ed.getDoc()).insertBefore(elem);
                    }
                    currentP.append(elem);
                } else if (1 == elem.nodeType && ed.dom.isBlock(elem)) currentP = null;
            });
        }
    });
    tinymce.PluginManager.add("wsbrtop", wikispaces.plugins.BrToP);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("static wikispaces.util.Cleanup", {
        cleanupEmptySpans: function(spans) {
            ws.common.log("cleanupEmptySpans", spans);
            for (var i = spans.length - 1; i >= 0; i--) {
                var jSpan = jQuery(spans[i]);
                if (jSpan.is(".commentBase") || jSpan.is(".commentRef")) continue;
                var trim = jQuery.trim(jSpan.text());
                if (jSpan.parents("body").length > 0 && (0 == spans[i].childNodes.length || 1 == spans[i].childNodes.length && 3 == spans[i].childNodes[0].nodeType && ("" == trim || 8203 == trim.charCodeAt(0)))) jSpan.replaceWith(jSpan.text());
            }
        },
        cleanupEmptyDivs: function(divs) {
            ws.common.log("cleanupEmptyDivs", divs);
            for (var i = divs.length - 1; i >= 0; i--) {
                var jDiv = jQuery(divs[i]);
                var trim = jQuery.trim(jDiv.text());
                if (jDiv.parents("body").length > 0 && (0 == divs[i].childNodes.length || 1 == divs[i].childNodes.length && 3 == divs[i].childNodes[0].nodeType && ("" == trim || 8203 == trim.charCodeAt(0)))) jDiv.replaceWith("<div> </div>");
            }
        },
        cleanupNoAttributeSpans: function(content) {
            var me = this;
            ws.common.log("cleanupNoAttributeSpans");
            jQuery(content).find("span").each(function() {
                if (me.selectedSpans && this == me.selectedSpans[0]) return;
                var jSpan = jQuery(this);
                if (!jSpan.attr("style") && !jSpan.attr("class")) jSpan.replaceWith(jSpan.contents());
            });
            if (jQuery(content).find(":last").is("span,div") || jQuery(content).find(":last").is("br") && jQuery(content).find(":last").prev().is("span,div")) jQuery(content).append("&nbsp;");
        },
        getStyleArray: function(node) {
            if (!node) return {};
            var style = jQuery(node).attr("style");
            if (!style) return {};
            return tinymce.activeEditor.dom.parseStyle(style);
        },
        normalizeCssSelector: function(value) {
            if (value == value.toUpperCase()) value = value.toLowerCase();
            return ws.common.camelize(value);
        },
        mergeStyles: function(parentArray, childArray) {
            var resultArray = {};
            for (var attr in parentArray) if ("function" != typeof parentArray[attr]) resultArray[attr] = parentArray[attr];
            for (var attr in childArray) if ("function" != typeof childArray[attr]) resultArray[attr] = this.mergeCss(parentArray[attr], attr, childArray[attr]);
            return resultArray;
        },
        collapseNodes: function(spans) {
            ws.common.log("collapseNodes");
            var newSpans = Array();
            for (var i = spans.length - 1; i >= 0; i--) if (jQuery(spans[i]).parents("body").length > 0) {
                var newNode = this.collapseNodeDown(spans[i]);
                newSpans[newSpans.length] = newNode;
            }
            return newSpans;
        },
        flattenNodes: function(spans) {
            ws.common.log("flattenNodes", spans);
            for (var i = spans.length - 1; i >= 0; i--) {
                var moreSpans = [ jQuery(spans[i]) ];
                var thisSpan;
                while (thisSpan = moreSpans.pop()) {
                    var original = thisSpan.parent();
                    if (!original.is(thisSpan.get(0).tagName)) continue;
                    ws.common.log("flattening", thisSpan.get(0), thisSpan.html());
                    var originalContents = original.contents();
                    var index = originalContents.index(thisSpan);
                    var duplicate = original.clone().empty().append(originalContents.slice(index + 1));
                    jQuery(original).after(duplicate).after(thisSpan);
                    var replaceStyles = this.mergeStyles(this.getStyleArray(original.get(0)), this.getStyleArray(thisSpan.get(0)));
                    for (var attr in replaceStyles) if ("function" != typeof replaceStyles[attr]) try {
                        thisSpan.css(attr, replaceStyles[attr]);
                    } catch (e) {}
                    if ("" == jQuery.trim(original.html())) original.remove();
                    if ("" == jQuery.trim(duplicate.html())) duplicate.remove(); else moreSpans.push(duplicate);
                    moreSpans.push(thisSpan);
                }
            }
        },
        collapseNodeDown: function(span) {
            while (jQuery(span).parent().is(jQuery(span).get(0).tagName) && jQuery(span).parent().attr("class") == jQuery(span).attr("class") && 1 == jQuery(span).parent().children().length) {
                var good = true;
                for (var i = 0; i < span.parentNode.childNodes.length; i++) if (3 == span.parentNode.childNodes[i].nodeType && "" == !jQuery.trim(span.parentNode.childNodes[i].nodeValue)) {
                    good = false;
                    break;
                }
                if (!good) break;
                span = span.parentNode;
            }
            var prepend = "";
            var append = "";
            var replaceStyles = this.getStyleArray(span);
            var thisSpan = span;
            while (1 == jQuery(thisSpan).children().length && jQuery(thisSpan).children().eq(0).is(thisSpan.tagName) && jQuery(thisSpan).attr("class") == jQuery(thisSpan).children().eq(0).attr("class")) {
                var prependMode = true;
                var good = true;
                for (var i = 0; i < thisSpan.childNodes.length; i++) if (1 == thisSpan.childNodes[i].nodeType) prependMode = false; else if (3 == thisSpan.childNodes[i].nodeType && "" == jQuery.trim(thisSpan.childNodes[i].nodeValue)) if (prependMode) prepend += thisSpan.childNodes[i].nodeValue; else append += thisSpan.childNodes[i].nodeValue; else {
                    good = false;
                    break;
                }
                if (!good) break;
                thisSpan = jQuery(thisSpan).children().get(0);
                replaceStyles = this.mergeStyles(replaceStyles, this.getStyleArray(thisSpan));
            }
            if (thisSpan && thisSpan != span) {
                jQuery(thisSpan).prepend(prepend);
                jQuery(thisSpan).append(append);
                var replaceHtml = jQuery(thisSpan).html();
                jQuery(span).empty();
                jQuery(span).html(replaceHtml);
                for (var attr in replaceStyles) if ("function" != typeof replaceStyles[attr]) try {
                    jQuery(span).css(attr, replaceStyles[attr]);
                } catch (e) {}
            }
            return span;
        },
        mergeNodes: function(nodes) {
            ws.common.log("mergeNodes", nodes);
            if (!nodes || 0 == nodes.length) return;
            var editorDocument = this.editorDocument;
            var tagName = nodes[0].tagName;
            var working = true;
            while (working) {
                working = false;
                jQuery(editorDocument.body).find(tagName + " + br").each(function() {
                    if (1 == this.previousSibling.nodeType) {
                        working = true;
                        jQuery(this).prev().append("<br/>");
                        jQuery(this).remove();
                    }
                });
            }
            jQuery(editorDocument.body).find(tagName).each(function() {
                var nextNode = this.nextSibling;
                if (nextNode && 3 == nextNode.nodeType && "" == jQuery.trim(nextNode.nodeValue) && nextNode.nextSibling && 1 == nextNode.nextSibling.nodeType && nextNode.nextSibling.tagName == tagName.toUpperCase() && jQuery(nextNode.nextSibling).attr("style") == jQuery(this).attr("style") && jQuery(nextNode.nextSibling).attr("class") == jQuery(this).attr("class")) {
                    jQuery(this).append(nextNode.nodeValue);
                    nextNode.parentNode.removeChild(nextNode);
                }
            });
            for (var i = nodes.length - 1; i >= 0; i--) if (jQuery(nodes[i]).parents("body").length > 0) this.mergeNode(nodes[i]);
            working = true;
            while (working) {
                working = false;
                jQuery(editorDocument.body).find(tagName + " br:last-child").each(function() {
                    if (!this.nextSibling) {
                        working = true;
                        jQuery(this).parent().after("<br/>");
                        jQuery(this).remove();
                    }
                });
            }
            ws.common.log("end mergeNodes", nodes);
        },
        mergeNode: function(node) {
            var jNode = jQuery(node);
            if (node.previousSibling && node.previousSibling.tagName == node.tagName && jNode.prev().attr("class") == jNode.attr("class") && jNode.prev().attr("style") == jNode.attr("style")) {
                var leftNode = jNode.prev();
                leftNode.html(leftNode.html() + jNode.html());
                jNode.remove();
            }
        },
        mergeCss: function(parentValue, attr, value) {
            if (!parentValue || "fontSize" != attr) return value;
            var parentValueNoUnit = parentValue.substr(0, parentValue.length - 2);
            var parentUnit = parentValue.substr(parentValue.length - 2, 2);
            if ("%" == parentUnit[1]) {
                parentUnit = "%";
                parentValueNoUnit = parentValue.substr(0, parentValue.length - 1);
            }
            var unit = value.substr(value.length - 2, 2);
            var valueNoUnit = value.substr(0, value.length - 2);
            if ("%" == unit[1]) {
                unit = "%";
                valueNoUnit = value.substr(0, value.length - 1);
            }
            if ("em" == unit || "ex" == unit) {
                unit = "%";
                valueNoUnit = 100 * valueNoUnit;
            }
            if ("em" == parentUnit || "ex" == parentUnit) {
                parentUnit = "%";
                parentValueNoUnit = 100 * parentValueNoUnit;
            }
            if ("%" == unit) {
                var newValue = Math.round(100 * parentValueNoUnit * valueNoUnit) / (100 * 100);
                return newValue + parentUnit;
            } else return value;
        },
        removeBrInTable: function(content) {
            var cells = jQuery(content).find("td br:last-child, th br:last-child").remove();
        },
        removeSafariSpans: function(content) {
            ws.common.log("removeSafariSpans");
            jQuery("span.wkzw", content).remove();
            jQuery("span", content).removeClass("Apple-tab-span Apple-style-span");
            this.cleanupNoAttributeSpans(content);
        },
        removeMsoStyles: function(spans) {
            var me = this;
            jQuery(spans).each(function() {
                var styles = me.getStyleArray(this);
                var foundMso = false;
                for (var attr in styles) if ("function" == typeof styles[attr]) delete styles[attr]; else if (0 == attr.indexOf("mso")) {
                    delete styles[attr];
                    foundMso = true;
                }
                if (foundMso) try {
                    var newSpan = jQuery("<" + jQuery(this)[0].tagName + ">", this.ownerDocument).attr("class", jQuery(this).attr("class")).html(jQuery(this).html()).attr("id", jQuery(this).attr("id")).css(styles);
                    jQuery(this).replaceWith(newSpan);
                } catch (e) {}
            });
        },
        actionableSpans: function(content) {
            return jQuery(content).find("span");
        },
        actionableDivs: function(content) {
            return jQuery(content).find("div");
        },
        cleanup: function(editor, editorCleanup, showPopup) {
            var me = this;
            ws.common.log("cleanup", editorCleanup);
            if ("none" == editorCleanup) return;
            var cleanings = new Array();
            if (editorCleanup) cleanings = editorCleanup.split(",");
            if (cleanings.length > 0) {
                this.editorDocument = editor.getDoc();
                var content = this.editorDocument.body;
                var popup = null;
                if (showPopup) popup = tinymce.mainEditor.plugins.wspopup.show("cleanupPopupContents");
                jQuery.each(cleanings, function(i, cleaning) {
                    switch (cleaning) {
                      case "safari":
                        me.removeSafariSpans(content);
                        return;

                      case "mso":
                        me.removeMsoStyles(me.actionableSpans(content));
                        return;

                      case "collapse":
                        me.collapseNodes(me.actionableSpans(content));
                        return;

                      case "merge":
                        me.mergeNodes(me.actionableSpans(content));
                        return;

                      case "flatten":
                        me.flattenNodes(me.actionableSpans(content));
                        return;

                      case "empty":
                        me.cleanupEmptySpans(me.actionableSpans(content));
                        me.cleanupEmptyDivs(me.actionableDivs(content));
                        return;

                      case "bookmarks":
                        jQuery(content).find("span[_mce_type='bookmark']").remove();
                        return;

                      case "trailingLinebreaks":
                        jQuery(content).find("p > br:last-child, div > br:last-child").remove();
                        return;

                      case "brTable":
                        me.removeBrInTable(content);
                        return;

                      case "relativeFiles":
                        jQuery(content).find("img").each(function() {
                            if (jQuery(this).attr("src").match(/^file\/view/)) jQuery(this).attr("src", "/" + jQuery(this).attr("src")); else if (jQuery(this).attr("src").match(/^\.\.\/\.\.\/file\/view/)) jQuery(this).attr("src", jQuery(this).attr("src").slice(5));
                        });
                        return;
                    }
                });
                if (popup) popup.close();
            }
        }
    });
    tinymce.PluginManager.add("wscleanup", wikispaces.util.Cleanup);
})(tinymce, jQuery);

(function(tinymce) {
    tinymce.create("wikispaces.popups.Cleanup", {
        init: function(ed) {
            ed.plugins.wspopup.register({
                wsname: "cleanupPopupContents",
                title: "Optimize Page",
                width: 340,
                height: 160
            });
        }
    });
    tinymce.PluginManager.add("wscleanuppopup", wikispaces.popups.Cleanup);
})(tinymce);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.CommentPlugin", {
        popup: null,
        init: function(ed, url) {
            this.editor = ed;
            var plugin = this;
            WikispacesCommentManager.clear();
            WikispacesCommentManager.readOnly = false;
            ed.addButton("wscomment", {
                title: "Add Comment",
                label: "Comment",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsComment");
                }
            });
            ed.onInit.add(function() {
                _.defer(function() {
                    WikispacesCommentManager.showAll();
                });
                _.delay(function() {
                    WikispacesCommentManager.redrawAll();
                }, 1e3);
                _.delay(function() {
                    WikispacesCommentManager.redrawAll();
                }, 3e3);
            });
            ed.onModeSwitch.add(function(mode) {
                if ("visual" == mode) _.defer(function() {
                    WikispacesCommentManager.showAll();
                }); else if ("plain" == mode) WikispacesCommentManager.hideAll();
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces comment",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        isAutoSaveComments: function(commentData) {
            return _(commentData).any(function(obj) {
                return _.isString(obj);
            });
        },
        loadComments: function(commentData) {
            if (this.isAutoSaveComments(commentData)) WikispacesCommentManager.retrieveData(function() {
                _(commentData).each(function(bodyOrMemo, commentId) {
                    var comment = WikispacesCommentManager.commentById(commentId);
                    var body = _(bodyOrMemo).isString() ? bodyOrMemo : bodyOrMemo["body"];
                    if (comment) comment.setReply(body); else WikispacesCommentManager.addComment(new WikispacesComment({
                        content: body,
                        commentId: commentId
                    }));
                });
            }); else WikispacesCommentManager.commentsFromDigests(commentData);
            jQuery(".commentColumn").insertAfter("#wsMainEditor_external");
            jQuery(".commentColumn").css("right", -58);
        },
        newComments: function() {
            return _(WikispacesCommentManager.unsavedComments()).reduce(function(memo, comment) {
                memo[comment.commentId()] = comment.memo();
                return memo;
            }, {});
        },
        markCommentsSaved: function() {
            WikispacesCommentManager.markCommentsSaved();
        }
    });
    tinymce.PluginManager.add("wscomment", wikispaces.plugins.CommentPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.CommentSpacePlugin", {
        popup: null,
        MINIMUM_REDISCOVER_MILLISECONDS: 600,
        init: function(ed, url) {
            this.editor = ed;
            var plugin = this;
            this.commentSpace = null;
            this.commentsDisabled = !!ed.plugins.wscommon.getOption("commentsDisabled");
            ed.onInit.add(function() {
                jQuery(".mceIframeContainer iframe").css("background-color", "transparent").attr("allowTransparency", true);
                plugin.commentSpace = new WikispacesCommentSpace(ed.getBody(), ed.getContainer(), ed.getContainer(), jQuery(ed.getContainer()).find(".mceIframeContainer"), ed);
                ed.theme.controlManager().setDisabled("wscomment", plugin.commentsDisabled);
            });
            ed.onSetContent.add(function() {
                var lastMarker = jQuery("a.range[name^=comment-]:last", ed.getBody());
                if (lastMarker.size() > 0 && 0 == lastMarker.next().size() && (lastMarker.parent().is("body") || 0 == lastMarker.parent().next().size())) jQuery(ed.getBody()).append("<p><br/></p>");
            });
            ed.onRemove.add(function() {
                if (plugin.commentSpace) {
                    WikispacesCommentManager.removeSpace(plugin.commentSpace);
                    plugin.commentSpace = null;
                }
            });
            ed.addCommand("wsComment", function() {
                if (ed.wsselection && ed.wsselection.withinCode()) return;
                if (ed.selection.isCollapsed()) return;
                var comment = new WikispacesComment();
                ed.wsselection.normalizeOutsideLinks();
                var fore = ed.selection.getRng(true).cloneRange();
                var aft = ed.selection.getRng(true).cloneRange();
                fore.collapse(true);
                aft.collapse(false);
                var nbsp = ed.getDoc().createTextNode(" ");
                aft.insertNode(nbsp);
                function nextSiblingsText(node) {
                    if (!node) return ""; else return (1 == node.nodeType ? jQuery(node).text() : node.nodeValue || "") + nextSiblingsText(node.nextSibling);
                }
                if (jQuery.trim(nextSiblingsText(nbsp.nextSibling))) nbsp.parentNode.removeChild(nbsp);
                var closer = comment.generateCloser(ed.getDoc());
                aft.insertNode(closer);
                var opener = comment.generateOpener(ed.getDoc());
                fore.insertNode(opener);
                if (tinymce.isIE) {
                    closer = jQuery(closer);
                    if (!closer.parent().is("p") && closer.prev().is("p")) closer.appendTo(closer.prev());
                    if (jQuery.browser.version <= 8) {
                        ed.dom.setOuterHTML(opener, ed.dom.createHTML("a", {
                            name: comment.openAnchorName(),
                            "class": "range"
                        }, ""));
                        ed.dom.setOuterHTML(closer, ed.dom.createHTML("a", {
                            name: comment.closeAnchorName(),
                            "class": "range"
                        }, ""));
                    }
                }
                WikispacesCommentManager.addComment(comment);
                comment.open();
                ed.selection.collapse();
            });
            var lastRediscover = 0;
            var redrawComments = function(force) {
                var requestTime = new Date().getTime();
                if (requestTime - lastRediscover < plugin.MINIMUM_REDISCOVER_MILLISECONDS) setTimeout(function() {
                    if (lastRediscover < requestTime) {
                        lastRediscover = new Date().getTime();
                        WikispacesCommentManager.redrawAll(force);
                    }
                }, plugin.MINIMUM_REDISCOVER_MILLISECONDS); else {
                    lastRediscover = requestTime;
                    WikispacesCommentManager.redrawAll(force);
                }
            };
            ed.onChange.add(function(ed) {
                setTimeout(redrawComments, 0);
            });
            ed.onUndo.add(function() {
                redrawComments(true);
            });
            ed.onRedo.add(function() {
                redrawComments(true);
            });
            ed.onKeyUp.add(redrawComments);
        },
        getInfo: function() {
            return {
                longname: "Wikispaces comment space",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        loadComments: function(commentData) {
            WikispacesCommentManager.load(commentData);
        }
    });
    tinymce.PluginManager.add("wscommentspace", wikispaces.plugins.CommentSpacePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.CommonPlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.onLoadContent.add(function(ed) {
                plugin.startingSpanCount = jQuery(ed.getDoc()).find("span").length;
            });
            if (jQuery.browser.mozilla || jQuery.browser.webkit) ed.onBeforeSetContent.add(function(ed, o) {
                if (o.content.match(/<hr ?\/>\s*$/)) o.content += "<br/>";
            });
            if (ed.plugins["paste"]) {
                ed.plugins["paste"].onPreProcess.add(function(pl, o) {
                    o.content = o.content.replace(/<\/?pre>/gi, "");
                });
                var pasteCssWhitelist = [ "font-family", "font-size", "background-color", "text-align", "vertical-align", "text-decoration", "color" ];
                ed.plugins["paste"].onPostProcess.add(function(pl, o) {
                    jQuery("*", o.node).each(function() {
                        var elem = jQuery(this);
                        if (!elem.attr("style")) return;
                        var elemStyles = {};
                        jQuery.each(pasteCssWhitelist, function(i, css) {
                            if (elem.attr("style").match(new RegExp("\\b" + css + "\\b", "i"))) elemStyles[css] = elem.css(css);
                        });
                        elem.attr("style", "");
                        elem.css(elemStyles);
                    });
                    wikispaces.util.Cleanup.collapseNodes(jQuery("span", o.node));
                    wikispaces.util.Cleanup.flattenNodes(jQuery("span", o.node));
                });
            }
        },
        getInfo: function() {
            return {
                longname: "Wikispaces common",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        fullContent: function(showPopup, cleanups) {
            if ("visual" == this.editor.plugins.wscommon.getOption("mode")) {
                try {
                    var modes = cleanups ? cleanups.split(",") : [];
                    modes.push("mso");
                    modes.push("merge");
                    modes.push("relativeFiles");
                    var spanCount = jQuery(this.editor.getDoc()).find("span").length;
                    if (spanCount != this.startingSpanCount) modes.push("collapse");
                    if (tinymce.isWebKit) modes.push("safari");
                    wikispaces.util.Cleanup.cleanup(this.editor, modes.join(","), showPopup);
                    this.startingSpanCount = jQuery(this.editor.getDoc()).find("span").length;
                } catch (e) {}
                jQuery("img[data-mce-src]", this.editor.getDoc()).each(function() {
                    jQuery(this).attr("src", jQuery(this).data("mce-src"));
                });
                return this.editor.plugins.wsreference.pushInReferences(this.editor.getContent({
                    format: "raw"
                }));
            } else return jQuery("#textEditor").val();
        },
        editorIFrame: function() {
            return document.getElementById(this.editor.id + "_ifr");
        },
        editorToolbar: function() {
            return document.getElementById(this.editor.id + "_external");
        },
        editorContainer: function() {
            return document.getElementById(this.editor.id + "_container");
        },
        sessionReloadFailed: function() {
            var mainEditor = tinymce.mainEditor;
            this.reloadFailed = true;
            mainEditor.plugins.wsautosave.autosaveEnabled = false;
            mainEditor.plugins.wsautosave.setStatus("Autosave Disabled", true);
            mainEditor.controlManager.setDisabled("wspreview", true);
            mainEditor.controlManager.setDisabled("wsimage", true);
            mainEditor.plugins.wslinkpopup.disableSelect();
            alert("Your connection to Wikispaces has been disrupted.  We recommend you save your page now, and try editing the page again.");
        },
        getIframeInParentWindow: function(element) {
            var doc = element.ownerDocument;
            var parentWindow = doc.parentWindow;
            if (!parentWindow) parentWindow = doc.defaultView;
            if (!parentWindow) return null;
            if (parentWindow.parent == parentWindow) return null;
            return parentWindow.frameElement;
        },
        absoluteOffset: function(element) {
            var valueT = 0, valueL = 0;
            while (element) {
                if ("BODY" == element.tagName.toUpperCase()) {
                    element = this.getIframeInParentWindow(element);
                    if (!element) break;
                }
                valueT += element.offsetTop || 0;
                valueL += element.offsetLeft || 0;
                element = element.offsetParent;
            }
            return {
                left: valueL,
                top: valueT
            };
        },
        getPositionWith: function(elem, target, extraOffset) {
            target = jQuery(target);
            elem = jQuery(elem);
            var targetOffset = this.absoluteOffset(target[0]);
            var baseOffset = this.absoluteOffset(elem[0].offsetParent);
            var left = targetOffset.left + target.outerWidth() - baseOffset.left;
            var top = targetOffset.top + target.outerHeight() - baseOffset.top;
            if (extraOffset) {
                top += extraOffset;
                left += extraOffset;
            }
            var elementWidth = elem.outerWidth();
            var elementHeight = elem.outerHeight();
            var container = jQuery(this.editor.getContentAreaContainer());
            var containerOffset = this.absoluteOffset(container[0]);
            var containerRight = containerOffset.left + container.outerWidth();
            var containerBottom = containerOffset.top + container.outerHeight();
            if (baseOffset.left + left + elementWidth > containerRight) left = containerRight - elementWidth - baseOffset.left;
            if (baseOffset.top + top + elementHeight > containerBottom) top = containerBottom - elementHeight - baseOffset.top;
            if (top < containerOffset.top) top = containerOffset.top - baseOffset.top;
            if (left < containerOffset.left) left = containerOffset.left - baseOffset.left;
            return {
                left: left,
                top: top
            };
        },
        positionBelow: function(elementToPosition, attachTo) {
            attachTo = jQuery(attachTo);
            elementToPosition = jQuery(elementToPosition);
            var offset = this.absoluteOffset(attachTo[0]);
            var scrollLeft = jQuery(window).scrollLeft();
            var scrollTop = jQuery(window).scrollTop();
            var absoluteLeft = offset.left + 2;
            var absoluteTop = offset.top + attachTo.outerHeight() + 4;
            var elementWidth = elementToPosition.outerWidth();
            var viewportRight = jQuery(window).width() + scrollLeft;
            if (absoluteLeft + elementWidth > viewportRight) absoluteLeft = viewportRight - elementWidth;
            var elementHeight = elementToPosition.outerHeight();
            var viewportBottom = jQuery(window).height() + scrollTop;
            if (absoluteTop + elementHeight > viewportBottom) absoluteTop = viewportBottom - elementHeight;
            if (absoluteTop < scrollTop) absoluteTop = scrollTop;
            if (absoluteLeft < scrollLeft) absoluteLeft = scrollLeft;
            var elementToPositionOffset = this.absoluteOffset(elementToPosition[0].offsetParent);
            return {
                left: absoluteLeft - elementToPositionOffset.left,
                top: absoluteTop - elementToPositionOffset.top
            };
        },
        scrollToElement: function(element) {
            element = jQuery(element);
            var elementTop = this.absoluteOffset(element[0]).top;
            var elementHeight = element.outerHeight({
                margin: true
            });
            var elementBottom = elementTop + elementHeight;
            var windowTop = document.body.scrollTop;
            if (0 == windowTop) if (window.pageYOffset) windowTop = window.pageYOffset; else if (document.body.parentElement) windowTop = document.body.parentElement.scrollTop; else widowTop = 0;
            var windowHeight = jQuery(window).height();
            var windowBottom = windowTop + windowHeight;
            var topDiff = elementTop - (windowTop + 50);
            if (topDiff < 0 || windowHeight - 50 < elementHeight && elementTop > windowTop + 50) {
                jQuery(window).scrollTo({
                    top: "+=" + (topDiff - 30) + "px",
                    left: "+=0px"
                });
                return;
            }
            var bottomDiff = elementBottom - windowBottom;
            if (bottomDiff > 0) jQuery(window).scrollTo({
                top: "+=" + (bottomDiff + 150) + "px",
                left: "+=0px"
            });
        },
        cursorToAndRemoveElement: function(element) {
            element = jQuery(element);
            if (!element.length) return;
            this.editor.selection.select(element[0], true);
            this.editor.selection.collapse(true);
            this.editor.focus();
            this.scrollToElement(element);
            element.remove();
            this.editor.nodeChanged();
        },
        getSiblingOfElement: function(element, nextOrPrevious) {
            if (!element) return null;
            if (!nextOrPrevious) nextOrPrevious = "next";
            var node = element[nextOrPrevious + "Sibling"];
            while (node && 3 == node.nodeType && "" == node.nodeValue) node = node[nextOrPrevious + "Sibling"];
            return node;
        },
        disableUntilLibsLoad: function(ed, buttonName) {
            ed.onInit.add(function() {
                if (!ws.editor.content.isLoaded) {
                    ed.theme.controlManager().setDisabled(buttonName, true);
                    ws.editor.content.add(function() {
                        ed.theme.controlManager().setDisabled(buttonName, false);
                    });
                }
            });
        },
        isNodeEmpty: function(node) {
            return this.isTextEmpty(jQuery(node).text());
        },
        isTextEmpty: function(text) {
            text = text.replace(/\uFEFF/g, "");
            text = jQuery.trim(text);
            return 0 == text.length;
        },
        areNodesAdjacent: function(prev, next) {
            var compare = prev;
            while (compare && compare != next) {
                if (1 == compare.nodeType) return false;
                if (!this.isTextEmpty(compare)) return false;
                compare.prev.nextSibling;
            }
            if (compare == next) return true;
            return false;
        },
        isCommentEditor: function() {
            return jQuery(this.editor.getContainer()).parent().is(".commentEditor");
        },
        getOption: function(opt) {
            return jQuery(this.editor.getElement()).closest("form").find('input[title="' + opt + '"]').val();
        },
        setOption: function(opt, value) {
            return jQuery(this.editor.getElement()).closest("form").find('input[title="' + opt + '"]').val(value);
        },
        resizeToolbar: function() {
            var normalWidth = 906;
            var medWidth = 706;
            var minWidth = 631;
            var $toolbar = jQuery("#wsMainEditor_external");
            var $buttonPreview = jQuery("#wsMainEditor_wspreview").closest("td");
            if (jQuery(window).width() < medWidth + $toolbar.offset().left) {
                jQuery(".mceButtonLabel").slice(0, 5).hide();
                $toolbar.css("min-width", minWidth);
            } else if (jQuery(window).width() < normalWidth + $toolbar.offset().left) {
                jQuery(".mceButtonLabel").slice(0, 5).hide();
                $toolbar.css("min-width", medWidth);
            } else {
                jQuery(".mceButtonLabel").show();
                $toolbar.css("min-width", normalWidth);
            }
        }
    });
    tinymce.PluginManager.add("wscommon", wikispaces.plugins.CommonPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.ConcurrentEditor", {
        editor: null,
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "concurrentEditor",
                title: "Page Activity",
                width: 300,
                height: 100,
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        uiSetup: function(popup) {
            jQuery("#concurrentEditorClose").click(function(e) {
                popup.close();
                e.preventDefault();
                return false;
            });
        }
    });
    tinymce.PluginManager.add("wsconcurrenteditorpopup", wikispaces.popups.ConcurrentEditor);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.DraftRecovered", {
        editor: null,
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "draftRecovered",
                title: "Draft Recovered",
                width: 440,
                height: 130,
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        uiSetup: function(popup) {
            var editor = this.editor;
            var plugin = editor.plugins.wsautoload;
            jQuery("#recoverDraft").click(function(e) {
                ws.common.track("Editor", "Autosave", "Load");
                plugin.loadVersion(plugin.autosaveContent, plugin.autosavePageComments, plugin.autosaveVersion, plugin.autosaveCleanup);
                popup.close();
                editor.undoManager.clear();
                editor.plugins.wsautosave.autosave(false, plugin.autosaveContent);
                e.preventDefault();
                return false;
            });
            jQuery("#discardDraft").click(function(e) {
                ws.common.track("Editor", "Autosave", "Discard");
                popup.close();
                jQuery.ajax({
                    url: ws.common.pathFor("page", "discardautosave", wikispaces_page),
                    type: "GET",
                    cache: false,
                    global: false
                });
                e.preventDefault();
                return false;
            });
        }
    });
    tinymce.PluginManager.add("wsdraftrecoveredpopup", wikispaces.popups.DraftRecovered);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.ExpiredDraft", {
        editor: null,
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "expiredDraft",
                title: "Expired Draft Recovered",
                width: 600,
                height: 350,
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        uiSetup: function(popup) {
            var editor = this.editor;
            var plugin = editor.plugins.wsautoload;
            jQuery("#expireDraft").click(function(e) {
                ws.common.track("Editor", "Autosave", "Forced Discard");
                popup.close();
                jQuery.ajax({
                    url: ws.common.pathFor("page", "discardautosave", wikispaces_page),
                    type: "GET",
                    cache: false,
                    global: false
                });
                e.preventDefault();
                return false;
            });
        }
    });
    tinymce.PluginManager.add("wsexpireddraftpopup", wikispaces.popups.ExpiredDraft);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.ImagePlugin", {
        "static": {
            newImageIdCounter: 1
        },
        init: function(ed, url) {
            var plugin = this;
            ed.addCommand("wsimage", function() {
                tinymce.mainEditor.plugins.wspopup.show("imageTool", {
                    plugin: plugin
                });
            });
            ed.addButton("wsimage", {
                title: "Insert Images and Files",
                label: "File",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsimage");
                    ws.common.track("Editor", "Open Image Tool");
                }
            });
            ed.onNodeChange.add(function(ed, cm, n, co) {
                if ("visual" != ed.plugins.wscommon.getOption("mode")) {
                    ed.theme.controlManager().setActive("wsimage", false);
                    return;
                }
                var isPlaceholder = plugin.isFilePlaceholder(n);
                ed.theme.controlManager().setActive("wsimage", isPlaceholder);
                if (isPlaceholder) tinymce.mainEditor.plugins.wsimageoverlay.show(ed, n); else tinymce.mainEditor.plugins.wsimageoverlay.hide();
            });
            ed.onSetContent.add(function(ed) {
                jQuery('img[src*="embedthumbnail/placeholder"]', ed.getBody()).addClass("missing");
            });
            ed.onClick.add(function(ed, evt) {
                if (jQuery(evt.target).is("img.missing")) {
                    ed.selection.select(evt.target);
                    tinymce.mainEditor.plugins.wspopup.show("imageTool", {
                        plugin: plugin
                    });
                }
            });
            ed.plugins["paste"].onPostProcess.add(function(pl, o) {
                jQuery("img", o.node).each(function() {
                    var img = jQuery(this);
                    if (!img.attr("src").match(/https?:\/\//)) {
                        var width = Math.max(img.attr("width"), 200);
                        var height = Math.max(img.attr("height"), 50);
                        var url = window.location.protocol + "//" + window.location.host + ws.common.pathFor("site", "embedthumbnail", "placeholder") + "?w=" + width + "&h=" + height;
                        img.attr("src", url).attr("width", width).attr("height", height).addClass("missing");
                    }
                });
            });
            if (tinymce.isGecko) ed.onInit.add(function() {
                ed.dom.bind(ed.getBody(), "drop", function(e) {
                    setTimeout(function() {
                        jQuery("img", ed.getDoc()).each(function() {
                            jQuery(this).attr("alt", jQuery(this).attr("alt").replace(/\n/g, ""));
                        });
                    }, 0);
                });
            });
            ed.plugins.wscommon.disableUntilLibsLoad(ed, "wsimage");
        },
        getInfo: function() {
            return {
                longname: "Wikispaces image",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        isFilePlaceholder: function(elem) {
            return "IMG" == elem.nodeName && !jQuery(elem).hasClass("missing") && !jQuery(elem).hasClass("WikiMedia") && !jQuery(elem).hasClass("WikiReference") && !jQuery(elem).hasClass("WikiAnchor") || jQuery(elem).hasClass("WikiMediaFile");
        },
        isLocalContext: function(context) {
            var match = null;
            if ("/" == context && wikispaces_isDefaultSpace) return true; else if (match = context.match(/^\/([^\/]+)\/([^\/]+)\//)) return match[1] == wikispaces_projectName && match[2] == wikispaces_spaceName; else return false;
        },
        insertImageInEditor: function(objectType, imageName, mediaType, url, location, context) {
            var me = this;
            if ("image" == mediaType) {
                ws.common.track("Editor", "Add Image", imageName);
                var imageSrc;
                if (url) imageSrc = url; else if ("file" == objectType) imageSrc = location + ws.common.encodePath(objectType, "view", imageName); else if ("doc" == objectType) imageSrc = location + ws.common.encodePath(objectType, "viewfile", imageName);
                var img = jQuery("<img>").attr("src", imageSrc).hide().appendTo(jQuery("body"));
                img.load(function() {
                    me.insertImageInEditorCallback(objectType, imageName, mediaType, url, location, context, img);
                });
                img.attr("src", img.attr("src"));
            } else {
                ws.common.track("Editor", "Add File", imageName);
                this.insertImageInEditorCallback(objectType, imageName, mediaType, url, location, context);
            }
        },
        insertImageInEditorCallback: function(objectType, imageName, mediaType, url, location, context, img) {
            var editor = tinymce.activeEditor;
            var me = this;
            var html = "";
            var nextId = "newImage-" + wikispaces.plugins.ImagePlugin.newImageIdCounter++;
            var realNextId = nextId;
            var overlay;
            var src;
            var keyContext = context && this.isLocalContext(context) ? "" : context;
            var viewAction;
            var mediaClass;
            var embedClass;
            var titlePrefix;
            if ("file" == objectType) {
                viewAction = "view";
                mediaClass = "WikiMediaFile";
                embedClass = "WikiFile";
                titlePrefix = "File";
            } else if ("doc" == objectType) {
                viewAction = "viewfile";
                mediaClass = "WikiMediaDoc";
                embedClass = "GoogleDoc";
                titlePrefix = "Google Doc";
            } else if ("external" != objectType) return;
            if ("image" == mediaType) {
                var sizeString = "";
                if (img.width() > 800) {
                    var newHeight = Math.floor(800 / img.width() * img.height());
                    sizeString = ' width="800" height="' + newHeight + '"';
                }
                if (url) src = url; else src = this.isLocalContext(context) ? ws.common.pathFor(objectType, viewAction, imageName) : img.attr("src");
                html = '<img id="' + nextId + '" src="' + src + '"' + sizeString + "/>";
                overlay = tinymce.mainEditor.plugins.wsimageoverlay;
            } else if ("audio" == mediaType) {
                realNextId = 'wikitext@@media@@type="' + objectType + '" key="' + keyContext + imageName + '"';
                src = window.location.protocol + "//www." + wikispaces_domain + "/site/embedthumbnail/" + objectType + "-audio/" + encodeURIComponent(imageName) + "?h=20&w=240";
                html = '<img src="' + src + '" class="WikiMedia ' + mediaClass + '" id="' + nextId + '" title="Audio Player: ' + ws.common.escapeHtml(imageName) + '" />';
                overlay = tinymce.mainEditor.plugins.wswidgetoverlay;
            } else if ("video" == mediaType) {
                realNextId = 'wikitext@@media@@type="' + objectType + '" key="' + keyContext + imageName + '"';
                src = window.location.protocol + "//www." + wikispaces_domain + "/site/embedthumbnail/" + objectType + "-video/" + encodeURIComponent(imageName) + "?h=300&w=300";
                html = '<img src="' + src + '" class="WikiMedia ' + mediaClass + '" id="' + nextId + '" title="Video Player: ' + ws.common.escapeHtml(imageName) + '" />';
                overlay = tinymce.mainEditor.plugins.wswidgetoverlay;
            } else {
                realNextId = "wikitext@@" + objectType + "@@" + keyContext + imageName;
                src = window.location.protocol + "//www." + wikispaces_domain + "/site/embedthumbnail/" + objectType + "/" + encodeURIComponent(imageName) + "?h=40&w=200";
                html = '<img src="' + src + '" class="' + embedClass + '" id="' + nextId + '" title="' + titlePrefix + ": " + ws.common.escapeHtml(imageName) + '" />';
                overlay = tinymce.mainEditor.plugins.wsimageoverlay;
            }
            editor.wsselection.setContent(html);
            var imageElement = jQuery("#" + nextId, editor.getBody()).attr("id", realNextId).attr("src", src).get(0);
            editor.wsselection.updateBookmarkToNode(imageElement);
            editor.wsselection.restore();
            editor.plugins.wscommon.scrollToElement(imageElement);
            overlay.show(editor, imageElement);
        }
    });
    tinymce.PluginManager.add("wsimage", wikispaces.plugins.ImagePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.ImageOverlay", {
        init: function(ed, url) {
            var plugin = this;
            ed.onInit.add(function(editor) {
                var initFunc = function(editor) {
                    editor.onClick.add(function(editor, e) {
                        if (editor.plugins.wsimage.isFilePlaceholder(e.target)) plugin.show(editor, e.target); else plugin.hide();
                    });
                };
                editor.onInitSubEditor.add(initFunc);
                initFunc(editor);
            });
            this.overlayInit(ed, url);
        },
        overlayInit: function(ed, url) {
            var plugin = this;
            ed.onModeSwitch.add(function(mode) {
                if ("plain" == mode) plugin.hide();
            });
            ed.onKeyDown.add(function(ed, e) {
                if (plugin.img && (8 == e.keyCode || 46 == e.keyCode)) {
                    plugin.removeImage();
                    return false;
                }
            });
            jQuery(window).resize(function() {
                if (plugin.img && jQuery(plugin.img).is(":visible")) plugin.repositionAndShow();
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces image overlay",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        overlayContent: function() {
            return ws.editor.content.loadContent("imageProperties");
        },
        show: function(editor, img) {
            var me = this;
            this.editor = editor;
            if (this.img == img) return;
            this.img = img;
            if (null == this.overlay) {
                this.overlay = jQuery("<div>").addClass("WikiOverlay overlayLayer").css({
                    position: "absolute"
                }).html(this.overlayContent()).hide().appendTo("#pageEditor");
                this.setup();
            }
            tinymce.mainEditor.plugins.wstableoverlay.unselectTableCell();
            this.refreshLinkStatus(true);
            this.refreshAlignment();
            this.setCaption(jQuery(this.img).attr("alt"), true);
            if (jQuery(this.img).hasClass("WikiMediaFile")) {
                jQuery("#imageAttributes").hide();
                jQuery("#imageAppearance").show();
                jQuery("#fileRemove").show();
                jQuery("#docRemove").hide();
            } else if (jQuery(this.img).hasClass("WikiFile")) {
                jQuery("#imageAttributes").hide();
                jQuery("#imageAppearance").hide();
                jQuery("#fileRemove").show();
                jQuery("#docRemove").hide();
            } else if (jQuery(this.img).hasClass("GoogleDoc")) {
                jQuery("#imageAttributes").hide();
                jQuery("#imageAppearance").hide();
                jQuery("#fileRemove").hide();
                jQuery("#docRemove").show();
            } else {
                jQuery("#imageAttributes").show();
                jQuery("#imageAppearance").show();
                jQuery("#fileRemove").show();
                jQuery("#docRemove").hide();
            }
            if (jQuery(this.img).height() > 0) this.toggleFitImage(); else jQuery(this.img).load(function() {
                me.toggleFitImage(img);
            });
            this.repositionAndShow();
        },
        hide: function() {
            if (jQuery(this.img).closest("td,th").length) tinymce.mainEditor.plugins.wstableoverlay.selectTableCell(jQuery(this.img).closest("td,th").get(0));
            this.img = null;
            if (this.overlay) this.overlay.hide();
        },
        repositionAndShow: function() {
            this.overlay.css({
                left: "-10000px",
                top: "-10000px"
            }).show();
            var location = this.editor.plugins.wscommon.positionBelow(this.overlay, this.img);
            this.overlay.css(location);
        },
        refreshLinkStatus: function(skipReposition) {
            if (null == this.img) return;
            if (this.findParentLinkElement(this.img)) this.setImageLink(this.findParentLinkElement(this.img).href, skipReposition); else this.unsetImageLink(skipReposition);
        },
        currentAlignment: function() {
            if (null == this.img) return null;
            var div = jQuery(this.img).parent("div");
            if (div.length && "center" == div.css("text-align")) return "center"; else return jQuery(this.img).attr("align");
        },
        refreshAlignment: function() {
            jQuery("#imageAlign a").removeClass("buttonSelected");
            switch (this.currentAlignment()) {
              case "left":
                jQuery("#imageAlignLeft").addClass("buttonSelected");
                break;

              case "center":
                jQuery("#imageAlignCenter").addClass("buttonSelected");
                break;

              case "right":
                jQuery("#imageAlignRight").addClass("buttonSelected");
            }
        },
        setCaption: function(caption, skipReposition) {
            jQuery("#captionText").html(ws.common.truncify(caption, 80));
            jQuery("#imageCaptionInput").val(caption);
            jQuery(this.img).attr("alt", caption);
            jQuery("#captionEditor").hide();
            jQuery("#existingCaption").show();
            if (caption) {
                jQuery("#addImageCaption").hide();
                jQuery("#imageCaptionControls").show();
            } else {
                jQuery("#addImageCaption").show();
                jQuery("#imageCaptionControls").hide();
            }
            if (!skipReposition) this.repositionAndShow();
        },
        editCaption: function() {
            jQuery("#imageCaptionControls").show();
            jQuery("#existingCaption").hide();
            jQuery("#captionEditor").show();
            jQuery("#imageCaptionInput").focus();
        },
        setup: function() {
            var me = this;
            jQuery("#imageAlignLeft").click(function() {
                me.setImageAlignment("left");
                return false;
            });
            jQuery("#imageAlignCenter").click(function() {
                me.setImageAlignment("center");
                return false;
            });
            jQuery("#imageAlignRight").click(function() {
                me.setImageAlignment("right");
                return false;
            });
            jQuery("#imageAlignNone").click(function() {
                me.setImageAlignment("");
                return false;
            });
            jQuery("#imageSizeDown").click(function() {
                me.adjustImageSize(-.1);
                return false;
            });
            jQuery("#imageSizeUp").click(function() {
                me.adjustImageSize(.1);
                return false;
            });
            jQuery("#imageSizeOriginal").click(function() {
                me.adjustImageSize(0, true);
                return false;
            });
            jQuery("#imageSizeFit").click(function() {
                me.adjustImageSize(0, false, true);
                return false;
            });
            jQuery("#addImageCaption, #editCaption").click(function() {
                me.editCaption();
                return false;
            });
            jQuery("#saveImageCaption").click(function() {
                me.setCaption(jQuery("#imageCaptionInput").val());
                return false;
            });
            jQuery("#cancelCaption").click(function() {
                me.setCaption(jQuery(me.img).attr("alt"));
                return false;
            });
            jQuery("#removeCaption").click(function() {
                me.setCaption(null);
                return false;
            });
            jQuery("#addImageLink, #editImageLink").click(function() {
                me.editor.selection.select(me.img);
                me.editor.execCommand("wslink");
                return false;
            });
            jQuery("#removeImageLink").click(function() {
                jQuery(me.img).parent("a").replaceWith(jQuery(me.img).parent("a").contents());
                me.unsetImageLink();
                me.editor.wsselection.updateBookmarkToNode(me.img);
                return false;
            });
            jQuery("#visitImageLink").click(function() {
                window.open(jQuery(me.img).parent("a").attr("href"));
                return false;
            });
            jQuery(".imageRemoveLink").click(function() {
                me.removeImage();
                return false;
            });
        },
        removeImage: function() {
            this.editor.undoManager.begin();
            var toRemove = jQuery(this.img);
            if (this.findCenteringElement(this.img)) toRemove = jQuery(this.findCenteringElement(this.img)); else if (this.findParentLinkElement(this.img)) toRemove = jQuery(this.findParentLinkElement(this.img));
            var toSelect = jQuery("<span>", this.editor.getDoc()).insertBefore(toRemove);
            toRemove.remove();
            this.editor.plugins.wscommon.cursorToAndRemoveElement(toSelect);
            this.editor.undoManager.end();
            this.hide();
        },
        toggleFitImage: function() {
            if (jQuery(this.img).width() > 800) jQuery("#imageSizeFit").show(); else jQuery("#imageSizeFit").hide();
        },
        setImageLink: function(href, skipReposition) {
            jQuery("#imageLinkText").html(ws.common.truncify(href, 60)).attr("title", href);
            jQuery("#imageLinkControls").show();
            jQuery("#addImageLink").hide();
            if (!skipReposition) this.repositionAndShow();
        },
        unsetImageLink: function(skipReposition) {
            jQuery("#imageLinkControls").hide();
            jQuery("#addImageLink").show();
            if (!skipReposition) this.repositionAndShow();
        },
        updateImageCaption: function(text, skipReposition) {
            jQuery(this.img).attr("alt", text);
            if (!skipReposition) this.repositionAndShow();
        },
        setImageAlignment: function(align, skipReposition) {
            if ("center" == align) if (this.findCenteringElement(this.img)) return; else {
                this.img.align = "";
                var newDiv = jQuery("<div>", this.img.ownerDocument).css("text-align", "center");
                var imageNode = jQuery(this.img);
                if (imageNode.parent().is("a")) imageNode = imageNode.parent();
                imageNode.replaceWith(newDiv).appendTo(newDiv);
            } else {
                var centering = this.findCenteringElement(this.img);
                if (centering) jQuery(centering).replaceWith(centering.childNodes);
                this.img.align = align;
            }
            this.refreshAlignment();
            if (!skipReposition) this.repositionAndShow();
        },
        findCenteringElement: function(element) {
            while (element) {
                if (element.tagName && ("CENTER" == element.tagName.toUpperCase() || "DIV" == element.tagName.toUpperCase() && ("center" == element.style.textAlign || "center" == element.align))) return element;
                if (element.parentNode) element = element.parentNode; else return null;
            }
            return null;
        },
        findParentLinkElement: function(element) {
            return jQuery(element).parent("a[href]").get(0);
        },
        adjustImageSize: function(size, original, fit) {
            var me = this;
            var img = jQuery(this.img);
            if (this.starting_width && this.starting_height) this.adjustImageSizeCallback(size, original, fit); else if (img.width() > 0 && img.height() > 0) {
                this.starting_width = img.width();
                this.starting_height = img.height();
                this.adjustImageSizeCallback(size, original, fit);
            } else img.load(function() {
                this.starting_width = img.width();
                this.starting_height = img.height();
                me.adjustImageSizeCallback(size, original, fit);
            });
        },
        adjustImageSizeCallback: function(size, original, fit) {
            var img = jQuery(this.img);
            if (original) {
                img.removeAttr("height").removeAttr("width").css({
                    height: "auto",
                    width: "auto"
                });
                this.repositionAndShow();
                return;
            }
            var newHeight;
            var newWidth;
            if (fit) if (this.starting_width > 800) {
                newWidth = 800;
                newHeight = Math.round(800 / this.starting_width * this.starting_height);
            } else {
                newWidth = this.starting_width;
                newHeight = this.starting_height;
            } else if (0 != size) {
                var currentHeightRatio = img.height() / this.starting_height;
                var currentWidthRatio = img.width() / this.starting_width;
                newHeight = Math.floor(this.starting_height * (currentHeightRatio + size));
                newWidth = Math.floor(this.starting_width * (currentWidthRatio + size));
            }
            if (newHeight > 0 && newWidth > 0 && newHeight >= Math.floor(.05 * this.starting_height) && newWidth >= Math.floor(.05 * this.starting_width)) {
                img.height(newHeight);
                img.width(newWidth);
            }
            this.repositionAndShow();
            this.toggleFitImage();
            if (this.editor.plugins.autoresize) this.editor.plugins.autoresize.fitEditor();
            if (this.editor.onNeedsResize) this.editor.onNeedsResize.dispatch();
        }
    });
    tinymce.PluginManager.add("wsimageoverlay", wikispaces.plugins.ImageOverlay);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.Image", {
        MAX_PER_ROW: 8,
        MAX_ROWS: 8,
        PER_PAGE: 6,
        IMAGE_SIZE: 32,
        externalPosition: 0,
        currentMode: "files",
        currentTags: [],
        newUploads: [],
        plugin: null,
        editor: null,
        fileSource: "",
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "imageTool",
                title: "Images and Files",
                width: 670,
                height: 387,
                wsselection: 0,
                onShow: function(o) {
                    me.onShow(o);
                },
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        onShow: function(o) {
            this.showPage(1);
            this.setPlugin(o.plugin);
            if (this.uploader) this.uploader.refresh();
        },
        setPlugin: function(plugin) {
            this.plugin = plugin;
        },
        addPage: function(number) {
            var me = this;
            var a = document.createElement("a");
            a.href = "#";
            jQuery(a).click(function() {
                ws.common.track("Editor", "Show File Page", number);
                me.showPage(number);
                return false;
            });
            jQuery(a).html(number);
            jQuery(a).addClass("pageNumber");
            jQuery("#imagePages").append(a).append("&nbsp;");
        },
        showPage: function(page) {
            var me = this;
            this.showFileSpinner();
            var offset = (page - 1) * this.PER_PAGE;
            var pageLimit = this.PER_PAGE;
            var filename = "";
            if (jQuery("#filenameAutocomplete").val() != jQuery("#filenameAutocomplete").attr("title")) filename = jQuery("#filenameAutocomplete").val();
            var url = ws.common.pathFor("file", "listjson", this.currentMode);
            if (this.fileSource) if (match = this.fileSource.match(/(.*)\*$/)) url = match[1] + "file/listjson/" + this.currentMode + "?allTeams=1"; else url = this.fileSource + "file/listjson/" + this.currentMode;
            ws.common.ajaxPost({
                queueName: "imageList",
                url: url,
                data: {
                    offset: offset,
                    pageLimit: pageLimit,
                    filename: filename,
                    tag: this.currentTags.join(),
                    sources: jQuery("#fileSourcesList").length ? "" : "t"
                }
            }).done(function(data) {
                if (!data || !data.content) return;
                me.loadFileData(data.content);
                me.editor.plugins.wspopup.resize("imageTool");
                if (data.content.sources) me.buildSourcesList(data.content.sources, data.content.currentSource);
            });
        },
        buildSourcesList: function(sources, currentSource) {
            $fileSources = jQuery("<select/>", {
                id: "fileSourcesList"
            });
            _.each(sources, function(name, url) {
                $option = jQuery("<option/>", {
                    value: url
                }).text(name).appendTo($fileSources);
                if (url == currentSource) $option.prop("selected", true);
            });
            jQuery(".filterSourcesDrop").append($fileSources);
            jQuery(".filterSources").show();
            var me = this;
            $fileSources.change(function(e) {
                me.fileSource = jQuery(this).val();
                me.resetPages();
                me.showPage(1);
            });
        },
        showFileSpinner: function() {
            jQuery("#filenameAutocomplete").css("background", "white url('/i/spinner.gif') no-repeat center right");
        },
        hideFileSpinner: function() {
            jQuery("#filenameAutocomplete").css("background-image", "none");
        },
        setListMode: function(mode) {
            jQuery("#fileListMode").val(mode);
            this.currentMode = mode;
            this.showPage(1);
        },
        getCell: function(tableId, position) {
            return jQuery("#" + tableId + " tr").eq(Math.floor(position / this.MAX_PER_ROW)).find("td").get(position % this.MAX_PER_ROW);
        },
        addRow: function(tableId) {
            var row = document.createElement("tr");
            for (j = 0; j < this.MAX_PER_ROW; j++) row.appendChild(document.createElement("td"));
            jQuery("#" + tableId).append(row);
        },
        addFileRow: function(tableId, objectType, fileName, mimeType, viewGroup, location, context, url, isUploadInProgress) {
            var me = this;
            var mediaType = null;
            if ("image" == mimeType || this.isImage(mimeType) || "application/vnd.google-apps.drawing" == mimeType) mediaType = "image"; else if (this.isAudio(mimeType)) mediaType = "audio"; else if (this.isVideo(mimeType)) mediaType = "video";
            li1 = jQuery("<li>").attr("title", fileName).addClass("active");
            if (!isUploadInProgress) li1.click(function() {
                me.plugin.insertImageInEditor(objectType, fileName, mediaType, null, location, context);
                me.editor.plugins.wspopup.hide("imageTool");
            });
            var img = document.createElement("img");
            if (isUploadInProgress) {
                img.src = "/i/c.gif";
                img.width = me.IMAGE_SIZE;
                img.height = me.IMAGE_SIZE;
            } else if ("image" == mediaType && url) {
                img.src = url;
                if (img.height > img.width) {
                    img.width = img.width / img.height * me.IMAGE_SIZE;
                    img.height = me.IMAGE_SIZE;
                } else {
                    img.height = img.height / img.width * me.IMAGE_SIZE;
                    img.width = me.IMAGE_SIZE;
                }
            } else {
                var base = (location ? location : "") + ws.common.encodePath(objectType, "thumbnail", fileName);
                img.src = base + "?size=" + me.IMAGE_SIZE + (isUploadInProgress ? "&rnd=" + Math.random() : "");
                img.width = me.IMAGE_SIZE;
                img.height = me.IMAGE_SIZE;
            }
            jQuery(li1).append(img).append(jQuery('<div class="fileName">').text(ws.common.truncify(fileName, 40)));
            var pageViewGroup = tinymce.mainEditor.getParam("wsimage_page_view_group");
            if (1 == ws.common.compareGroupPermissionValues(viewGroup, pageViewGroup)) {
                var msg = "This file has more restrictive permissions than this page. Some users may not be able to see it.";
                jQuery('<img src="/i/icon_16_hidden.png"/>').css({
                    "float": "right",
                    "padding-top": 6
                }).attr("title", msg).attr("alt", msg).appendTo(li1);
            }
            jQuery(".fileList ul").append(li1);
            return li1;
        },
        addFileCell: function(tableId, fileName, mimeType, position, url, img) {
            var me = this;
            var fileId = tableId + "-file-" + position;
            var cell = this.getCell(tableId, position);
            if (!cell) {
                this.addRow(tableId);
                cell = this.getCell(tableId, position);
            }
            var td1 = document.createElement("td");
            td1.style.textAlign = "center";
            td1.style.padding = "5px;";
            td1.title = fileName;
            jQuery(td1).click(function() {
                me.plugin.insertImageInEditor("external", fileName, "image", url);
                me.editor.plugins.wspopup.hide("imageTool");
            });
            if (!img) img = document.createElement("img");
            if (url) {
                img.src = url;
                if (img.height > img.width) {
                    img.width = img.width / img.height * me.IMAGE_SIZE;
                    img.height = me.IMAGE_SIZE;
                } else {
                    img.height = img.height / img.width * me.IMAGE_SIZE;
                    img.width = me.IMAGE_SIZE;
                }
            }
            jQuery(img).appendTo(td1);
            cell.parentNode.replaceChild(td1, cell);
        },
        resetPages: function() {
            var me = this;
            var MAX_PAGE_NUMBERS = 7;
            var SURROUND_PAGES = 1;
            jQuery("#imagePages").html('<a href="#" class="pageNumber pageCurrent" style="visibility: hidden;">&nbsp;</a>');
            var startPage = 1;
            var endPage = this.pageCount;
            if (this.pageCount > MAX_PAGE_NUMBERS) {
                startPage = this.currentPage - SURROUND_PAGES;
                if (startPage < 1) startPage = 1;
                endPage = startPage + SURROUND_PAGES;
                if (endPage > this.pageCount) endPage = this.pageCount;
            }
            var pagesShown = 1 + endPage - startPage + (endPage == this.pageCount ? 0 : 1) + (1 == startPage ? 0 : 1);
            var i = 0;
            while (pagesShown < MAX_PAGE_NUMBERS && (1 != startPage || endPage != this.pageCount)) {
                if (i % 2) {
                    startPage--;
                    if (startPage < 1) startPage = 1;
                } else {
                    endPage++;
                    if (endPage > this.pageCount) endPage = this.pageCount;
                }
                i++;
                pagesShown = 1 + endPage - startPage + (endPage == this.pageCount ? 0 : 1) + (1 == startPage ? 0 : 1);
            }
            if (this.pageCount > 1) {
                if (1 == this.currentPage) jQuery("#imagePages").append('<span class="pageFirst inactive">&laquo; Previous</span>'); else {
                    var prevLink = jQuery('<a href="#" class="pageFirst">&laquo; Previous</a>').click(function() {
                        me.showPage(me.currentPage - 1);
                    });
                    jQuery("#imagePages").append(prevLink);
                }
                if (startPage > 1) {
                    this.addPage(1);
                    if (startPage > 2) jQuery("#imagePages").append(" ... ");
                }
                for (i = startPage; i <= endPage; i++) this.addPage(i);
                if (this.pageCount > endPage) {
                    if (endPage + 1 < this.pageCount) jQuery("#imagePages").append(" ... ");
                    this.addPage(this.pageCount);
                }
                if (this.currentPage == this.pageCount) jQuery("#imagePages").append('<span class="inactive">Next &raquo;</span>'); else {
                    var nextLink = jQuery('<a href="#">Next &raquo;</a>').click(function() {
                        me.showPage(me.currentPage + 1);
                    });
                    jQuery("#imagePages").append(nextLink);
                }
            }
        },
        loadFileData: function(data) {
            var me = this;
            jQuery(".fileList ul").empty();
            var number = 0;
            if ("myrecent" == this.currentMode) {
                var skip = (me.currentPage - 1) * me.PER_PAGE;
                jQuery.each(this.newUploads, function(i, item) {
                    if (i < skip) return;
                    if (number >= me.PER_PAGE) return false;
                    var newUpload = me.addFileRow("imageTable", item.f_type, item.f_name, item.r_mime_type, item.f_view_group, item.f_location, item.f_context, null, true);
                    var $indicator = jQuery(newUpload).attr("id", "swfu_file_" + item.id).find("div.fileName").append("&nbsp;&nbsp;").append(jQuery("<a>").attr("href", "#").addClass("uploadCancelButton").attr("id", item.id + "cancel").text("cancel").click(function(e) {
                        newUpload.remove();
                        me.uploader.removeFile(me.uploader.getFile(item.id));
                        e.preventDefault();
                    })).append('<div class="progressContainer"><div class="progressBar" id="' + item.id + 'progress"></div></div>');
                    number++;
                });
            }
            jQuery.each(data.files, function(i, item) {
                if (number >= me.PER_PAGE) return false;
                me.addFileRow("imageTable", item.f_type, item.f_name, item.r_mime_type, item.f_view_group, item.f_location, item.f_context);
                number++;
            });
            if (!number) {
                var li1 = jQuery("<li>").text("No files found").addClass("nodata");
                jQuery(".fileList ul").append(li1);
                number++;
            }
            while (number < this.PER_PAGE) {
                var li2 = document.createElement("li");
                var img = document.createElement("img");
                img.src = "/i/c.gif";
                img.height = me.IMAGE_SIZE;
                img.width = me.IMAGE_SIZE;
                li2.appendChild(img);
                li2.appendChild(document.createTextNode(" "));
                jQuery(".fileList ul").append(li2);
                number++;
            }
            this.pageCount = data.pagedata.numpages;
            this.currentPage = data.pagedata.current;
            this.resetPages();
            this.highlightPage(this.currentPage);
            this.hideFileSpinner();
        },
        highlightPage: function(page) {
            var pages = jQuery("#imagePages a.pageNumber").each(function() {
                if (jQuery(this).html() == page) jQuery(this).addClass("pageCurrent"); else jQuery(this).removeClass("pageCurrent");
            });
        },
        externalImageOnloadCallback: function(image) {},
        showExternalImage: function() {
            var me = this;
            var url = document.getElementById("externalImageUrl").value;
            if (!url) {
                alert("Please enter the address of an external image.");
                return;
            }
            var $image = jQuery("<img/>");
            $image.one("load", function() {
                if (0 === $image[0].height) {
                    alert("The external image could not be found.");
                    return;
                }
                var fileName = url.match(/.*\/([^\/\?]+)/)[1];
                me.addFileCell("externalTable", fileName, "image", me.externalPosition++, url, $image[0]);
            });
            $image.one("error", function() {
                alert("The external image could not be found.");
            });
            $image.attr("src", url);
        },
        uiSetup: function(popup) {
            var me = this;
            jQuery("#imageCloseButton").click(function() {
                popup.close();
                return false;
            });
            for (i = 0; i < this.MAX_ROWS; i++) this.addRow("externalTable");
            ws.session.reloadSession();
            if (ws.context.instance.isMain && "www" == ws.context.wiki.name) {
                me.setListMode("myrecent");
                jQuery("#imageDiv .filterTagShow").hide();
                jQuery("#fileListMode option").remove();
            }
            jQuery("#fileListMode").change(function() {
                me.setListMode(jQuery(this).val());
            });
            if (!wikispaces_isUserLoggedIn || !wikispaces_isUploadCapable) jQuery("#uploadButtons button").prop("disabled", true);
            jQuery("#externalTabCell button").click(function() {
                me.showExternalImage();
                return false;
            });
            jQuery("#imageDiv .modeSelector li.tab").click(function(evt) {
                jQuery("#imageDiv .modeSelector li.tab").removeClass("selected");
                jQuery(this).addClass("selected");
                jQuery("#imageDiv .fileMode").hide();
                jQuery("#imageDiv").find("#" + jQuery(this).attr("id") + "Cell").show();
            });
            jQuery("#filenameAutocomplete").keyup(function() {
                me.showPage(1);
            });
            if (wikispaces_username) jQuery("#fileListMode").append('<option value="myrecent">My Recent Uploads</option>');
            ws.select2.tagFilter(jQuery("#imageDiv .tagFilter"), {
                ajax: {
                    url: function() {
                        if (!me.fileSource) return ws.common.pathFor("tag", "listjson", me.currentMode);
                        var prefix = me.fileSource;
                        var match = prefix.match(/(.*)\*$/);
                        if (match) prefix = match[1];
                        return prefix + "tag/listjson/" + me.currentMode;
                    },
                    data: function(term, page) {
                        return jQuery.extend(ws.select2.tagFilterDefaults.ajax.data.call(this, term, page), {
                            allTeams: !!(me.fileSource && me.fileSource.match(/\*$/)) + 0,
                            oq: jQuery("#filenameAutocomplete").val()
                        });
                    }
                }
            }).change(function(e) {
                me.currentTags = e.val;
                me.showPage(1);
            });
            if (-1 != navigator.platform.indexOf("Mac")) jQuery("#ctrlKeyName").html("&#8984;");
            if (wikispaces_isUserLoggedIn) this.setupUploader();
        },
        setupUploader: function() {
            var me = this;
            var editor = tinymce.mainEditor;
            this.uploader = new plupload.Uploader({
                runtimes: _(ws.common.pluploadRuntimes()).without("silverlight").join(","),
                browse_button: "uploadFiles",
                url: editor.getParam("wsimage_upload_url"),
                flash_swf_url: "/s/plupload.flash.swf",
                silverlight_xap_url: "/s/plupload.silverlight.xap",
                multipart_params: Cookie.all(),
                max_file_size: editor.getParam("wsimage_max_file_size_mb") + "MB",
                drop_element: "imageDivTable",
                container: "uploadButtons"
            });
            this.uploader.init();
            this.uploader.bind("FilesAdded", function(up, files) {
                _(files).each(function(file) {
                    var type = "application/octet-stream";
                    if (me.isImageFilename(file.name)) type = "image";
                    me.newUploads.push({
                        f_name: file.name,
                        r_mime_type: type,
                        id: file.id
                    });
                });
                me.setListMode("myrecent");
                jQuery("#imageDivTable .filterTagShow:visible").effect("highlight", {}, 3e3);
                jQuery("#filenameAutocomplete").val("");
                jQuery("#uploadFiles").hide();
                jQuery("#cancelQueueBtn").show();
                up.refresh();
                up.start();
            });
            this.uploader.bind("UploadProgress", function(up, file) {
                jQuery("#swfu_file_" + file.id).find(".progressBar").css("width", file.percent + "%");
            });
            this.uploader.bind("FileUploaded", function(up, file, response) {
                jQuery("#swfu_file_" + file.id).attr("id", "").find(".progressContainer").remove();
                jQuery("#" + file.id + "cancel").remove();
            });
            var flushQueueAndReset = function() {
                me.newUploads = [];
                jQuery("#cancelQueueBtn").hide();
                jQuery("#uploadFiles").show();
                var url = ws.common.pathFor("file", "upload");
                url = ws.common.addUriParams(url, [ [ "multiModeConfirm", 1 ], [ "remoteMode", "true" ] ]);
                ws.common.ajaxPost({
                    url: url
                }).done(function(data) {
                    me.setListMode("myrecent");
                    jQuery("#filenameAutocomplete").val("");
                });
            };
            this.uploader.bind("UploadComplete", flushQueueAndReset);
            jQuery("#cancelQueueBtn").click(function() {
                me.uploader.stop();
                flushQueueAndReset();
            });
            this.uploader.bind("Error", function(up, err) {
                ws.common.logFileUploadError(err, editor.getParam("wsimage_max_file_size_mb") + "MB");
                if (err.file && jQuery("#" + err.file.id).length) jQuery("#" + err.file.id).removeClass("fileUploading").addClass("uploadError");
                up.refresh();
            });
        },
        isImage: function(mimeType) {
            switch (mimeType) {
              case "image/png":
              case "image/x-png":
              case "image/jpeg":
              case "image/gif":
              case "image/jpg":
              case "image/pjpeg":
                return true;
            }
            return false;
        },
        isImageFilename: function(filename) {
            return filename.match(/.*\.(?:gif|jpg|jpeg|png)$/i);
        },
        isMedia: function(mimeType) {
            return this.isAudio(mimeType) || this.isVideo(mimeType);
        },
        isAudio: function(mimeType) {
            switch (mimeType) {
              case "audio/mpeg":
              case "audio/mpg":
              case "audio/mp3":
              case "audio/x-mp3":
              case "audio/x-mpeg":
              case "audio/x-mpg":
              case "application/asx":
              case "application/x-mplayer2":
              case "audio/x-ms-wma":
              case "audio/x-ms-wax":
              case "audio/3gpp":
              case "audio/3gpp2":
              case "audio/aac":
              case "audio/x-aac":
              case "audio/aiff":
              case "audio/x-aiff":
              case "audio/mid":
              case "audio/midi":
              case "audio/x-midi":
              case "audio/mp4":
              case "audio/m4a":
              case "audio/x-m4a":
              case "audio/wav":
              case "audio/x-wav":
              case "audio/x-pn-realaudio":
              case "audio/x-pn-realaudio-plugin":
                return true;
            }
            return false;
        },
        isVideo: function(mimeType) {
            switch (mimeType) {
              case "video/x-ms-asf-plugin":
              case "video/x-ms-asf":
              case "video/x-ms-wm":
              case "video/x-ms-wmv":
              case "video/x-ms-wvx":
              case "video/avi":
              case "video/3gpp":
              case "video/3gpp2":
              case "video/m4v":
              case "video/x-m4v":
              case "video/mp4":
              case "video/mpeg":
              case "video/x-mpeg":
              case "video/quicktime":
              case "video/sd-video":
              case "video/flv":
              case "video/x-flv":
              case "video/x-msvideo":
              case "application/x-shockwave-flash":
              case "application/futuresplash":
                return true;
            }
            return false;
        }
    });
    tinymce.PluginManager.add("wsimagepopup", wikispaces.popups.Image);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.LinkPlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.addCommand("wslink", function() {
                tinymce.mainEditor.plugins.wspopup.show("linkTool", {
                    plugin: plugin
                });
            });
            ed.addButton("wslink", {
                title: "Insert Link",
                label: "Link",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wslink");
                    ws.common.track("Editor", "Open Link Tool");
                }
            });
            ed.onNodeChange.add(function(ed, cm, n, co, o) {
                ed.theme.controlManager().setActive("wslink", "A" == n.nodeName && !n.name || "IMG" == n.nodeName && "A" == n.parentNode.nodeName);
                if (o.initial) return;
                if ("A" == n.nodeName && !n.name && n.href.indexOf("#mce_temp_url#") == -1 && "visual" == ed.plugins.wscommon.getOption("mode")) tinymce.mainEditor.plugins.wslinkoverlay.show(n); else tinymce.mainEditor.plugins.wslinkoverlay.hide();
            });
            ed.onDblClick.add(function(ed, e) {
                if ("A" == e.target.nodeName) {
                    if ("A" == e.target.nodeName) ed.selection.select(e.target);
                    ed.execCommand("wslink");
                }
            });
            ed.plugins.wscommon.disableUntilLibsLoad(ed, "wslink");
        },
        getInfo: function() {
            return {
                longname: "Wikispaces link",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        setupForms: function() {
            var me = this;
            var editor = tinymce.activeEditor;
            editor.wsselection.restore(true);
            if (this.linkEnclosingSelectedImage()) editor.plugins.wslinkpopup.prefill(this.parseLink(jQuery(this.linkEnclosingSelectedImage()))); else if (this.selectedLink()) editor.plugins.wslinkpopup.prefill(this.parseLink(jQuery(this.selectedLink()))); else if (this.selectedImage() || this.isBlockElementSelected()) editor.plugins.wslinkpopup.prefill({
                linkText: null
            }); else editor.plugins.wslinkpopup.prefill({
                linkText: this.selectedText()
            });
        },
        insertLinkFromComponents: function(components) {
            var me = this;
            var editor = this.editor;
            var $link = this.componentsToLink(components);
            var linkTextChanged = this.selectedText() != components.linkText;
            var img;
            if (this.linkEnclosingSelectedImage()) {
                this.linkEnclosingSelectedImage().setAttribute("href", $link.attr("href"));
                if (components.targetNew) this.linkEnclosingSelectedImage().setAttribute("target", "_blank"); else this.linkEnclosingSelectedImage().removeAttribute("target");
            } else if (img = this.selectedImage()) {
                img.parentNode.appendChild($link.get(0));
                this.selectedImage().parentNode.replaceChild($link.get(0), img);
                $link.get(0).appendChild(img);
                tinymce.mainEditor.plugins.wsimageoverlay.refreshLinkStatus();
                editor.wsselection.updateBookmarkToNode(img);
            } else if (this.selectedLink()) {
                editor.dom.replace($link.get(0), this.selectedLink());
                editor.wsselection.updateBookmarkToNode($link.get(0));
            } else if (this.selectedText() && !linkTextChanged) {
                editor.wsselection.restore();
                editor.getDoc().execCommand("unlink", false, null);
                if (jQuery.browser.msie) {
                    var rng = editor.selection.getRng(true).cloneRange();
                    if ("A" == rng.endContainer.parentNode.nodeName && 0 == rng.endOffset) {
                        span = jQuery('<span class="ie-is-the-best">&nbsp</span>').insertBefore(rng.endContainer.parentNode);
                        rng.setEndBefore(span.get(0));
                        editor.selection.setRng(rng);
                    }
                }
                editor.execCommand("CreateLink", false, "#mce_temp_url#");
                if (jQuery.browser.msie) jQuery(".ie-is-the-best", editor.getDoc()).remove();
                var elementArray = editor.dom.select("a[href='#mce_temp_url#']");
                for (i = 0; i < elementArray.length; i++) {
                    editor.dom.setAttrib(elementArray[i], "href", $link.attr("href"));
                    editor.dom.removeClass(elementArray[i], "wiki_link");
                    editor.dom.removeClass(elementArray[i], "wiki_link_ext");
                    editor.dom.addClass(elementArray[i], $link.attr("class"));
                    if (components.targetNew) editor.dom.setAttrib(elementArray[i], "target", "_blank");
                    tinymce.mainEditor.plugins.wslinkoverlay.show(elementArray[i]);
                    if (linkTextChanged && 0 == i) {
                        editor.dom.setHTML(elementArray[i], jQuery("<div>").text(components.linkText).html());
                        break;
                    }
                }
                jQuery("a > a", tinymce.activeEditor.getDoc()).each(function() {
                    jQuery(this).parent().replaceWith(this);
                });
            } else editor.wsselection.setContent(this.editor.dom.getOuterHTML($link.get(0)));
            ws.common.track("Editor", "Add Link", $link.attr("href"));
            return true;
        },
        removeLink: function() {
            var editor = tinymce.activeEditor;
            if (editor.selection.isCollapsed()) {
                editor.wsselection.restore(true);
                var elm = editor.dom.getParent(editor.selection.getNode(), "A");
                if (elm) editor.dom.replace(jQuery("<span>", editor.getDoc()).get(0), elm, true);
            } else {
                editor.wsselection.restore();
                if (tinymce.isIE && !editor.selection.isCollapsed()) {
                    editor.selection.setContent('<span id="startMarker">﻿</span>' + editor.selection.getContent() + '<span id="endMarker">﻿</span>');
                    var start = jQuery("#startMarker", editor.getDoc());
                    var end = jQuery("#endMarker", editor.getDoc());
                    editor.dom.split(start.closest("a").get(0), start.get(0));
                    editor.dom.split(end.closest("a").get(0), end.get(0));
                    var link = start.next("a");
                    editor.selection.select(link.get(0), true);
                    start.remove();
                    end.remove();
                }
                editor.getDoc().execCommand("unlink", false, null);
                editor.wsselection.tightenSelection();
                var parentSpan = jQuery(editor.selection.getRng(true).startContainer).closest("span.wiki_link,span.wiki_link_new");
                parentSpan.before(parentSpan.html()).remove();
                editor.nodeChanged();
            }
        },
        componentsToLink: function(components) {
            var url;
            var clazz = null;
            if (components.pageName) {
                var object = null, method = null;
                if ("doc" == components.objectClass) {
                    object = "doc";
                    method = "view";
                } else if ("file" == components.objectClass) {
                    object = "file";
                    method = "view";
                }
                var path = ws.common.parseLink(components.pageName, object, method);
                if (components.wikiName == wikispaces_wikiName) url = path; else url = "http://" + components.wikiName + "." + wikispaces_domain + path;
                if (components.anchor) url += "#" + components.anchor;
                clazz = "wiki_link";
            } else if (components.mailTo) {
                url = "mailto:" + components.mailTo;
                clazz = "wiki_link_ext";
            } else {
                url = components.url;
                clazz = "wiki_link_ext";
            }
            url = encodeURI(url).replace(/%25/g, "%");
            var $link = jQuery("<a></a>", this.editor.getDoc()).attr("href", url).addClass(clazz);
            if (components.linkText) $link.text(components.linkText);
            if (components.targetNew) $link.attr("target", "_blank");
            return $link;
        },
        parseLink: function($elem) {
            var hrefText = $elem.attr("href");
            var wikiName = "";
            var pageName = "";
            var anchor = "";
            var extLink = "";
            var email = "";
            var objectClass = "page";
            hrefText = hrefText.replace(/^(\.\.\/)+/, "/");
            var rPathAndAnchor = "(?:/" + ws.common.PROJECT_INDICATOR + "/(.*?/.*?))?/(?:(page|file|doc)/view/)?([^#/]+)?(?:#(.+))?$";
            var rWikispacesURL = new RegExp("^(?:https?://)?([a-z0-9-]+)." + ws.common.escapeRegExp(wikispaces_domain) + rPathAndAnchor, "i");
            var rCurrentDomainURL = new RegExp("^(?:https?://)?" + ws.common.escapeRegExp(location.hostname) + rPathAndAnchor, "i");
            var rWikispacesURLPage = new RegExp("^" + rPathAndAnchor, "i");
            var matches = null;
            if (matches = rWikispacesURL.exec(hrefText)) {
                wikiName = matches[1];
                pageName = matches[4];
                if (!pageName && !matches[5]) pageName = "home";
                if (matches[2]) pageName = matches[2] + "/" + pageName;
                if (matches[3]) objectClass = matches[3];
                anchor = matches[5];
            } else if ((matches = rCurrentDomainURL.exec(hrefText)) || (matches = rWikispacesURLPage.exec(hrefText))) {
                wikiName = wikispaces_wikiName;
                pageName = matches[3];
                if (!pageName && !matches[4]) pageName = "home";
                if (matches[1]) pageName = matches[1] + "/" + pageName;
                if (matches[2]) objectClass = matches[2];
                anchor = matches[4];
            } else if (matches = hrefText.match(/^mailto:(.+)/i)) email = matches[1]; else extLink = hrefText;
            objectClass = objectClass.replace(/\/view\//, "");
            if (pageName) {
                pageName = pageName.replace(/\+/g, " ");
                pageName = decodeURIComponent(pageName);
            }
            if (anchor) {
                anchor = anchor.replace(/\+/g, " ");
                anchor = decodeURIComponent(anchor);
            }
            var linkText = $elem.text().replace(/\uFEFF/g, "");
            if ($elem.find("img").length) linkText = null;
            var targetNew = $elem.attr("target") && $elem.attr("target").match(/^_(blank|new)/);
            return {
                linkText: linkText,
                objectClass: objectClass,
                pageName: pageName,
                wikiName: wikiName,
                anchor: anchor,
                extLink: extLink,
                mailTo: email,
                targetNew: !!targetNew
            };
        },
        selectedLink: function() {
            return this.editor.wsselection.selectedLink();
        },
        selectedImage: function() {
            this.editor.wsselection.restore(true);
            return jQuery(this.editor.selection.getNode()).closest("img").get(0);
        },
        linkEnclosingSelectedImage: function() {
            return jQuery(this.selectedImage()).parent("a").get(0);
        },
        isBlockElementSelected: function() {
            return this.editor.selection.getContent().match(/(<\/?table>)|(<\/?tr>)|(<\/?td>)|(<\/?ul>)|(<\/?ol>)|(<\/?li>)/i);
        },
        selectedText: function() {
            this.editor.wsselection.restore(true);
            return this.editor.selection.getContent({
                format: "text"
            }).replace(/\uFEFF/g, "");
        }
    });
    tinymce.PluginManager.add("wslink", wikispaces.plugins.LinkPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.LinkOverlay", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            this.overlay = null;
            ed.onInit.add(function(editor) {
                var initFunc = function(editor) {
                    editor.onClick.add(function(editor, e) {
                        if ("A" == e.target.nodeName) plugin.show(e.target); else plugin.hide();
                    });
                };
                editor.onInitSubEditor.add(initFunc);
                initFunc(editor);
            });
            ed.onModeSwitch.add(function(mode) {
                if ("plain" == mode) plugin.hide();
            });
            jQuery(window).resize(function() {
                if (plugin.link && jQuery(plugin.link).is(":visible")) plugin.repositionAndShow();
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces link overlay",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        overlayContent: function() {
            return ws.editor.content.loadContent("linkProperties");
        },
        show: function(link) {
            var me = this;
            if (this.link == link) return;
            this.link = link;
            if (null == this.overlay) {
                this.overlay = jQuery("<div>").addClass("WikiOverlay overlayLayer").css({
                    position: "absolute"
                }).html(this.overlayContent()).hide().appendTo("#pageEditor");
                this.setup();
            }
            tinymce.mainEditor.plugins.wstableoverlay.unselectTableCell();
            var components = this.editor.plugins.wslink.parseLink(jQuery(this.link));
            jQuery(".linkOverlayLabel").hide();
            jQuery("#linkOverlayVisit").text("Visit").show();
            if (components.extLink) {
                jQuery("#linkOverlayLabelUrl").show();
                jQuery("#linkOverlayHref").text(ws.common.truncify(components.extLink, 60));
            } else if (components.mailTo) {
                jQuery("#linkOverlayLabelMailTo").show();
                jQuery("#linkOverlayHref").text(ws.common.truncify(components.mailTo, 60));
                jQuery("#linkOverlayVisit").hide();
            } else {
                if (components.wikiName && components.wikiName != wikispaces_wikiName) {
                    jQuery("#linkOverlayLabelWiki").show();
                    jQuery("#linkOverlayWiki").text(components.wikiName).show();
                }
                jQuery("#linkOverlayLabel" + ws.common.ucfirst(components.objectClass)).show();
                jQuery("#linkOverlayHref").text(ws.common.truncify(components.pageName, 60));
                if ("file" == components.objectClass) jQuery("#linkOverlayVisit").text("Show");
            }
            this.repositionAndShow();
        },
        hide: function() {
            if (jQuery(this.link).closest("td,th").length) tinymce.mainEditor.plugins.wstableoverlay.selectTableCell(jQuery(this.link).closest("td,th").get(0));
            if (this.overlay) this.overlay.hide();
            this.link = null;
        },
        repositionAndShow: function() {
            this.overlay.css({
                left: "-10000px",
                top: "-10000px"
            }).show();
            var location = this.editor.plugins.wscommon.positionBelow(this.overlay, this.link);
            this.overlay.css(location);
        },
        setup: function() {
            var me = this;
            jQuery("#linkOverlayVisit").click(function() {
                me.visitLink();
                return false;
            });
            jQuery("#linkOverlayChange").click(function() {
                me.changeLink();
                return false;
            });
            jQuery("#linkOverlayRemove").click(function() {
                me.removeLink();
                return false;
            });
        },
        visitLink: function() {
            window.open(jQuery(this.link).attr("href"));
            this.hide();
        },
        changeLink: function() {
            this.editor.execCommand("wslink");
            this.hide();
        },
        removeLink: function() {
            this.editor.undoManager.begin();
            this.editor.selection.select(this.link);
            this.editor.plugins.wslink.removeLink();
            this.editor.undoManager.end();
            this.hide();
        }
    });
    tinymce.PluginManager.add("wslinkoverlay", wikispaces.plugins.LinkOverlay);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.Link", {
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "linkTool",
                title: "Insert Link",
                width: 480,
                height: 250,
                wsselection: 2,
                onShow: function(o) {
                    me.onShow(o);
                },
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        setPlugin: function(plugin) {
            this.plugin = plugin;
        },
        onShow: function(o) {
            this.setPlugin(o.plugin);
            this.resetForms();
            if (o.plugin) o.plugin.setupForms();
        },
        resetForms: function() {
            jQuery("#linkDiv input").val("");
            jQuery("#linkText").closest("tr").show();
            jQuery("#linkTargetNew").prop("checked", false).prop("disabled", false);
            jQuery("#linkDiv #submitLink span span").text("Add Link");
            jQuery("#linkDiv #removeExistingLink").hide();
            jQuery("#linkWikiName").val(wikispaces_wikiName);
            jQuery("#linkWikiName").select2("data", {
                id: wikispaces_wikiName,
                text: wikispaces_wikiText
            });
            jQuery("#linkPageName").val("");
            jQuery("#linkPageName").select2("data", {
                id: "",
                text: ""
            });
            jQuery("#linkPageNameError").hide();
            this.hideAnchorField();
        },
        prefill: function(components) {
            if (null === components.linkText) jQuery("#linkText").closest("tr").hide();
            if (components.pageName || components.wikiName) this.prefillInternal(components.linkText, components.objectClass, components.pageName, components.wikiName, components.anchor, components.targetNew); else if (components.mailTo) this.prefillEmail(components.linkText, components.mailTo); else if (components.extLink) this.prefillExternal(components.linkText, components.extLink, components.targetNew); else if (components.linkText) {
                jQuery("#linkText").val(components.linkText);
                jQuery("#linkPageName").val(components.linkText);
                jQuery("#linkPageName").select2("data", {
                    id: "page:" + components.linkText,
                    text: components.linkText
                });
            }
        },
        prefillInternal: function(linkText, objectClass, pageName, wikiName, anchor, targetNew) {
            jQuery("#linkText").val(linkText);
            var wikiText = wikiName;
            if (wikispaces_wikiName == wikiName) wikiText = wikispaces_wikiText;
            jQuery("#linkWikiName").val(wikiName);
            jQuery("#linkWikiName").select2("data", {
                id: wikiName,
                text: wikiText
            });
            jQuery("#linkPageName").val(("page" == objectClass ? "" : objectClass + ":") + pageName);
            jQuery("#linkPageName").select2("data", {
                id: objectClass + ":" + pageName,
                text: pageName
            });
            jQuery("#linkAnchor").val(anchor);
            if (anchor) this.showAnchorField();
            jQuery("#linkTargetNew").prop("checked", targetNew);
            jQuery("#linkDiv #submitLink span span").text("Change Link");
            jQuery("#linkDiv #removeExistingLink").show();
            this.showInternal();
        },
        prefillExternal: function(linkText, url, targetNew) {
            jQuery("#linkText").val(linkText);
            jQuery("#linkUrl").val(url);
            jQuery("#linkTargetNew").prop("checked", targetNew);
            jQuery("#linkDiv #submitLink span span").text("Change Link");
            jQuery("#linkDiv #removeExistingLink").show();
            this.showExternal();
        },
        prefillEmail: function(linkText, address) {
            jQuery("#linkText").val(linkText);
            jQuery("#linkEmailAddress").val(address);
            jQuery("#linkDiv #submitLink span span").text("Change Link");
            jQuery("#linkDiv #removeExistingLink").show();
            this.showEmail();
        },
        disableSelect: function() {
            this.sessionFailure = true;
        },
        getValidatedLinkComponents: function() {
            var linkText;
            if (jQuery("#linkText").is(":visible")) {
                linkText = jQuery("#linkText").val();
                if ("" === linkText) {
                    alert("Please enter link text.");
                    return false;
                }
                if (!this.validateLinkText(linkText)) return false;
            }
            var targetNew = jQuery("#linkTargetNew").prop("checked");
            if ("Internal" == this.linkType) {
                var wikiName = jQuery("#linkWikiName").val();
                var pageName = jQuery("#linkPageName").val();
                var objectClass = "page";
                var matches = pageName.match(/(.+):(.+)/);
                if (matches) {
                    objectClass = matches[1];
                    pageName = matches[2];
                }
                if ("" === wikiName || "" === pageName) {
                    alert("Please enter a wiki and page name.");
                    return false;
                }
                if (!this.validatePageName(pageName)) return false;
                var anchor = null;
                if ("page" == objectClass) {
                    anchor = jQuery("#linkAnchor").val();
                    if (anchor && !this.validateAnchor(anchor)) return false;
                }
                return {
                    linkText: linkText,
                    wikiName: wikiName,
                    pageName: pageName,
                    objectClass: objectClass,
                    anchor: anchor,
                    targetNew: targetNew
                };
            } else if ("Email" == this.linkType) {
                var email = jQuery("#linkEmailAddress").val();
                if (!email.match(/.+@.+\..+/)) {
                    alert("Please enter a valid e-mail address.");
                    return false;
                }
                email = email.replace(/[\]\[{}|]/g, encodeURIComponent);
                return {
                    linkText: linkText,
                    mailTo: email
                };
            } else if ("External" == this.linkType) {
                var url = jQuery("#linkUrl").val();
                url = url.replace(/[\]\[{}|]/g, encodeURIComponent);
                if ("" === url) {
                    alert("Please enter a URL.");
                    return false;
                } else if (!url.match(/^[a-zA-Z0-9.+-]+:\/\//)) url = "http://" + url;
                return {
                    linkText: linkText,
                    url: url,
                    targetNew: targetNew
                };
            }
        },
        validatePageName: function(pageName) {
            if (pageName.match(/^\.\.?\s*$/)) {
                jQuery("#linkPageNameError").text("Wiki page names cannot be '.' or '..'.").show();
                return false;
            }
            if (pageName.length > 255) {
                jQuery("#linkPageNameError").text("Wiki page name cannot be more than 255 characters.").show();
                return false;
            }
            var project;
            var team;
            var page;
            var matches = pageName.match(ws.common.full_link_regex);
            if (matches) {
                project = matches[1];
                team = matches[2];
                page = matches[3];
            }
            var single_page_matches = pageName.match(ws.common.single_page_regex);
            if (single_page_matches) page = single_page_matches[2];
            if (!matches && !single_page_matches) {
                jQuery("#linkPageNameError").text("To link to a page in another team, use the format 'project/team/page'.").show();
                return false;
            }
            if (project && project.match(ws.common.projectNameRegex)) {
                jQuery("#linkPageNameError").text("Project names cannot contain: [ ] :").show();
                return false;
            }
            if (team && team.match(ws.common.teamNameRegex)) {
                jQuery("#linkPageNameError").text("Team names cannot contain: [ ] :").show();
                return false;
            }
            if (page.match(ws.common.pageNameRegex)) {
                jQuery("#linkPageNameError").text('Wiki page names cannot contain: [ ] : | { } $ + " # @').show();
                return false;
            }
            jQuery("#linkPageNameError").hide();
            return true;
        },
        validateLinkText: function(text) {
            if (text.match(/]]|]$/)) {
                jQuery("#linkTextError").show();
                return false;
            } else {
                jQuery("#linkTextError").hide();
                return true;
            }
        },
        validateAnchor: function(anchor) {
            if (anchor.match(/^[^\]\|]+$/)) {
                jQuery("#linkAnchorError").hide();
                return true;
            } else {
                jQuery("#linkAnchorError").show();
                return false;
            }
        },
        showInternal: function() {
            this.linkType = "Internal";
            jQuery("#linkDiv .selected").removeClass("selected");
            jQuery("#switchToInternal").addClass("selected");
            jQuery("#linkDiv .modeRow").hide();
            jQuery("#linkDiv .internalLink").show();
            jQuery("#linkTargetNew").prop("disabled", false);
            jQuery("#linkTextWiki").focus();
            if (jQuery("#linkAnchor").val()) this.showAnchorField(); else this.hideAnchorField();
        },
        showExternal: function() {
            this.linkType = "External";
            jQuery("#linkDiv .selected").removeClass("selected");
            jQuery("#switchToExternal").addClass("selected");
            jQuery("#linkDiv .modeRow").hide();
            jQuery("#linkDiv .externalLink").show();
            jQuery("#linkTargetNew").prop("disabled", false);
            jQuery("#url").focus();
        },
        showEmail: function() {
            this.linkType = "Email";
            jQuery("#linkDiv .selected").removeClass("selected");
            jQuery("#switchToEmail").addClass("selected");
            jQuery("#linkDiv .modeRow").hide();
            jQuery("#linkDiv .emailLink").show();
            jQuery("#linkTargetNew").prop("disabled", true);
            jQuery("#linkTextEmail").focus();
        },
        showAnchorField: function() {
            jQuery("#anchorCellOff").hide();
            jQuery("#anchorCellOn").show();
        },
        hideAnchorField: function() {
            jQuery("#anchorCellOff").show();
            jQuery("#anchorCellOn").hide();
        },
        uiSetup: function(popup) {
            var me = this;
            this.linkType = "Internal";
            jQuery("#switchToInternal").click(function() {
                me.showInternal();
            });
            jQuery("#switchToExternal").click(function() {
                me.showExternal();
            });
            jQuery("#switchToEmail").click(function() {
                me.showEmail();
            });
            jQuery("#linkWikiAnchor").click(function() {
                me.showAnchorField();
                return false;
            });
            ws.select2.wikiAndObject(jQuery("#linkWikiName"), jQuery("#linkPageName"));
            if (jQuery("#linkText").is(":visible")) {
                jQuery("#linkPageName").change(function() {
                    var val = jQuery(this).val().match(/(?:\w+\:)?(.*)/)[1];
                    if (val && (!jQuery("#linkText").val() || me.linkTextFromSelection)) {
                        jQuery("#linkText").val(val);
                        me.linkTextFromSelection = true;
                    }
                });
                jQuery("#linkText").change(function() {
                    me.linkTextFromSelection = false;
                });
            }
            var closePopup = function() {
                tinymce.activeEditor.focus();
                popup.close();
                tinymce.mainEditor.plugins.wsimageoverlay.refreshLinkStatus();
                return false;
            };
            jQuery("#submitLink").click(function(event) {
                var components = me.getValidatedLinkComponents();
                if (components) {
                    me.plugin.insertLinkFromComponents(components);
                    closePopup();
                }
            });
            jQuery("#removeExistingLink").click(function(event) {
                me.plugin.removeLink();
                closePopup();
            });
            jQuery("#linkCloseButton, #cancelLink").click(closePopup);
        }
    });
    tinymce.PluginManager.add("wslinkpopup", wikispaces.popups.Link);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.ListPlugin", {
        init: function(ed, url) {
            var me = this;
            var plugin = this;
            this.editor = ed;
            this.selectedItem = null;
            function generateList(command) {
                var headerName = null;
                if (jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6").size() > 0) headerName = jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6").get(0).nodeName;
                var closestList = jQuery(ed.selection.getNode()).closest("ul,ol");
                ed.execCommand(command);
                if (tinymce.isWebKit && headerName) {
                    var bookmark = ed.selection.getBookmark();
                    jQuery(ed.selection.getNode()).closest("li").wrapInner("<" + headerName + ">");
                    ed.selection.moveToBookmark(bookmark);
                }
                plugin.mergeLists(ed.selection.getNode());
            }
            ed.addCommand("wsInsertOrderedList", function() {
                generateList("InsertOrderedList");
            });
            ed.addCommand("wsInsertUnorderedList", function() {
                generateList("InsertUnorderedList");
            });
            ed.onNodeChange.add(function(ed, cm, n, co) {
                me.selectedItem = jQuery(n).closest("li").get(0);
                var tableSelected = ed.wsselection && ed.wsselection.selectedElements("table").length > 0;
                ed.theme.controlManager().setDisabled("insertorderedlist", tableSelected);
                ed.theme.controlManager().setDisabled("insertunorderedlist", tableSelected);
                ed.theme.controlManager().setDisabled("hr", null != me.selectedItem);
            });
            ed.onKeyDown.addToTop(function(ed, e) {
                if (!me.selectedItem || e.ctrlKey || e.altKey) return;
                if ("9" == e.keyCode) {
                    try {
                        ed.wsExecCommand("useCSS", false, true);
                    } catch (x) {}
                    ed.undoManager.add();
                    ed.undoManager.begin();
                    var tmpClass = "wsTmpLiWorkingClass";
                    jQuery("." + tmpClass, ed.getDoc()).removeClass(tmpClass);
                    var list = jQuery(ed.selection.getNode()).closest("li").addClass(tmpClass).children("ol,ul")[0];
                    if (list) {
                        var bookmark = ed.selection.getBookmark();
                        while (list) {
                            ed.dom.split(list.parentNode, list);
                            list = jQuery("." + tmpClass, ed.getDoc()).eq(0).removeClass(tmpClass).end().eq(1).children("ol,ul")[0];
                        }
                        ed.selection.moveToBookmark(bookmark);
                    }
                    jQuery("." + tmpClass, ed.getDoc()).removeClass(tmpClass);
                    if (e.shiftKey) if (!tinymce.isGecko) ed.wsExecCommand("outdent", false, ""); else {
                        bookmark = ed.selection.getBookmark();
                        var li = jQuery(ed.selection.getNode()).closest("li");
                        var parent = li.parent("ol,ul");
                        if (parent.length) if (parent.children().length > 1) li = jQuery(ed.dom.split(parent[0], li[0])); else li = parent.children().replaceAll(parent);
                        if (!li.parent().is("ol,ul")) li.replaceWith(jQuery("<p>", ed.getDoc()).append(li.contents()));
                        ed.selection.moveToBookmark(bookmark);
                    } else {
                        ed.wsExecCommand("indent", false, "");
                        if (tinymce.isWebKit) {
                            bookmark = ed.selection.getBookmark();
                            jQuery(ed.selection.getStart()).closest("li").addClass("wsholdstart");
                            jQuery(ed.selection.getEnd()).closest("li").addClass("wsholdend");
                            var done = false;
                            var start = false;
                            jQuery(ed.selection.getStart()).parents("ul,ol").last().find("li").each(function(i, elem) {
                                if (done) return;
                                if (jQuery(elem).is(".wsholdstart")) {
                                    jQuery(elem).removeClass("wsholdstart");
                                    start = true;
                                }
                                if (jQuery(elem).is(".wsholdend")) {
                                    jQuery(elem).removeClass("wsholdend");
                                    done = true;
                                }
                                if (start) jQuery(elem).children("br:first-child").remove();
                            });
                            ed.selection.moveToBookmark(bookmark);
                        }
                        if (tinymce.isGecko) {
                            var bq = jQuery(ed.selection.getNode()).parent().closest("blockquote");
                            var children = bq.children();
                            if (1 == children.length && children.eq(0).is("ol,ul")) {
                                var bookmark = ed.selection.getBookmark();
                                var nodeName = children[0].nodeName.toLowerCase();
                                bq.wrapInner("<" + nodeName + ">").children().eq(0).unwrap();
                                ed.selection.moveToBookmark(bookmark);
                            }
                        }
                    }
                    ed.undoManager.end();
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
                if (tinymce.isGecko) ed.onSetContent.add(function() {
                    jQuery("li", ed.getBody()).each(function(i, elem) {
                        if (0 == elem.childNodes.length) jQuery(elem).html("<br/>");
                    });
                });
            });
            var webkitNewHeaderListItem = false;
            ed.onKeyDown.addToTop(function(ed, e) {
                if (!me.selectedItem || e.ctrlKey || e.altKey) return;
                if ("13" == e.keyCode && !e.shiftKey && tinymce.isIE) {
                    var li = jQuery(ed.selection.getNode()).closest("li");
                    if (li.length && "" == li.text() && !li.find("img").length) {
                        ed.selection.setContent('<span id="_ws_new_cursor">﻿</span>');
                        li.parent().find("li").each(function(i, elem) {
                            if ("" == jQuery(elem).text() && !jQuery(elem).find("img").length) jQuery(elem).html('<span class="wsTemp">﻿</span>');
                        });
                        li = jQuery(ed.dom.split(li.parent()[0], li[0]));
                        li.parent().find("span.wsTemp").remove();
                        if (!li.parent().is("ol,ul")) {
                            if (!li.find("br:last-child").length) li.append("<br>");
                            li.wrapInner("<p>").replaceWith(li.contents());
                        }
                        var cursor = jQuery("#_ws_new_cursor", ed.getDoc());
                        cursor.after(ed.getDoc().createTextNode(""));
                        ed.selection.select(cursor[0].nextSibling, true);
                        ed.selection.collapse(false);
                        cursor.remove();
                        tinymce.dom.Event.cancel(e);
                        return;
                    } else {
                        li = jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6,p,div").closest("li");
                        if (li.length) {
                            ed.selection.setContent('<span id="_ws_splitonme">﻿</span><span id="_ws_new_cursor">﻿</span>');
                            var split = jQuery("#_ws_splitonme", ed.getDoc());
                            jQuery(ed.dom.split(split.closest("li")[0], split[0])).remove();
                            var block = jQuery("#_ws_new_cursor", ed.getDoc()).closest("h1,h2,h3,h4,h5,h6,p,div");
                            block.replaceWith(block.contents());
                            var cursor = jQuery("#_ws_new_cursor", ed.getDoc());
                            var li = cursor.closest("li");
                            cursor.remove();
                            li.prepend(ed.getDoc().createTextNode(""));
                            ed.selection.select(li[0].firstChild, true);
                            ed.selection.collapse(false);
                            tinymce.dom.Event.cancel(e);
                            return;
                        }
                    }
                }
                if ("13" == e.keyCode) {
                    function reinsertChildList() {
                        var childList = jQuery(ed.selection.getNode()).closest("li").find("ul,ol").first();
                        if (!childList.length) childList = jQuery(ed.selection.getNode()).next("ul,ol");
                        var item = jQuery("<li>&nbsp;</li>").insertBefore(childList);
                        childList.appendTo(item);
                        var span = jQuery("<span>", ed.getDoc()).prependTo(item);
                        ed.plugins.wscommon.cursorToAndRemoveElement(span);
                        tinymce.dom.Event.cancel(e);
                    }
                    if (tinymce.isGecko && !e.shiftKey && ed.wsselection.isInFrontOf("ul,ol")) reinsertChildList(); else if ((tinymce.isGecko || tinymce.isWebKit) && "" == jQuery(ed.selection.getNode()).text() && !jQuery(ed.selection.getNode()).find("img").length && jQuery(ed.selection.getNode()).parents("ol,ul").length >= 2) {
                        var li = jQuery(ed.selection.getNode()).closest("li");
                        var span;
                        if (li.parent("ul,ol").prev("li").get(0)) {
                            span = jQuery("<span>", ed.getDoc()).prependTo(jQuery("<li><br/>").insertAfter(li.parent()));
                            if (tinymce.isGecko) setTimeout(function() {
                                jQuery("ul > br:only-child", ed.getDoc()).parent().remove();
                            }, 100);
                        } else span = jQuery("<span>", ed.getDoc()).prependTo(jQuery("<li><br/>").insertAfter(li.parents("li").first()));
                        setTimeout(function() {
                            ed.plugins.wscommon.cursorToAndRemoveElement(span);
                        }, 100);
                        li.remove();
                        tinymce.dom.Event.cancel(e);
                    } else if (tinymce.isWebKit) if (e.shiftKey && ed.wsselection.isInFrontOf("ul,ol")) jQuery(ed.selection.getNode()).closest("li").find("ul,ol").first().before("<br/>"); else if (!e.shiftKey && jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6").size() > 0) if (ed.wsselection.isAtTheEndOf("li")) {
                        var span = jQuery("<span>", ed.getDoc()).prependTo(jQuery("<li><br/>").insertAfter(jQuery(ed.selection.getNode()).parent("li")));
                        ed.plugins.wscommon.cursorToAndRemoveElement(span);
                        tinymce.dom.Event.cancel(e);
                    } else if (ed.wsselection.isInFrontOf("ul,ol")) reinsertNestedList(); else webkitNewHeaderListItem = true;
                }
            });
            ed.onKeyUp.add(function(ed, e) {
                if (e.shiftKey || e.ctrlKey || e.altKey) return;
                if (tinymce.isWebKit) {
                    if (me.selectedItem && "8" == e.keyCode) {
                        var thisLi = jQuery(ed.selection.getNode()).closest("li");
                        var nextChildren = thisLi.next("li").children();
                        if (nextChildren.eq(0).is("ul,ol")) {
                            var nextUl = nextChildren.eq(0);
                            nextUl.remove();
                            thisLi.append(nextUl);
                            if (0 == thisLi.next("li").children().length) thisLi.next("li").remove();
                        }
                    }
                    if (webkitNewHeaderListItem) {
                        var header = jQuery(ed.selection.getNode()).closest("h1,h2,h3,h4,h5,h6").wrap("<li>");
                        ed.plugins.wscommon.cursorToAndRemoveElement(jQuery("<span>", ed.getDoc()).prependTo(header));
                        webkitNewHeaderListItem = false;
                    }
                }
            });
        },
        mergeLists: function(node) {
            var ed = this.editor;
            var list = jQuery(node).parents("ul,ol").last();
            while (list.prev().is("ul,ol")) list = list.prev();
            while (list.is("ul,ol")) {
                list.find("ol,ul").each(function(i, elem) {
                    var j = jQuery(elem);
                    if (j.closest("body")[0] == ed.getBody() && j.prev().length && j.prev()[0].nodeName == j[0].nodeName && ed.plugins.wscommon.areNodesAdjacent(j.prev()[0], j[0])) {
                        j.prepend(j.prev().html());
                        j.prev().remove();
                    }
                });
                list = list.next();
                if (list[0] && list[0].nodeName == list.prev()[0].nodeName) {
                    list.prepend(list.prev().html());
                    list.prev().remove();
                }
            }
        },
        getInfo: function() {
            return {
                longname: "Wikispaces list",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.PluginManager.add("wslist", wikispaces.plugins.ListPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    var UNRESIZEABLE_CLASSES = [ "WikiAnchor", "WikiReference", "WikiMediaRss", "WikiMediaToc", "WikiMediaCustom" ];
    tinymce.create("wikispaces.plugins.ObjectResizePlugin", {
        init: function(ed, url) {
            this.editor = ed;
            var plugin = this;
            ed.onInit.add(function() {
                if (tinymce.isGecko) {
                    ed.onMouseDown.add(function(ed, e) {
                        plugin.enableObjectResizing(plugin.isResizable(e.target));
                    });
                    ed.onKeyDown.add(function(ed, e) {
                        if (e.keyCode >= 33 && e.keyCode <= 40) plugin.enableObjectResizing(false);
                    });
                }
                if (tinymce.isIE) ed.dom.bind(ed.getDoc(), "controlselect", function(e) {
                    return plugin.isResizable(e.srcElement);
                });
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces object resize",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        isResizable: function(n) {
            var elem = jQuery(n);
            return elem.is("img,pre") && !this.hasAnyClass(elem, UNRESIZEABLE_CLASSES);
        },
        enableObjectResizing: function(flag) {
            if (this.resizingEnabled === flag) return;
            this.resizingEnabled = flag;
            try {
                this.editor.execCommand("enableObjectResizing", false, flag, {
                    skip_undo: true
                });
            } catch (ex) {}
            this.editor.execCommand("mceRepaint", false);
        },
        hasAnyClass: function(el, classnames) {
            for (var i = 0; i < classnames.length; i++) if (jQuery(el).hasClass(classnames[i])) return true;
            return false;
        }
    });
    tinymce.PluginManager.add("wsobjectresize", wikispaces.plugins.ObjectResizePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.PopupPlugin", {
        popups: {},
        popupStack: [],
        zIndex: 4e5,
        BORDER_HEIGHT: 40,
        BORDER_WIDTH: 15,
        register: function(settings) {
            if (!settings.wsname || this.popups[settings.wsname]) return false;
            settings = jQuery.extend({}, settings);
            this.popups[settings.wsname] = settings;
        },
        show: function(wsname, showOptions) {
            var settings = this.popups[wsname];
            if (!settings) return false;
            if (void 0 !== settings.wsselection && false !== settings.wsselection) {
                if (!(settings.stackPosition >= 0)) tinymce.activeEditor.undoManager.begin();
                tinymce.activeEditor.wsselection.save(settings.wsselection);
            }
            if (!settings.popup) settings.popup = this._openPopup(settings);
            var top = this._getTopPopup();
            if (top && settings.wsname == top.wsname) return settings.popup;
            if (settings.stackPosition >= 0) this.popupStack.splice(settings.stackPosition, 1);
            if (top) top.popup.blur();
            var zIndex = this._getMaxZIndex() || this.zIndex;
            var jPopup = jQuery("#" + settings.popup.id);
            jPopup.css("z-index", zIndex + 2);
            settings.stackPosition = this.popupStack.length;
            this.popupStack.push(settings);
            settings.popup.focus();
            jPopup.show();
            jQuery(window).on("resize." + settings.popup.id, function() {
                clearTimeout(settings.popup.resizeTimeoutId);
                settings.popup.resizeTimeoutId = setTimeout(function() {
                    settings.popup.resize();
                }, 10);
            });
            settings.popup.resize(true);
            this._lightBox();
            if (settings.onShow) {
                if (!showOptions) showOptions = {};
                settings.onShow(showOptions);
            }
            return settings.popup;
        },
        hide: function(wsname) {
            var settings = this.popups[wsname];
            if (!settings || !settings.popup) return false;
            if (settings.stackPosition >= 0) {
                this.popupStack.splice(settings.stackPosition, 1);
                settings.stackPosition = -1;
                var top = this._getTopPopup();
                if (top) top.popup.focus(); else {
                    tinymce.activeEditor.focus();
                    if (void 0 !== settings.wsselection && false !== settings.wsselection) tinymce.activeEditor.wsselection.restore();
                }
                if (void 0 !== settings.wsselection && false !== settings.wsselection) tinymce.activeEditor.undoManager.end();
            }
            jQuery(window).off("." + settings.popup.id);
            jQuery("#" + settings.popup.id).hide();
            this._lightBox();
            return true;
        },
        resize: function(wsname, center) {
            var settings = this.popups[wsname];
            if (!settings || !settings.popup) return false;
            settings.popup.resize(center);
            return true;
        },
        _getTopPopup: function() {
            return this.popupStack[this.popupStack.length - 1];
        },
        _getMaxZIndex: function() {
            var top = this._getTopPopup();
            if (!top) return 0;
            return jQuery("#" + top.popup.id).css("z-index");
        },
        _lightBox: function(zIndex) {
            var level = this._getMaxZIndex() - 1;
            var blocker = jQuery("#wsPopupModalBlocker");
            if (!blocker.length) blocker = jQuery("<div>").attr("id", "wsPopupModalBlocker").addClass("ui-widget-overlay").appendTo(jQuery("body"));
            if (level < 0) blocker.hide(); else blocker.css("z-index", level).show();
        },
        _openPopup: function(settings) {
            var me = this;
            settings = jQuery.extend({
                min_width: settings.width,
                min_height: settings.height
            }, settings);
            if (void 0 == settings.content) settings.content = "<div>" + ws.editor.content.loadContent(settings.wsname) + "</div>";
            settings.id = tinymce.DOM.uniqueId();
            var jPopup = jQuery("<div>").addClass("wsPopup ui-corner-all").attr("id", settings.id).css({
                width: settings.width,
                height: settings.height,
                overflow: "hidden",
                "z-index": -1
            }).append(settings.content).appendTo(jQuery("body"));
            jQuery.extend(settings, {
                close: function() {
                    me.hide(settings.wsname);
                },
                blur: function() {
                    jPopup.removeClass("wsPopupFocus");
                },
                focus: function() {
                    jPopup.addClass("wsPopupFocus");
                },
                resize: function(center) {
                    me._resizePopup(this, center);
                }
            });
            if (settings.uiSetup) settings.uiSetup(settings);
            this._moveIntoView(settings, true);
            this._resizePopup(settings, true);
            return settings;
        },
        _resizePopup: function(popup, center) {
            if (!popup) return false;
            var me = this;
            var jPopup = jQuery("#" + popup.id);
            var sizeToElement = jPopup.children().eq(0);
            jPopup.ready(function() {
                setTimeout(function() {
                    var width = sizeToElement.outerWidth(true);
                    var height = sizeToElement.outerHeight(true);
                    if (jQuery.browser.safari) {
                        alternateWidth = sizeToElement.outerWidth();
                        alternateHeight = sizeToElement.outerHeight();
                        if (alternateWidth > width) width = alternateWidth;
                        if (alternateHeight > height) height = alternateHeight;
                    }
                    var extraPush = 0;
                    var pushSize = function() {
                        var tableWidth = jQuery(this).outerWidth(true) + extraPush;
                        var tableHeight = jQuery(this).outerHeight(true) + extraPush;
                        if (tableWidth > width) width = tableWidth;
                        if (tableHeight > height) height = tableHeight;
                    };
                    sizeToElement.find("table").each(pushSize);
                    extraPush = 20;
                    sizeToElement.find("iframe").each(pushSize);
                    if (height < popup.min_height) height = popup.min_height;
                    if (width < popup.min_width) width = popup.min_width;
                    var css = {};
                    var moveToLeft = false;
                    var moveToTop = false;
                    var windowHeight = jQuery(window).height() - me.BORDER_HEIGHT;
                    var windowWidth = jQuery(window).width() - me.BORDER_WIDTH;
                    if (height > windowHeight) width += jQuery.getScrollbarWidth();
                    if (width > windowWidth) {
                        height += jQuery.getScrollbarWidth();
                        width = windowWidth;
                        css.overflowX = "scroll";
                        moveToLeft = true;
                    } else css.overflowX = "hidden";
                    if (height > windowHeight) {
                        height = windowHeight;
                        css.overflowY = "scroll";
                        moveToTop = true;
                    } else css.overflowY = "hidden";
                    css.width = width;
                    css.height = height;
                    jPopup.css(css);
                    me._moveIntoView(popup, center);
                }, 10);
            });
        },
        _moveIntoView: function(popup, center) {
            var windowHeight = jQuery(window).height();
            var windowWidth = jQuery(window).width();
            var jPopup = jQuery("#" + popup.id);
            var css = {};
            if (center) {
                css.top = (windowHeight - jPopup.height() + this.BORDER_WIDTH) / 2;
                css.left = (windowWidth - jPopup.width()) / 2;
            } else {
                var popupTop = parseInt(jPopup.css("top"));
                var popupLeft = parseInt(jPopup.css("left"));
                var hiddenHeight = windowHeight - jPopup.height() - popupTop - this.BORDER_WIDTH / 2;
                var hiddenWidth = windowWidth - jPopup.width() - popupLeft - this.BORDER_WIDTH / 2;
                if (hiddenHeight < 0) css.top = popupTop + hiddenHeight;
                if (hiddenWidth < 0) css.left = popupLeft + hiddenWidth;
            }
            jPopup.css(css);
        }
    });
    tinymce.PluginManager.add("wspopup", wikispaces.plugins.PopupPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.PreviewPlugin", {
        init: function(ed, url) {
            this.editor = ed;
            var plugin = this;
            ed.addCommand("preview", function() {
                plugin.showPreview();
            });
            ed.addCommand("endPreview", function() {
                plugin.hidePreview();
            });
            ed.onModeSwitch.add(function(mode) {
                if (jQuery("#previewBox").length) plugin.hidePreview();
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces preview",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        showPreview: function() {
            var me = this;
            var content = this.editor.plugins.wscommon.fullContent(true, "empty");
            this.getPreviewData(content, this.editor.plugins.wscommon.getOption("mode"), function(previewData) {
                me.hideEditor();
                var previewBox = jQuery("<div></div>").attr("id", "previewBox").addClass("wiki editorLayer").css({
                    width: "100%",
                    position: "relative"
                }).html(previewData);
                jQuery(me.editor.getContainer()).append(previewBox);
                me.editor.theme.showToolSet("preview");
                WikispacesCommentManager.hideAll();
                me.commentSpaces = WikispacesCommentManager.preemptSpaces();
                WikispacesCommentManager.readOnly = true;
                me.previewSpace = new WikispacesCommentSpace(previewBox, "#wsMainEditor_container", "#wsMainEditor_container");
                WikispacesCommentManager.showAll();
                ws.math.process("previewBox");
            });
        },
        hidePreview: function() {
            jQuery("#previewBox").remove();
            this.editor.theme.showToolSet();
            jQuery(".mceToolbar.spinner").remove();
            jQuery(".mceToolbar").show();
            this.showEditor();
            WikispacesCommentManager.removeSpace(this.previewSpace);
            WikispacesCommentManager.restoreSpaces(this.commentSpaces);
            WikispacesCommentManager.readOnly = false;
            if ("visual" == this.editor.plugins.wscommon.getOption("mode")) WikispacesCommentManager.redrawAll(true); else WikispacesCommentManager.hideAll();
        },
        getPreviewData: function(content, mode, callback) {
            var me = this;
            var spinner = jQuery("<div></div>").attr("id", "previewSpinner").addClass("wikispaces_content").addClass("mceToolbar spinner").css({
                textAlign: "center"
            }).html('Loading Preview <img src="/i/spinner.gif" alt="" width="18" height="18" style="padding-top: 9px; vertical-align: -4px;"/>');
            jQuery(".mceToolbar").hide();
            jQuery(me.editor.plugins.wscommon.editorToolbar()).append(spinner);
            var errorFunction = function(request, textStatus, errorThrown) {
                ws.session.reloadSession(function() {
                    me.showPreview();
                }, 3e3, function() {
                    me.editor.plugins.wscommon.sessionReloadFailed();
                    jQuery(".mceToolbar.spinner").remove();
                    jQuery(".mceToolbar").show();
                });
            };
            jQuery.ajax({
                url: ws.common.pathFor("page", "preview", wikispaces_page),
                type: "POST",
                async: true,
                cache: false,
                data: {
                    content: content,
                    mode: mode
                },
                dataType: "xml",
                global: false,
                error: errorFunction,
                success: function(data, textStatus, request) {
                    ws.common.log("showPreviewResponse", data);
                    ws.session.reloadSessionSuccess();
                    var jXml = jQuery(data);
                    var previewData = "";
                    if (jXml.find("preview").length) callback(jXml.find("preview").text());
                    jQuery(".mceToolbar.spinner").remove();
                    jQuery(".mceToolbar").show();
                    if (jXml.find("preview").length) return;
                    if (jXml.find("error").length) {
                        var error = jXml.find("error").attr("message");
                        alert(error);
                    } else alert("An unexpected error occurred.");
                }
            });
        },
        hideEditor: function() {
            this.bookmark = null;
            try {
                this.bookmark = this.editor.selection.getBookmark(2);
            } catch (e) {}
            jQuery(".WikiOverlay").hide();
            this.frameHeight = jQuery(this.editor.plugins.wscommon.editorIFrame()).height();
            jQuery(this.editor.getContentAreaContainer()).hide();
            jQuery("#referenceEditors").hide();
        },
        showEditor: function() {
            jQuery(this.editor.getContentAreaContainer()).show();
            jQuery(this.editor.plugins.wscommon.editorIFrame()).height(this.frameHeight);
            jQuery("#referenceEditors").show();
            var me = this;
            setTimeout(function() {
                try {
                    if (me.bookmark) me.editor.selection.moveToBookmark(me.bookmark);
                } catch (e) {}
                me.editor.focus();
                me.editor.wsselection.ensureCursor();
            }, 100);
        }
    });
    tinymce.PluginManager.add("wspreview", wikispaces.plugins.PreviewPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.ReferencePlugin", {
        popup: null,
        init: function(ed, url) {
            this.editor = ed;
            var plugin = this;
            this.nextRefId = 0;
            ed.onBeforeSetContent.addToTop(function(ed, o) {
                if ((o.load || o.wsautoload) && "visual" == ed.plugins.wscommon.getOption("mode")) {
                    plugin.removeReferenceEditors();
                    plugin.pullOutReferences(o);
                }
            });
            ed.onModeSwitch.add(function(mode) {
                if ("plain" == mode) plugin.removeReferenceEditors();
            });
            var detectCitations = function() {
                for (var i = 0; i <= plugin.nextRefId; i++) {
                    var citationExists = jQuery(ed.getDoc()).find("#citation-" + i).length > 0;
                    var referenceActive = plugin.isReferenceActive(i);
                    if (referenceActive && !citationExists || !referenceActive && citationExists) plugin.toggleReference(i);
                }
            };
            var sortCitations = function() {
                var citations = jQuery(ed.getDoc()).find("img.WikiReference");
                var citationOrder = jQuery.map(citations, function(elem) {
                    return plugin.elementIdToRefId(jQuery(elem).attr("id"));
                });
                var referenceEditors = jQuery("#referenceEditors div.referenceEditorContainer:visible");
                var referenceOrder = jQuery.map(referenceEditors, function(elem) {
                    return plugin.elementIdToRefId(jQuery(elem).attr("id"));
                });
                if (citationOrder.join(",") != referenceOrder.join(",")) jQuery.each(citationOrder, function(i, refId) {
                    var editor = tinymce.editors["reference-editor-" + refId];
                    var html = editor.getContent({
                        format: "raw"
                    });
                    tinymce.mainEditor.plugins.wsundomain.removeEditor(editor);
                    editor.undoManager.subClear();
                    editor.remove();
                    editor.destroy();
                    jQuery("#reference-editor-container-" + refId).remove();
                    plugin.addReferenceEditor(refId, html);
                });
            };
            var detectAndSortCitations = function() {
                detectCitations();
            };
            ed.onChange.add(function(ed) {
                setTimeout(detectAndSortCitations, 0);
            });
            ed.onUndo.add(detectAndSortCitations);
            ed.onRedo.add(detectAndSortCitations);
            var priorSelection = false;
            ed.onKeyDown.add(function(ed) {
                priorSelection = !ed.selection.isCollapsed();
            });
            ed.onKeyUp.add(function(ed, e) {
                if (8 == e.keyCode || 46 == e.keyCode || priorSelection) detectCitations();
            });
            ed.onDblClick.add(function(ed, e) {
                if (jQuery(e.target).is("img.WikiReference")) {
                    var refId = plugin.elementIdToRefId(jQuery(e.target).attr("id"));
                    var refEditor = tinymce.editors["reference-editor-" + refId];
                    jQuery.scrollTo(refEditor.getContentAreaContainer(), {
                        axis: "y",
                        duration: 500
                    });
                    refEditor.focus();
                }
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces reference",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        getNextRefId: function() {
            return ++this.nextRefId;
        },
        elementIdToRefId: function(elementId) {
            return elementId.match(/-(\d+)$/)[1];
        },
        pullOutReferences: function(o) {
            var withinPre = false;
            var me = this;
            o.content = o.content.replace(/(&lt;ref(?:&gt;|>)((?:.|\n)*?)&lt;\/ref(?:&gt;|>))|(<pre\s+.*?>)|(<\/pre>)/gim, function() {
                if (arguments[1] && !withinPre) {
                    var refId = me.getNextRefId();
                    var html = me.makeReferenceHtml(refId);
                    me.addReferenceEditor(refId, arguments[2]);
                    return html;
                } else if (arguments[3]) withinPre = true; else if (arguments[4]) withinPre = false;
                return arguments[0];
            });
        },
        pushInReferences: function(content) {
            ws.common.log("pushInReferences");
            return content.replace(/<img[^>]*?id="?citation-(\d+)[^>]*?>/gi, function(m, refId) {
                var html = tinymce.editors["reference-editor-" + refId].getContent();
                return "&lt;ref&gt;" + html + "&lt;/ref&gt;";
            });
        },
        makeReferenceHtml: function(id) {
            return '<img src="/i/icon_16_numbersquare.png" alt="Reference - double click to edit" title="Reference - double click to view" width="16" height="16" class="WikiReference" id="citation-' + id + '"/> ';
        },
        insertReferenceAtSelection: function() {
            var refId = this.getNextRefId();
            this.editor.wsselection.setContent(this.makeReferenceHtml(refId));
            var citation = jQuery(this.editor.getDoc()).find("#citation-" + refId);
            var index = jQuery(this.editor.getDoc()).find("img.WikiReference").index(citation);
            return this.addReferenceEditor(refId, "Type the content of your reference here.", index);
        },
        addReferenceEditor: function(refId, html, index) {
            var me = this;
            var areaId = "reference-editor-" + refId;
            var edHtml = '<div id="reference-editor-container-' + refId + '" class="editorLayer referenceEditorContainer">' + '<textarea id="' + areaId + '"></textarea></div>';
            if (0 == jQuery("#referenceEditors").length) jQuery("#pageEditor").append('<div id="referenceEditors"></div>');
            if ("undefined" != typeof index && jQuery("div#referenceEditors > div:nth-child(" + (index + 1) + ")").size() > 0) jQuery("div#referenceEditors > div:nth-child(" + (index + 1) + ")").before(edHtml); else jQuery("#referenceEditors").append(edHtml);
            var readyCallback = function(ed) {
                ed.setContent(html);
            };
            return this.editor.plugins.wssubeditor.create(areaId, {
                reference_reference_id: refId,
                height: "50",
                theme: "-reference"
            }, null, readyCallback);
        },
        toggleReference: function(refId) {
            if (this.isReferenceActive(refId)) {
                jQuery("#reference-editor-container-" + refId).hide();
                this.editor.focus();
                this.editor.undoManager.begin();
                jQuery(this.editor.getDoc()).find("#citation-" + refId).remove();
                this.editor.undoManager.end();
            } else jQuery("#reference-editor-container-" + refId).show();
        },
        isReferenceActive: function(refId) {
            return jQuery("#reference-editor-container-" + refId).is(":visible");
        },
        referenceCount: function() {
            return jQuery("#referenceEditors div.referenceEditorContainer").size();
        },
        killEditor: function(editor, refId) {
            editor.remove();
            editor.destroy();
            jQuery("#reference-editor-container" + refId).remove();
            jQuery("#reference-editor-" + refId).remove();
        },
        killZombieEditor: function(editor, refId, delay) {
            var me = this;
            _.delay(function() {
                if (editor.initialized) me.killEditor(editor, refId); else me.killZombieEditor(editor, refId, 2 * delay);
            }, delay);
        },
        removeReferenceEditors: function() {
            var me = this;
            jQuery.each(tinymce.editors.concat(), function() {
                if (match = this.id.match(/^reference-editor-(\d)+/)) {
                    var refId = parseInt(match[1]);
                    if (this.initialized) me.killEditor(this, refId); else me.killZombieEditor(this, refId, 500);
                }
            });
        }
    });
    tinymce.PluginManager.add("wsreference", wikispaces.plugins.ReferencePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.util.TimeTracker", {
        TimeTracker: function(opt_bucket) {
            if (opt_bucket) this.bucket_ = opt_bucket.sort(this.sortNumber); else this.bucket_ = this.DEFAULT_BUCKET;
        },
        startTime_: null,
        stopTime_: null,
        bucket_: null,
        DEFAULT_BUCKET: [ 100, 500, 1500, 2500, 5e3 ],
        _getTimeDiff: function() {
            return this.stopTime_ - this.startTime_;
        },
        sortNumber: function(a, b) {
            return a - b;
        },
        _recordStartTime: function(opt_time) {
            if (void 0 != opt_time) this.startTime_ = opt_time; else this.startTime_ = new Date().getTime();
        },
        _recordEndTime: function(opt_time) {
            if (void 0 != opt_time) this.stopTime_ = opt_time; else this.stopTime_ = new Date().getTime();
        },
        _track: function(tracker, opt_event_obj_name, opt_event_label) {
            var eventTracker;
            if (void 0 != opt_event_obj_name && 0 != opt_event_obj_name.length) eventTracker = tracker._createEventTracker(opt_event_obj_name); else eventTracker = tracker._createEventTracker("TimeTracker");
            var i;
            var bucketString;
            for (i = 0; i < this.bucket_.length; i++) if (this._getTimeDiff() < this.bucket_[i]) if (0 == i) {
                bucketString = "0-" + this.bucket_[0];
                break;
            } else {
                bucketString = this.bucket_[i - 1] + "-" + (this.bucket_[i] - 1);
                break;
            }
            if (!bucketString) bucketString = this.bucket_[i - 1] + "+";
            try {
                eventTracker._trackEvent(bucketString, opt_event_label, this._getTimeDiff());
            } catch (e) {}
        },
        _setHistogramBuckets: function(buckets_array) {
            this.bucket_ = buckets_array.sort(this.sortNumber);
        }
    });
    tinymce.create("wikispaces.plugins.SavePlugin", {
        timeTracker: null,
        init: function(ed, url) {
            this.editor = ed;
            this.noDirtyCheck = false;
            this.timeTracker = new wikispaces.util.TimeTracker();
            this.timeTracker._setHistogramBuckets([ 1e3 * 1 * 60, 1e3 * 2 * 60, 1e3 * 5 * 60, 1e3 * 10 * 60, 1e3 * 20 * 60, 1e3 * 30 * 60, 1e3 * 60 * 60 ]);
            this.timeTracker._recordStartTime();
            var plugin = this;
            ed.addCommand("wsSave", function() {
                plugin.save();
            });
            ed.addCommand("wsSaveAndContinue", function() {
                plugin.saveAndContinue();
            });
            ed.onSaveContent.add(function(ed, o) {
                plugin.editor.plugins.wsautosave.autosave(false);
            });
            ed.onInit.add(function() {
                window.onbeforeunload = function(e) {
                    if (!plugin.noDirtyCheck && plugin.isContentDirty()) {
                        tinymce.mainEditor.plugins.wsautosave.autosave(false);
                        return "You have not saved your changes.";
                    }
                };
            });
        },
        createControl: function(n, cm) {
            var me = this;
            if ("wssave" == n) {
                var c = cm.createSplitButton("wssave", {
                    title: "Save",
                    label: "Save",
                    onclick: function() {
                        me.editor.wsExecCommand("wsSave");
                    }
                });
                var saveWithComment;
                var switchModes;
                var saveAndContinue;
                c.onRenderMenu.add(function(c, m) {
                    saveWithComment = m.add({
                        title: "Save with Comment",
                        icon: "saveWithComment",
                        onclick: function() {
                            tinymce.mainEditor.plugins.wspopup.show("saveWithComment");
                            jQuery("#saveWithCommentComment").focus();
                        }
                    });
                    saveWithComment.setDisabled(true);
                    saveAndContinue = m.add({
                        title: "Save and Continue",
                        icon: "saveContinue",
                        onclick: function() {
                            c.setDisabled(true);
                            me.editor.wsExecCommand("wsSaveAndContinue");
                        }
                    });
                    saveAndContinue.setDisabled(true);
                    switchModes = m.add({
                        id: "switchEditorModes",
                        title: "visual" == me.editor.plugins.wscommon.getOption("mode") ? "Wikitext Editor" : "Visual Editor",
                        icon: "saveTextEditor",
                        onclick: function() {
                            me.editor.execCommand("wstext");
                        }
                    });
                });
                c.originalShow = c.showMenu;
                c.showMenu = function() {
                    var scrollTop = jQuery(window).scrollTop();
                    c.originalShow();
                    jQuery(window).scrollTop(scrollTop);
                    jQuery("#menu_wsMainEditor_wsMainEditor_wssave_menu").css({
                        borderBottom: "1px solid #d4d0c9",
                        borderRight: "1px solid #d4d0c9"
                    }).appendTo(document.body);
                    me.editor.plugins.wstoolbarscroll.moveScroller();
                    if (ws.editor.content.isLoaded) {
                        saveWithComment.setDisabled(false);
                        saveAndContinue.setDisabled(false);
                    }
                    if (me.editor.plugins.wscommon.reloadFailed) switchModes.setDisabled(true);
                    me.editor.plugins.wscommon.resizeToolbar();
                };
            } else if ("wscancel" == n) var c = cm.createButton("wscancel", {
                title: "Cancel",
                label: "Cancel",
                "class": "mceButtonNotReallyLabeled mceButtonGroup",
                onclick: function() {
                    ws.common.track("Editor", "Stop", "Cancel");
                    me.timeTracker._recordEndTime();
                    try {
                        _gaq.push(function() {
                            me.timeTracker._track(_gat._getTrackerByName(), void 0, "Editor");
                        });
                    } catch (e) {}
                    if (me.isContentDirty()) me.editor.plugins.wsautosave.autosave(false);
                    me.noDirtyCheck = true;
                    document.location = me.editor.getParam("wssave_cancel_url");
                }
            });
            return c;
        },
        getInfo: function() {
            return {
                longname: "Wikispaces save",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        save: function() {
            this.editor.plugins.wsautosave.autosave(false);
            var content;
            if ("failed" == this.editor.plugins.wsautosave.mergeStatus) {
                var replaceResults = confirm("Someone else has saved changes to this page since you started editing. You are about to overwrite some of their changes.\n\n" + "Click OK to save. Your edits will overwrite the other person's changes.\n\n" + "Click Cancel to return to editing. We will show you the other person's saved changes. Where there are conflicts, you can copy their changes into your edit by hand.");
                if (replaceResults) {
                    ws.common.track("Editor", "Concurrent Editing", "Merge Failed - Overwrite");
                    content = this.editor.plugins.wscommon.fullContent(true, "bookmarks,empty");
                } else {
                    ws.common.track("Editor", "Concurrent Editing", "Merge Failed - Cancel");
                    this.editor.plugins.wsautosave.showConcurrentEditorPopup();
                    return false;
                }
            } else if ("success" == this.editor.plugins.wsautosave.mergeStatus) content = this.editor.plugins.wsautosave.mergeResult; else content = this.editor.plugins.wscommon.fullContent(true, "bookmarks,empty");
            ws.common.track("Editor", "Stop", "Save");
            this.timeTracker._recordEndTime();
            try {
                _gaq.push(function() {
                    if (this.timeTracker) this.timeTracker._track(_gat._getTrackerByName(), void 0, "Editor");
                });
            } catch (e) {}
            var form = jQuery(this.editor.getElement()).closest("form");
            this.noDirtyCheck = true;
            this.addComments(form.get(0));
            form.find("#wsMainEditor").val(content);
            form.submit();
        },
        saveAndContinue: function() {
            this.editor.plugins.wsautosave.autosave(false);
            if ("failed" == this.editor.plugins.wsautosave.mergeStatus) {
                var replaceResults = confirm("Someone else has saved changes to this page since you started editing. You are about to overwrite some of their changes.\n\n" + "Click OK to save. Your edits will overwrite the other person's changes.\n\n" + "Click Cancel to return to editing. We will show you the other person's saved changes. Where there are conflicts, you can copy their changes into your edit by hand.");
                if (replaceResults) ws.common.track("Editor", "Concurrent Editing", "Merge Failed - Overwrite"); else {
                    ws.common.track("Editor", "Concurrent Editing", "Merge Failed - Cancel");
                    this.editor.plugins.wsautosave.showConcurrentEditorPopup();
                    return false;
                }
            }
            var content = this.editor.plugins.wscommon.fullContent(true, "bookmarks,empty");
            var form = jQuery(this.editor.getElement()).closest("form");
            this.noDirtyCheck = true;
            this.addComments(form.get(0));
            form.find("#wsMainEditor").val(content);
            form.attr("target", "target_editor");
            this.editor.plugins.wscommon.setOption("saveAndContinue", 1);
            var esto = this;
            jQuery("#target_editor").one("load", function() {
                esto.editor.plugins.wscomment.markCommentsSaved();
            });
            form.submit();
        },
        isContentDirty: function() {
            if ("visual" == this.editor.plugins.wscommon.getOption("mode")) {
                for (var i = 0; i < tinymce.editors.length; i++) if (tinymce.editors[i].isDirty()) return true;
                return false;
            } else return tinymce.mainEditor.plugins.wstext.isDirty();
        },
        addComments: function(form) {
            this.editor.plugins.wscommon.setOption("pageComments", JSON.stringify(this.editor.plugins.wscomment.newComments()));
        }
    });
    tinymce.PluginManager.add("wssave", wikispaces.plugins.SavePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.SaveWithComment", {
        editor: null,
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "saveWithComment",
                title: "Save With Comment",
                width: 430,
                height: 100,
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        uiSetup: function(popup) {
            var editor = this.editor;
            jQuery("#saveWithCommentComment").keydown(function(e) {
                switch (e.which) {
                  case 13:
                    jQuery("#saveWithCommentSave").click();
                    break;

                  case 27:
                    jQuery("#saveWithCommentCancel").click();
                }
            });
            jQuery("#saveWithCommentSave").click(function(e) {
                ws.common.track("Editor", "Stop", "Comment");
                editor.plugins.wscommon.setOption("comment", jQuery("#saveWithCommentComment").val());
                editor.wsExecCommand("wsSave");
                e.preventDefault();
                return false;
            });
            jQuery("#saveWithCommentCancel").click(function(e) {
                popup.close();
                e.preventDefault();
                return false;
            });
            jQuery("#saveWithCommentClose").click(function(e) {
                popup.close();
                e.preventDefault();
                return false;
            });
        }
    });
    tinymce.PluginManager.add("wssavewithcommentpopup", wikispaces.popups.SaveWithComment);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.SelectionPlugin", {
        init: function(ed, url) {
            ed.onInit.add(function() {
                ed.wsselection = new wikispaces.util.Selection(ed);
            });
            if (!tinymce.isIE) {
                ed.onKeyUp.add(function(ed, e) {
                    if (16 == e.keyCode && !ed.selection.isCollapsed()) ed.wsselection.tightenSelection();
                });
                ed.onMouseUp.add(function(ed, e) {
                    if (!ed.selection.isCollapsed()) ed.wsselection.tightenSelection();
                });
                ed.onExecCommand.add(function(ed, e) {
                    if (!ed.selection.isCollapsed()) ed.wsselection.tightenSelection();
                });
            }
        },
        getInfo: function() {
            return {
                longname: "Wikispaces selection",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.create("wikispaces.util.Selection", {
        bookmark: null,
        type: null,
        textBookmark: null,
        editor: null,
        Selection: function(editor) {
            this.editor = editor;
        },
        save: function(type) {
            if ("visual" == this.editor.plugins.wscommon.getOption("mode") && this.bookmark || "visual" != this.editor.plugins.wscommon.getOption("mode") && this.textBookmark) return null;
            return this.saveOver(type);
        },
        saveOver: function(type) {
            if ("visual" == this.editor.plugins.wscommon.getOption("mode")) {
                this.bookmarkIsCollapsed = this.editor.selection.isCollapsed();
                try {
                    this.bookmark = this.editor.selection.getBookmark(type);
                    this.type = type;
                    return this.bookmark;
                } catch (e) {
                    return null;
                }
            }
            var textArea = this.editor.plugins.wstext.editorTextArea();
            this.editor.plugins.wstext.prepareSelection(textArea);
            this.textBookmark = {
                start: textArea.sel_start,
                end: textArea.sel_end
            };
            return this.textBookmark;
        },
        updateBookmarkToNode: function(node) {
            this.editor.selection.select(node);
            this.editor.nodeChanged();
            var type = this.type;
            if (null === type) type = 0;
            this.saveOver(type);
        },
        restore: function(keep) {
            if ("visual" == this.editor.plugins.wscommon.getOption("mode")) {
                if (this.bookmark) {
                    this.editor.selection.moveToBookmark(jQuery.extend({}, this.bookmark, {
                        keep: keep
                    }));
                    if (this.bookmarkIsCollapsed) this.editor.selection.collapse(true);
                    if (!keep) {
                        this.bookmark = null;
                        this.type = null;
                    }
                }
            } else if (this.textBookmark) {
                var textArea = this.editor.plugins.wstext.editorTextArea();
                this.editor.plugins.wstext.setSelectionRange(textArea, this.textBookmark.start, this.textBookmark.end);
                if (!keep) this.textBookmark = null;
            }
        },
        setContent: function(html, avoid) {
            var editor = this.editor;
            if ("visual" == this.editor.plugins.wscommon.getOption("mode")) {
                var jHtml = jQuery("<div>").append(html);
                jHtml.find("img").addClass("NewWikiImage");
                html = jHtml.html();
                editor.focus();
                this.restore();
                if (avoid) this.avoid(avoid);
                editor.selection.setContent(html);
                editor.undoManager.add();
                if (editor.onNeedsResize) editor.onNeedsResize.dispatch();
                jQuery("img.NewWikiImage", editor.selection.getNode()).removeClass("NewWikiImage").load(function() {
                    if (editor.onNeedsResize) editor.onNeedsResize.dispatch();
                }).each(function() {
                    this.src = this.src;
                });
            } else {
                this.editor.plugins.wstext.editorTextArea().focus();
                this.restore();
                this.editor.plugins.wstext.insertInEditor(html);
                if (this.textBookmark) this.textBookmark.end = this.textBookmark.start;
            }
        },
        avoid: function(selector) {
            var selection = this.editor.selection;
            var avoidElem = jQuery(selection.getNode()).closest(selector).get(0);
            if (avoidElem) {
                selection.select(avoidElem);
                selection.collapse();
            }
        },
        selectedLink: function() {
            if (this.bookmark && this.bookmark.id) {
                var bmStart = jQuery("#" + this.bookmark.id + "_start", this.editor.getDoc()).closest("a");
                if (bmStart.length > 0) return bmStart.get(0);
                var bmEnd = jQuery("#" + this.bookmark.id + "_end", this.editor.getDoc()).closest("a");
                if (bmEnd.length > 0) return bmEnd.get(0);
                var bmStartNext = jQuery("#" + this.bookmark.id + "_start", this.editor.getDoc()).next("a");
                if (bmStartNext.length > 0) return bmStartNext.get(0);
            } else ;
            return jQuery(this.editor.selection.getNode()).closest("a").get(0);
        },
        ensureCursor: function() {
            if (tinymce.isIE || "visual" != this.editor.plugins.wscommon.getOption("mode")) return;
            var me = this;
            setTimeout(function() {
                jQuery("input.WikiSearchInput").first().focus();
                jQuery(me.editor.plugins.wscommon.editorIFrame()).focus();
            }, 500);
        },
        selectAll: function() {
            this.editor.selection.select(this.editor.getBody(), true);
        },
        canStepIntoNode: function(node) {
            if (!node || 3 != node.nodeType && 1 != node.nodeType) return false;
            switch (node.nodeName) {
              case "BR":
              case "HR":
              case "EMBED":
              case "FRAMESET":
              case "FRAME":
              case "IFRAME":
              case "IMG":
              case "OBJECT":
                return false;

              default:
                return true;
            }
        },
        tightenSelection: function() {
            if (tinymce.isIE) return;
            var selection = this.editor.selection;
            var rng = selection.getRng(true);
            var startNode = rng.startContainer;
            var startOffset = rng.startOffset;
            var endNode = rng.endContainer;
            var endOffset = rng.endOffset;
            newNode = null;
            while (rng.compareBoundaryPoints(Range.START_TO_END, rng) > 0) {
                if (3 == endNode.nodeType) {
                    if (0 < endOffset) break;
                    newNode = endNode.previousSibling;
                } else if (1 == endNode.nodeType) if (endOffset > 0) newNode = endNode.childNodes[endOffset - 1]; else newNode = endNode.previousSibling; else break;
                var newOffset = null;
                if (!newNode) {
                    newNode = endNode.parentNode;
                    newOffset = 0;
                }
                if (!this.canStepIntoNode(newNode)) break;
                if (null === newOffset) if (3 == newNode.nodeType) newOffset = newNode.nodeValue.length; else if (1 == newNode.nodeType) newOffset = newNode.childNodes.length; else break;
                endNode = newNode;
                endOffset = newOffset;
                rng.setEnd(endNode, endOffset);
            }
            if (rng.compareBoundaryPoints(Range.START_TO_END, rng) <= 0) {
                endNode = startNode;
                endOffset = startOffset;
                rng.setStart(startNode, startOffset);
            }
            var newNode = null;
            while (rng.compareBoundaryPoints(Range.START_TO_END, rng) > 0) {
                if (3 == startNode.nodeType) {
                    if (startNode.nodeValue.length > startOffset) break;
                    newNode = startNode.nextSibling;
                } else if (1 == startNode.nodeType) if (startOffset < startNode.childNodes.length) newNode = startNode.childNodes[startOffset]; else newNode = startNode.nextSibling; else break;
                var newOffset = null;
                if (!newNode) {
                    newNode = startNode.parentNode;
                    if (3 == newNode.nodeType) newOffset = newNode.nodeValue.length; else if (1 == newNode.nodeType) newOffset = newNode.childNodes.length;
                }
                if (!this.canStepIntoNode(newNode)) break;
                if (null === newOffset) newOffset = 0;
                startNode = newNode;
                startOffset = newOffset;
                rng.setStart(startNode, startOffset);
            }
            if (rng.compareBoundaryPoints(Range.START_TO_END, rng) <= 0) {
                startNode = endNode;
                startOffset = endOffset;
                rng.setEnd(endNode, endOffset);
            }
            selection.setRng(rng);
        },
        isInitialTextNode: function(node) {
            if (3 != node.nodeType) return false;
            var sib = node.prevSibling;
            while (null != sib) {
                if (3 != sib.nodeType || "" != sib.nodeValue) return false;
                sib = sib.prevSibling;
            }
            return true;
        },
        isTerminalTextNode: function(node) {
            if (3 != node.nodeType) return false;
            var sib = node.nextSibling;
            while (null != sib) {
                if (3 != sib.nodeType || "" != sib.nodeValue) return false;
                sib = sib.nextSibling;
            }
            return true;
        },
        isAtTheBeginningOf: function(selector) {
            if (!this.editor.selection.isCollapsed() || !jQuery(this.editor.selection.getNode()).closest(selector).length > 0) return false;
            var rng = this.editor.selection.getRng(true);
            if (0 != rng.startOffset || !this.isInitialTextNode(rng.startContainer)) return false;
            var elem = this.editor.selection.getNode();
            while (!jQuery(elem).is(selector)) {
                if (jQuery(elem).prev().size() > 0) return false;
                elem = elem.parentNode;
            }
            return true;
        },
        isAtTheEndOf: function(selector) {
            if (!this.editor.selection.isCollapsed() || !jQuery(this.editor.selection.getNode()).closest(selector).length > 0) return false;
            var rng = this.editor.selection.getRng(true);
            if (rng.endContainer.length != rng.endOffset || !this.isTerminalTextNode(rng.endContainer)) return false;
            var elem = this.editor.selection.getNode();
            while (!jQuery(elem).is(selector)) {
                if (jQuery(elem).next().size() > 0) return false;
                elem = elem.parentNode;
            }
            return true;
        },
        mineOrParentsNextSibling: function(elem, selector) {
            if (0 == jQuery(elem).next().size() && elem.parentNode) return this.mineOrParentsNextSibling(elem.parentNode, selector); else return jQuery(elem).next().is(selector);
        },
        isInFrontOf: function(selector) {
            if (!this.editor.selection.isCollapsed()) return false;
            var rng = this.editor.selection.getRng(true);
            if (3 != rng.endContainer.nodeType || rng.endContainer.length != rng.endOffset) return false;
            if (jQuery(rng.endContainer.nextSibling).is(selector)) return true; else return this.mineOrParentsNextSibling(this.editor.selection.getNode(), selector);
        },
        selectedElements: function(selector) {
            var rng = this.editor.selection.getRng(true);
            var startElem = 1 != rng.startContainer.nodeType ? rng.startContainer.parentNode : rng.startContainer;
            var endElem = 1 != rng.endContainer.nodeType ? rng.endContainer.parentNode : rng.endContainer;
            var elem = startElem, elems = [];
            while (null != elem) {
                if (jQuery(elem).is(selector)) elems.push(elem);
                if (elem == endElem) break;
                if (jQuery(elem).has(endElem).size() > 0) {
                    jQuery(elem).find("*").each(function() {
                        if (jQuery(this).is(selector)) elems.push(this);
                        if (this == endElem) return false;
                    });
                    break;
                }
                jQuery(elem).find(selector).each(function() {
                    elems.push(this);
                });
                if (jQuery(elem).next().size() > 0) elem = jQuery(elem).next().get(0); else elem = jQuery(elem).parents().next().get(0);
            }
            return elems;
        },
        normalizeOutsideLinks: function() {
            var rng = this.editor.selection.getRng(true);
            var start = rng.startContainer;
            if (3 == start.nodeType) start = start.parentNode;
            if (jQuery(start).is("a")) rng.setStartBefore(start);
            var end = rng.endContainer;
            if (3 == end.nodeType) end = end.parentNode;
            if (jQuery(end).is("a")) rng.setEndAfter(end);
            this.editor.selection.setRng(rng);
        },
        contentBefore: function() {
            var saveRng = this.editor.selection.getRng(true);
            var rng = saveRng.cloneRange();
            rng.collapse(true);
            rng.insertNode(jQuery("<span>", this.editor.getDoc()).attr("id", "_CB").get(0));
            var fullContent = this.editor.getContent({
                format: "raw",
                no_events: 1
            });
            jQuery("#_CB", this.editor.getDoc()).remove();
            this.editor.selection.setRng(saveRng);
            var match = fullContent.match(/<span id="_CB"/i);
            if (match) return fullContent.substring(0, match.index); else return "";
        },
        contentAfter: function() {
            var saveRng = this.editor.selection.getRng(true);
            var rng = saveRng.cloneRange();
            rng.collapse(false);
            rng.insertNode(jQuery("<span>", this.editor.getDoc()).attr("id", "_CB").get(0));
            var fullContent = this.editor.getContent({
                format: "raw",
                no_events: 1
            });
            jQuery("#_CB", this.editor.getDoc()).remove();
            this.editor.selection.setRng(saveRng);
            var match = fullContent.match(/<span id="_CB".*?\/span>/i);
            if (match) return fullContent.substr(match.index + match[0].length); else return "";
        },
        withinCode: function() {
            return jQuery(this.editor.selection.getStart()).closest("pre").size() > 0 || jQuery(this.editor.selection.getEnd()).closest("pre").size() > 0;
        },
        withinMath: function() {
            var mathRegexp = /\[\[math\]\]/g;
            var beforeMatch = this.contentBefore().match(mathRegexp);
            var afterMatch = this.contentAfter().match(mathRegexp);
            return beforeMatch && 0 != beforeMatch.length % 2 || afterMatch && 0 != afterMatch.length % 2;
        }
    });
    tinymce.PluginManager.add("wsselection", wikispaces.plugins.SelectionPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.StylePlugin", {
        firstTime: true,
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.addCommand("wsStyle", function() {
                ws.common.track("Editor", "Open Style Tool");
                var se = ed.selection;
                if (jQuery(se.getNode()).closest("pre").length) {
                    alert("You cannot apply a style inside of a code block.");
                    return;
                }
                var span = plugin.getSelectedSpan(se);
                var div = plugin.getSelectedDiv(se);
                tinymce.mainEditor.plugins.wspopup.show("stylePopupContents", {
                    plugin: plugin,
                    span: span,
                    div: div
                });
            });
            ed.addButton("wsstyle", {
                title: "Style Text",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsStyle");
                }
            });
            ed.onNodeChange.add(function(ed, cm, n, co) {
                if (ws.editor.content.isLoaded) cm.setDisabled("wsstyle", ed.wsselection && ed.wsselection.withinCode());
                cm.setActive("wsstyle", jQuery(n).closest("span,div,font,strike,s").length > 0);
            });
            ed.plugins.wscommon.disableUntilLibsLoad(ed, "wsstyle");
        },
        getInfo: function() {
            return {
                longname: "Wikispaces style",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        applyStyle: function() {
            ws.common.track("Editor", "Apply Style");
            var styleText = jQuery(document["styleForm"].styleText).val();
            var editor = tinymce.activeEditor;
            editor.wsselection.restore();
            if (editor.selection.isCollapsed()) {
                var selectSpan = jQuery(editor.selection.getNode()).closest("span").get(0);
                if (selectSpan) {
                    editor.selection.setContent('<span id="splitter">﻿</span>');
                    var splitter = jQuery("#splitter", editor.getDoc()).removeAttr("id").get(0);
                    editor.dom.split(selectSpan, splitter);
                    editor.selection.select(splitter, true);
                    if (!tinymce.isWebKit) {
                        editor.selection.collapse();
                        jQuery(splitter).remove();
                    }
                }
            } else this.removeStyle();
            var parsedStyles = editor.dom.parseStyle(styleText);
            if (parsedStyles["text-align"] && "auto" != parsedStyles["text-align"]) {
                var block = jQuery(editor.selection.getNode()).closest("div,p,td,th,li,h1,h2,h3,h4,h5,h6");
                if (block.length) {
                    if (!block.is("div")) {
                        var bookmark = editor.selection.getBookmark();
                        div = jQuery("<div>", editor.getDoc());
                        block.wrapInner("<div>");
                        block = block.children("div").eq(0);
                        editor.selection.moveToBookmark(bookmark);
                    }
                    block.css("text-align", parsedStyles["text-align"]);
                    delete parsedStyles.display;
                    delete parsedStyles["text-align"];
                }
            } else if (!parsedStyles["text-align"] || "auto" == parsedStyles["text-align"]) jQuery(editor.selection.getNode()).closest("div,p,td,th,li,h1,h2,h3,h4,h5,h6").css("text-align", "");
            styleText = "";
            for (var elem in parsedStyles) styleText += elem + ": " + parsedStyles[elem] + ";" + "\n";
            if (!styleText) return;
            if (editor.selection.isCollapsed() && tinymce.isIE) return this.applyCaretStyleIE(editor, styleText);
            editor.formatter.register("ws_style", {
                inline: "span",
                styles: parsedStyles
            });
            editor.formatter.apply("ws_style");
        },
        applyCaretStyleIE: function(editor, styleText) {
            var id = editor.dom.uniqueId();
            var doc = editor.getDoc();
            var rng = doc.selection.createRange();
            editor.selection.setContent(jQuery("<div>").append(jQuery("<span>").attr("style", styleText).attr("id", id).text("﻿")).html());
            rng.moveToElementText(jQuery("#" + id, doc)[0]);
            rng.select();
        },
        removeStyle: function() {
            var editor = tinymce.activeEditor;
            editor.wsselection.restore(true);
            editor.execCommand("RemoveFormat");
            editor.nodeChanged();
        },
        setSpanText: function(node) {
            if (!node) return;
            var style = jQuery(node).attr("style");
            if (!style) return;
            var me = this;
            document["styleForm"].removeStyleButton.disabled = false;
            jQuery.each(tinymce.activeEditor.dom.parseStyle(style), function(k, v) {
                if ("function" != typeof v) me.setSpanTextValue(k, v);
            });
        },
        setSpanTextValue: function(styleAttribute, value) {
            var fixedStyleAttribute = ws.common.normalizeCssSelector(styleAttribute);
            ws.common.log("setting " + styleAttribute + " as " + fixedStyleAttribute + " with " + value);
            switch (fixedStyleAttribute) {
              case "fontSize":
                jQuery(document["styleForm"].styleSize).val(value);
                break;

              case "fontFamily":
                var font = value.replace(/,\s*/gi, ", ");
                jQuery(document["styleForm"].styleFont).val(font);
                break;

              case "color":
                var realColor = new RGBColor(value).toHex().toUpperCase();
                jQuery(document["styleForm"].styleColor).val(realColor);
                jQuery.farbtastic("#colorpickerColor").setColor(realColor);
                break;

              case "backgroundColor":
                var realColor = new RGBColor(value).toHex().toUpperCase();
                jQuery(document["styleForm"].styleBackgroundColor).val(realColor);
                jQuery.farbtastic("#colorpickerBackgroundColor").setColor(realColor);
                break;

              case "textAlign":
                jQuery(document["styleForm"].styleAlignment).val(value);
                break;

              case "verticalAlign":
                jQuery(document["styleForm"].styleVertical).val(value);
                if (jQuery(document["styleForm"].styleVertical).val() != value) {
                    var opt = jQuery("<option>").val(value).html(value);
                    jQuery(document["styleForm"].styleVertical).append(opt);
                    jQuery(document["styleForm"].styleVertical).val(value);
                }
                break;

              case "textDecoration":
                if ("line-through" == value || "lineThrough" == value) jQuery(document["styleForm"].styleStrike).prop("checked", true);
                break;

              case "accelerator":
              case "csstext":
              case "cssText":
                break;

              default:
                jQuery(document["styleForm"].styleText).val(jQuery(document["styleForm"].styleText).val() + "\n" + styleAttribute + ": " + value + ";");
            }
        },
        getUsedColors: function() {
            var colors = new Array();
            jQuery.each(tinymce.editors, function() {
                jQuery(this.dom.select("span,div")).each(function() {
                    var jThis = jQuery(this);
                    if (jThis.css("color") && "transparent" != jThis.css("color")) colors[colors.length] = new RGBColor(jThis.css("color")).toHex().toUpperCase();
                    if (jThis.css("backgroundColor") && "transparent" != jThis.css("backgroundColor")) colors[colors.length] = new RGBColor(jThis.css("backgroundColor")).toHex().toUpperCase();
                });
            });
            return colors;
        },
        getSelectedDiv: function(selection) {
            var selectedFrag = selection.getRng(true).cloneContents();
            var foundDiv = null;
            if (!foundDiv) foundDiv = jQuery(selection.getNode()).closest("div").get(0);
            return foundDiv;
        },
        getSelectedSpan: function(selection) {
            var selectedFrag = selection.getRng(true).cloneContents();
            var foundSpan = null;
            for (var i = 0; i < selectedFrag.childNodes.length; ++i) {
                var node = selectedFrag.childNodes[i];
                if (3 == node.nodeType && ("" == node.nodeValue || "﻿" == node.nodeValue)) continue;
                if (1 != node.nodeType || foundSpan) {
                    foundSpan = null;
                    break;
                }
                foundSpan = node;
            }
            if (!foundSpan) foundSpan = jQuery(selection.getNode()).closest("span,font,strike,s").get(0);
            if (foundSpan && foundSpan.nodeName.toLowerCase().match(/^(font|strike|s)$/)) {
                var nodeName = foundSpan.nodeName.toLowerCase();
                if ("s" == nodeName) nodeName = "strike";
                var fontSizes = tinymce.explode(tinymce.settings.font_size_style_values);
                var filters = {
                    font: {
                        backgroundColor: foundSpan.style.backgroundColor,
                        color: foundSpan.color,
                        fontFamily: foundSpan.face,
                        fontSize: fontSizes[parseInt(foundSpan.size) - 1]
                    },
                    strike: {
                        textDecoration: "line-through"
                    }
                };
                this.editor.wsselection.restore();
                this.editor.wsselection.save();
                var newSpan = this.editor.dom.create("span", {
                    style: filters[nodeName]
                });
                this.editor.dom.replace(newSpan, foundSpan, 1);
                this.editor.wsselection.restore(true);
                foundSpan = newSpan;
            }
            return foundSpan;
        }
    });
    tinymce.PluginManager.add("wsstyle", wikispaces.plugins.StylePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.Style", {
        plugin: null,
        currentColorInput: null,
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "stylePopupContents",
                title: "Color and Style",
                width: 680,
                height: 350,
                wsselection: 0,
                onShow: function(o) {
                    me.onShow(o);
                },
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        onShow: function(o) {
            this.setPlugin(o.plugin);
            this.resetSpanText();
            var previousColors = [];
            if (o.plugin) {
                o.plugin.setSpanText(o.div);
                o.plugin.setSpanText(o.span);
                previousColors = this.dedupeColors(o.plugin.getUsedColors());
            }
            this.setupSwatches(this.getStyleColors(previousColors));
            this.mergeBasicStyleToAdvanced();
            this.updatePreviewStyle();
            if (this.editor.selection.isCollapsed()) jQuery("#removeStyleButton").hide(); else jQuery("#removeStyleButton").show();
        },
        setPlugin: function(plugin) {
            this.plugin = plugin;
        },
        resetSpanText: function() {
            this.resetSpanStyleSize();
            this.resetSpanStyleFont();
            this.resetSpanStyleColor();
            this.resetSpanStyleBackgroundColor();
            this.resetSpanStyleAlignment();
            this.resetSpanStyleVertical();
            this.resetSpanStyleStrike();
            jQuery(document["styleForm"].styleText).val("");
        },
        resetSpanStyleSize: function() {
            jQuery(document["styleForm"].styleSize).val("100%");
        },
        resetSpanStyleFont: function() {
            jQuery(document["styleForm"].styleFont).val("");
        },
        resetSpanStyleColor: function() {
            jQuery.farbtastic("#colorpickerColor").setColor("#000000");
            jQuery(document["styleForm"].styleColor).val("");
        },
        resetSpanStyleBackgroundColor: function() {
            jQuery.farbtastic("#colorpickerBackgroundColor").setColor("#FFFFFF");
            jQuery(document["styleForm"].styleBackgroundColor).val("");
        },
        resetSpanStyleAlignment: function() {
            jQuery(document["styleForm"].styleAlignment).val("");
        },
        resetSpanStyleVertical: function() {
            jQuery(document["styleForm"].styleVertical).val("");
        },
        resetSpanStyleStrike: function() {
            jQuery(document["styleForm"].styleStrike).prop("checked", false);
        },
        mergeAdvancedStyleToBasic: function() {
            var text = jQuery(document["styleForm"].styleText).val();
            var matches;
            if (matches = text.match(/^\s*font-size:\s*(.+?);*\s*$/im)) this.plugin.setSpanTextValue("font-size", matches[1]); else this.resetSpanStyleSize();
            if (matches = text.match(/^\s*font-family:\s*(.+?);*\s*$/im)) this.plugin.setSpanTextValue("font-family", matches[1]); else this.resetSpanStyleFont();
            if (matches = text.match(/^\s*color:\s*(.+?);*\s*$/im)) this.plugin.setSpanTextValue("color", matches[1]); else this.resetSpanStyleColor();
            if (matches = text.match(/^\s*background-color:\s*(.+?);*\s*$/im)) this.plugin.setSpanTextValue("background-color", matches[1]); else this.resetSpanStyleBackgroundColor();
            if (matches = text.match(/^\s*text-align:\s*(.+?);*\s*$/im)) this.plugin.setSpanTextValue("text-align", matches[1]); else this.resetSpanStyleAlignment();
            if (matches = text.match(/^\s*vertical-align:\s*(.+?);*\s*$/im)) this.plugin.setSpanTextValue("vertical-align", matches[1]); else this.resetSpanStyleVertical();
            if (matches = text.match(/^\s*text-decoration:\s*(.+?);*\s*$/im)) this.plugin.setSpanTextValue("text-decoration", matches[1]); else this.resetSpanStyleStrike();
        },
        updatePreviewStyle: function() {
            if ("none" != jQuery(".styleBasic").css("display")) this.mergeBasicStyleToAdvanced();
            var previewStyle = jQuery.trim(document["styleForm"].styleText.value).replace(/;?\n/gim, "; ");
            jQuery("#stylePreviewApplied").attr("style", previewStyle);
        },
        mergeBasicStyleToAdvanced: function() {
            var text = jQuery(document["styleForm"].styleText).val();
            var size = jQuery(document["styleForm"].styleSize).val();
            var font = jQuery(document["styleForm"].styleFont).val();
            var color = jQuery(document["styleForm"].styleColor).val();
            var backgroundColor = jQuery(document["styleForm"].styleBackgroundColor).val();
            var alignment = jQuery(document["styleForm"].styleAlignment).val();
            var vertical = jQuery(document["styleForm"].styleVertical).val();
            var strike = jQuery(document["styleForm"].styleStrike).prop("checked");
            if (size && "100%" != size) if (text.match(/^\s*font-size:\s*.*$/gim)) text = text.replace(/^\s*font-size:\s*.*$/gim, "font-size: " + size + ";"); else text = text + "\nfont-size: " + size + ";"; else text = text.replace(/^\s*font-size:\s*.*$/gim, "");
            if (font) if (text.match(/^\s*font-family:\s*.*$/gim)) text = text.replace(/^\s*font-family:\s*.*$/gim, "font-family: " + font + ";"); else text = text + "\nfont-family: " + font + ";"; else text = text.replace(/^\s*font-family:\s*.*$/gim, "");
            if (color) if (text.match(/^\s*color:\s*.*$/gim)) text = text.replace(/^\s*color:\s*.*$/gim, "color: " + color + ";"); else text = text + "\ncolor: " + color + ";"; else text = text.replace(/^\s*color:\s*.*$/gim, "");
            if (backgroundColor) if (text.match(/^\s*background-color:\s*.*$/gim)) text = text.replace(/^\s*background-color:\s*.*$/gim, "background-color: " + backgroundColor + ";"); else text = text + "\nbackground-color: " + backgroundColor + ";"; else text = text.replace(/^\s*background-color:\s*.*$/gim, "");
            if (alignment) {
                if (text.match(/^\s*text-align:\s*.*$/gim)) text = text.replace(/^\s*text-align:\s*.*$/gim, "text-align: " + alignment + ";"); else text = text + "\ntext-align: " + alignment + ";";
                if (!text.match(/^\s*display:\s*block;\s*$/gim)) text += "\ndisplay: block;";
            } else {
                text = text.replace(/^\s*text-align:\s*.*$/gim, "");
                text = text.replace(/^\s*display:\s*block;\s*$/gim, "");
            }
            if (vertical) if (text.match(/^\s*vertical-align:\s*.*$/gim)) text = text.replace(/^\s*vertical-align:\s*.*$/gim, "vertical-align: " + vertical + ";"); else text = text + "\nvertical-align: " + vertical + ";"; else text = text.replace(/^\s*vertical-align:\s*.*$/gim, "");
            if (strike) if (text.match(/^\s*text-decoration:\s*.*$/gim)) text = text.replace(/^\s*text-decoration:\s*.*$/gim, "text-decoration: line-through;"); else text += "\ntext-decoration: line-through;"; else text = text.replace(/^\s*text-decoration:\s*.*$/gim, "");
            jQuery(document["styleForm"].styleText).val(jQuery.trim(text));
        },
        dedupeColors: function(colors) {
            colors.sort();
            var uniqueColors = new Array();
            var previous = null;
            for (var i = 0; i < colors.length; i++) {
                if (colors[i] != previous) uniqueColors[uniqueColors.length] = colors[i];
                previous = colors[i];
            }
            return uniqueColors;
        },
        getBasicColors: function() {
            return [ "#000000", "#404040", "#808080", "#C0C0C0", "#FFFFFF", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#FF00FF", "#800000", "#008000", "#000080", "#808000", "#008080", "#800080" ];
        },
        getStyleColors: function(previousColors) {
            var colors = this.getBasicColors();
            var uniqueColors = colors;
            for (var i = 0; i < previousColors.length; i++) {
                var found = false;
                for (var j = 0; j < colors.length; j++) if (previousColors[i] == colors[j]) {
                    found = true;
                    break;
                }
                if (!found) uniqueColors[uniqueColors.length] = previousColors[i];
            }
            return uniqueColors;
        },
        setupSwatches: function(colors) {
            var me = this;
            jQuery("#styleColors").empty();
            var swatchStyle = {
                "float": "left",
                margin: "3px",
                width: "20px",
                height: "15px",
                cursor: "crosshair",
                border: "1px black solid"
            };
            for (var i = 0; i < colors.length; i++) {
                var div = document.createElement("div");
                swatchStyle["background-color"] = colors[i];
                jQuery(div).css(swatchStyle);
                jQuery(div).attr("title", colors[i]);
                jQuery(div).click(function(e) {
                    me.chooseStyleColor(jQuery(this).css("backgroundColor"));
                    e.preventDefault();
                });
                jQuery("#styleColors").append(div);
            }
        },
        chooseStyleColor: function(color) {
            color = new RGBColor(color).toHex().toUpperCase();
            if (!color) return;
            var currentInputName = this.currentColorInput.name;
            jQuery.farbtastic("#colorpicker" + currentInputName.substring(5)).setColor(color);
            document["styleForm"][currentInputName].focus();
        },
        adjustFont: function(adjustment) {
            var val = jQuery(document["styleForm"].styleSize).val();
            if (val.match(/%\s*$/gi)) {
                val = parseInt(val);
                val += adjustment;
                jQuery(document["styleForm"].styleSize).val(val + "%");
            }
            this.updatePreviewStyle();
        },
        uiSetup: function(popup) {
            var me = this;
            jQuery("#switchToAdvanced").click(function() {
                me.hideColorPickers();
                me.mergeBasicStyleToAdvanced();
                jQuery("#stylePopupContents .styleAdvanced").show();
                jQuery("#stylePopupContents .styleBasic").hide();
                jQuery("#switchToBasic").removeClass("selected");
                jQuery("#switchToAdvanced").addClass("selected");
                return false;
            });
            jQuery("#switchToBasic").click(function() {
                me.mergeAdvancedStyleToBasic();
                jQuery("#stylePopupContents .styleAdvanced").hide();
                jQuery("#stylePopupContents .styleBasic").show();
                jQuery("#switchToAdvanced").removeClass("selected");
                jQuery("#switchToBasic").addClass("selected");
                return false;
            });
            jQuery("#styleAdvancedTextarea").keyup(function() {
                me.updatePreviewStyle();
            });
            jQuery("#styleAdvancedTextarea").change(function() {
                me.updatePreviewStyle();
            });
            jQuery("#styleFont").focus(function() {
                me.hideColorPickers();
            });
            jQuery("#styleFont").change(function() {
                me.updatePreviewStyle();
            });
            jQuery("#sizeDown").click(function() {
                me.hideColorPickers();
                me.adjustFont(-10);
                return false;
            });
            jQuery("#styleSize").focus(function() {
                me.hideColorPickers();
            });
            jQuery("#styleSize").keyup(function() {
                me.updatePreviewStyle();
            });
            jQuery("#sizeUp").click(function() {
                me.hideColorPickers();
                me.adjustFont(10);
                return false;
            });
            jQuery("#styleColor").focus(function() {
                me.hideColorPickers();
                jQuery("#colorpickerColor").show();
                jQuery("#styleColors").show();
                me.currentColorInput = this;
            });
            jQuery("#styleColor").focus(function() {
                me.updatePreviewStyle();
            });
            jQuery("#styleBackgroundColor").focus(function() {
                me.hideColorPickers();
                jQuery("#colorpickerBackgroundColor").show();
                jQuery("#styleColors").show();
                me.currentColorInput = this;
            });
            jQuery("#styleBackgroundColor").focus(function() {
                me.updatePreviewStyle();
            });
            jQuery("#styleAlignment").focus(function() {
                me.hideColorPickers();
            });
            jQuery("#styleAlignment").change(function() {
                me.updatePreviewStyle();
            });
            jQuery("#styleVertical").focus(function() {
                me.hideColorPickers();
            });
            jQuery("#styleVertical").change(function() {
                me.updatePreviewStyle();
            });
            jQuery("#styleStrike").focus(function() {
                me.hideColorPickers();
            });
            jQuery("#styleStrike").click(function() {
                me.updatePreviewStyle();
            }).change(function() {
                me.updatePreviewStyle();
            });
            var closePopup = function() {
                tinymce.activeEditor.focus();
                popup.close();
                return false;
            };
            jQuery("#applyStyleButton").click(function() {
                if (jQuery("#stylePopupContents .styleBasic").is(":visible")) me.mergeBasicStyleToAdvanced();
                me.plugin.applyStyle();
                return closePopup();
            });
            jQuery("#removeStyleButton").click(function() {
                me.plugin.removeStyle();
                return closePopup();
            });
            jQuery("#styleCancel").click(closePopup);
            jQuery("#styleCloseButton").click(closePopup);
            jQuery("#colorpickerColor").farbtastic(function(color) {
                me.farbtasticCallback.call(this, color, document["styleForm"].styleColor);
                me.updatePreviewStyle();
            });
            jQuery("#colorpickerBackgroundColor").farbtastic(function(color) {
                me.farbtasticCallback.call(this, color, document["styleForm"].styleBackgroundColor);
                me.updatePreviewStyle();
            });
        },
        farbtasticCallback: function(color, element) {
            jQuery(element).css({
                backgroundColor: color,
                color: this.hsl[2] > .5 ? "#000" : "#fff"
            });
            jQuery(element).each(function() {
                this.value = color;
            });
        },
        hideColorPickers: function() {
            jQuery("#colorpickerColor").hide();
            jQuery("#colorpickerBackgroundColor").hide();
            jQuery("#styleColors").hide();
        }
    });
    tinymce.PluginManager.add("wsstylepopup", wikispaces.popups.Style);
})(tinymce, jQuery);

(function(tinymce) {
    tinymce.create("wikispaces.plugins.SubEditorPlugin", {
        init: function(ed, url) {
            this.editor = ed;
            ed.onInitSubEditor = new tinymce.util.Dispatcher(ed);
            this.plugins = ed.getParam("wssubeditor_plugins");
            this.options = ed.getParam("wssubeditor_options");
            var setup = this.options.setup;
            var subSetup = function(subEditor) {
                subEditor.onInit.add(function(editor) {
                    ed.onInitSubEditor.dispatch(editor);
                });
            };
            if (setup) this.options.setup = function(subeditor) {
                setup(subeditor);
                subSetup(subeditor);
            }; else this.options.setup = subSetup;
            var plugin = this;
            ed.addCommand("wssubeditor", function() {
                plugin.create();
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces sub editor",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        create: function(id, options, plugins, readyCallback) {
            this.options.plugins = plugins ? plugins : this.plugins;
            var editor = new tinymce.Editor(id, jQuery.extend({}, this.options, options));
            editor.render();
            if (readyCallback) if (editor.initialized) readyCallback(editor); else editor.onInit.add(readyCallback);
            return editor;
        }
    });
    tinymce.PluginManager.add("wssubeditor", wikispaces.plugins.SubEditorPlugin);
})(tinymce);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.TablePlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            this.emptyCellContents = tinymce.isIE ? "&nbsp;" : "<br/>";
            ed.addCommand("wsTable", function() {
                if (ed.dom.getParent(ed.selection.getNode(), "TABLE,UL,OL")) return;
                tinymce.mainEditor.plugins.wspopup.show("tablePopupContents", {
                    plugin: plugin
                });
                jQuery("#tablePopupContents input").first().focus();
            });
            ed.addButton("wstable", {
                title: "Insert Table",
                label: "Table",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsTable");
                    ws.common.track("Editor", "Open Table Tool");
                }
            });
            ed.onNodeChange.add(function(ed, cm, n) {
                n = ed.selection.getStart();
                if (n && !jQuery(n).parents().addBack().is(".mceContentBody")) return;
                var p = ed.dom.getParent(n, "td,th");
                var selectionInTable = "TABLE" === n.nodeName || !!p;
                if ("visual" == ed.plugins.wscommon.getOption("mode")) {
                    ed.theme.controlManager().setActive("wstable", selectionInTable);
                    ed.theme.controlManager().setDisabled("wstable", jQuery(n).parents().is("ol,ul"));
                } else {
                    ed.theme.controlManager().setActive("wstable", false);
                    ed.theme.controlManager().setDisabled("wstable", false);
                }
                if (!!p && !jQuery(n).is("img") && "visual" == ed.plugins.wscommon.getOption("mode")) tinymce.mainEditor.plugins.wstableoverlay.selectTableCell(p); else tinymce.mainEditor.plugins.wstableoverlay.unselectTableCell();
            });
            function isAtStart(rng, par) {
                var doc = par.ownerDocument, rng2 = doc.createRange(), elm, html;
                rng2.setStartBefore(par);
                rng2.setEnd(rng.endContainer, rng.endOffset);
                elm = doc.createElement("body");
                elm.appendChild(rng2.cloneContents());
                html = elm.innerHTML.replace(/<(br|img)[^>]*>/gi, "-");
                html = html.replace(/<table[^>]*>\s*(<tbody[^>]*>\s*)?(<tr[^>]*>\s*|(<tr[^>]*>\s*)?<t(d|h)[^>]*>)/g, "");
                html = html.replace(/<[^>]+>/g, "");
                return 0 == html.length;
            }
            ed.onInit.add(function(ed) {
                if (!tinymce.isIE) {
                    function fixTableCaretPos() {
                        var last;
                        for (last = ed.getBody().lastChild; last && 3 == last.nodeType && !last.nodeValue.length; last = last.previousSibling) ;
                        if (last && "TABLE" == last.nodeName) ed.dom.add(ed.getBody(), "p", null, '<br mce_bogus="1" />');
                    }
                    if (tinymce.isGecko) ed.onKeyDown.add(function(ed, e) {
                        var rng, table, dom = ed.dom;
                        if (37 == e.keyCode || 38 == e.keyCode) {
                            rng = ed.selection.getRng();
                            table = dom.getParent(rng.startContainer, "table");
                            if (table && ed.getBody().firstChild == table) if (isAtStart(rng, table)) {
                                rng = dom.createRng();
                                rng.setStartBefore(table);
                                rng.setEndBefore(table);
                                ed.selection.setRng(rng);
                                e.preventDefault();
                            }
                        }
                    });
                    ed.onKeyUp.add(fixTableCaretPos);
                    ed.onSetContent.add(fixTableCaretPos);
                    ed.onVisualAid.add(fixTableCaretPos);
                    ed.onPreProcess.add(function(ed, o) {
                        var last = o.node.lastChild;
                        if (last && 1 == last.childNodes.length && "BR" == last.firstChild.nodeName) ed.dom.remove(last);
                    });
                    fixTableCaretPos();
                }
            });
            ed.onKeyDown.addToTop(function(ed, e) {
                if (!tinymce.mainEditor.plugins.wstableoverlay.selectedTableCell || e.ctrlKey || e.altKey) return;
                if ("9" == e.keyCode) {
                    var currentCell = jQuery(tinymce.mainEditor.plugins.wstableoverlay.selectedTableCell);
                    var moveCell;
                    if (e.shiftKey) {
                        moveCell = currentCell.prev("td,th");
                        if (0 == moveCell.length && currentCell.parents("tr").eq(0).prev("tr").length > 0) moveCell = currentCell.parents("tr").eq(0).prev("tr").find("td,th").eq(currentCell.parents("tr").eq(0).prev("tr").find("td,th").length - 1);
                        if (!moveCell.length) {
                            tinymce.mainEditor.plugins.wstableoverlay.addNewRow(false, true);
                            moveCell = currentCell.parents("tr").eq(0).prev("tr").find("td,th").eq(currentCell.parents("tr").eq(0).prev("tr").find("td,th").length - 1);
                        }
                    } else {
                        moveCell = currentCell.next("td,th");
                        if (0 == moveCell.length && currentCell.parents("tr").eq(0).next("tr").length > 0) moveCell = currentCell.parents("tr").eq(0).next("tr").find("td,th").eq(0);
                        if (!moveCell.length) {
                            tinymce.mainEditor.plugins.wstableoverlay.addNewRow(false, false);
                            moveCell = currentCell.parents("tr").eq(0).next("tr").find("td,th").eq(0);
                        }
                    }
                    if (moveCell.length) {
                        moveCell = moveCell.get(0);
                        ed.selection.select(moveCell, true);
                        ed.selection.collapse(true);
                        tinymce.mainEditor.plugins.wstableoverlay.selectTableCell(moveCell);
                        tinymce.activeEditor.undoManager.add();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
                if (tinymce.isWebKit && (8 == e.keyCode || 46 == e.keyCode)) {
                    var li = jQuery(ed.selection.getNode()).closest("li:first-child");
                    if (li.size() > 0 && "" == li.text()) {
                        ed.undoManager.begin();
                        var list = li.parent();
                        li.remove();
                        if (0 == list.children().size()) list.remove();
                        span = jQuery("<span>", ed.getDoc()).prependTo(tinymce.mainEditor.plugins.wstableoverlay.selectedTableCell);
                        ed.plugins.wscommon.cursorToAndRemoveElement(span);
                        ed.undoManager.end();
                    }
                }
            });
            ed.plugins.wscommon.disableUntilLibsLoad(ed, "wstable");
        },
        getInfo: function() {
            return {
                longname: "Wikispaces table",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        addTable: function(tableRows, tableCols) {
            ws.common.track("Editor", "Add Table", tableRows + "x" + tableCols);
            if (isNaN(tableRows) || tableRows < 1) tableRows = 1;
            if (isNaN(tableCols) || tableCols < 1) tableCols = 1;
            var html = '<table class="wiki_table" id="__newTable__">\n';
            for (var rows = 0; rows < tableRows; rows++) {
                html += "<tr>\n";
                for (var cols = 0; cols < tableCols; cols++) html += "<td>" + this.emptyCellContents + "</td>\n";
                html += "</tr>\n";
            }
            html += "</table>\n";
            var editor = this.editor;
            editor.wsselection.setContent(html);
            var table = editor.dom.select("#__newTable__")[0];
            editor.dom.split(jQuery(table).closest("p,div,h1,h2,h3,h4,h5,h6")[0], table);
            table = editor.dom.select("#__newTable__")[0];
            editor.dom.setAttrib(table, "id", null);
            jQuery("td", editor.contentDocument).css({
                minWidth: 5,
                minHeight: 20
            });
            var cell = editor.dom.select("td", table)[0];
            editor.selection.select(cell.firstChild);
            editor.selection.collapse(true);
            editor.controlManager.setDisabled("table", true);
            editor.controlManager.setActive("table", true);
            tinymce.mainEditor.plugins.wstableoverlay.selectTableCell(cell);
            tinymce.mainEditor.controlManager.setActive("wstable", true);
        }
    });
    tinymce.PluginManager.add("wstable", wikispaces.plugins.TablePlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.TableOverlay", {
        selectedTableCell: null,
        init: function(ed, url) {
            var plugin = this;
            ed.onModeSwitch.add(function(mode) {
                if ("plain" == mode) plugin.hide();
            });
            jQuery(window).resize(function() {
                if (plugin.selectedTableCell && jQuery(plugin.selectedTableCell).is(":visible")) plugin.show(ed, plugin.selectedTableCell);
            });
            this.emptyCellContents = tinymce.isIE ? "&nbsp;" : "<br/>";
        },
        show: function(editor, cell) {
            this.editor = editor;
            this.selectedTableCell = cell;
            if (!this.menuHandleLoaded) {
                jQuery("#pageEditor").append(ws.editor.content.loadContent("tableMenu"));
                this.setupMenu();
                this.menuHandleLoaded = true;
            }
            jQuery("#tablePropertiesMenuHandle").css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px"
            }).addClass("overlayLayer").show();
            jQuery("#tableProperties").hide();
            this.reposition();
            this.updateMenu(cell);
        },
        showProperties: function() {
            jQuery("#tableProperties").css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px"
            }).addClass("overlayLayer").show();
            jQuery("#tablePropertiesMenuHandle").hide();
            this.reposition();
        },
        hide: function() {
            if (this.selectedTableCell) {
                this.removeHighlight();
                this.selectedTableCell = null;
            }
            jQuery("#tablePropertiesMenuHandle").hide();
            jQuery("#tableProperties").hide();
        },
        updateMenu: function(node) {
            node = jQuery(node);
            var propList = jQuery("#tablePropertiesList");
            var nodeIsTh = node.is("th");
            if (nodeIsTh) propList.find(".headerToggleLabel").text("Remove Header"); else propList.find(".headerToggleLabel").text("Make Header");
            propList.find(".alignmentMenu:not(.tableAlignmentMenu)").toggleClass("disabledMenu", nodeIsTh);
            propList.find(".mergeSplit").toggleClass("disabledMenu", !(node.attr("colspan") > 1));
            propList.find(".mergeLeft").toggleClass("disabledMenu", !node.prev("td,th").length);
            propList.find(".mergeRight").toggleClass("disabledMenu", !node.next("td,th").length);
        },
        tablePropertiesShow: function(e, clazz) {
            var promise = jQuery.when();
            if (e.is("ul:visible")) promise = e.slideUp("fast").promise();
            if (e.is("ul:not(:visible)")) promise = jQuery.when(promise, jQuery(clazz).slideUp("fast").promise(), e.slideDown("fast").promise());
            var me = this;
            promise.done(function() {
                me.reposition();
            });
        },
        reposition: function() {
            var location = null;
            var props = jQuery("#tableProperties:visible");
            if (props.length) {
                location = this.editor.plugins.wscommon.getPositionWith(props, this.selectedTableCell, 2);
                props.css(location);
            }
            var handle = jQuery("#tablePropertiesMenuHandle:visible");
            if (handle.length) {
                location = this.editor.plugins.wscommon.getPositionWith(handle, this.selectedTableCell, 2);
                handle.css(location);
            }
        },
        getScope: function(node) {
            node = jQuery(node);
            if (node.closest("#cellItem").length) return "Cell"; else if (node.closest("#rowItem").length) return "Row"; else if (node.closest("#colItem").length) return "Col"; else if (node.closest("#tableItem").length) return "Table";
            return null;
        },
        setupMenu: function() {
            var me = this;
            jQuery("#tablePropertiesMenuHandle").click(function(event) {
                event.stopPropagation();
                jQuery("#tablePropertiesList ul").hide();
                me.showProperties();
                return false;
            });
            jQuery("#tablePropertiesList ul").hide();
            jQuery("#tablePropertiesList .topmenu").click(function(event) {
                event.stopPropagation();
                me.tablePropertiesShow(jQuery(this).next(), "#tablePropertiesList li ul:visible");
                return false;
            });
            jQuery("#tablePropertiesList .submenu").click(function(event) {
                event.stopPropagation();
                me.tablePropertiesShow(jQuery(this).next(), "#tablePropertiesList li ul li ul:visible");
                return false;
            });
            jQuery("#cellItem, #rowItem, #colItem, #tableItem").mouseover(function() {
                var func = "highlight" + me.getScope(this);
                me[func]("highlightTableCell");
                return true;
            }).mouseout(function() {
                me.removeHighlight();
                return true;
            });
            jQuery("#tableProperties .mergeMenu li").mouseover(function() {
                var func;
                var dir;
                switch (jQuery(this).attr("class")) {
                  case "mergeLeft":
                    dir = true;
                    func = "highlight" + me.getScope(this) + "ForMerge";
                    break;

                  case "mergeRight":
                    dir = false;
                    func = "highlight" + me.getScope(this) + "ForMerge";
                    break;

                  case "mergeUp":
                    dir = true;
                    func = "highlight" + me.getScope(this) + "ForRowMerge";
                    break;

                  case "mergeDown":
                    dir = false;
                    func = "highlight" + me.getScope(this) + "ForRowMerge";
                }
                if (func) me[func](dir);
                return true;
            }).mouseout(function() {
                me.removeHighlight("highlightTableCellForMerge");
                return true;
            }).click(function() {
                var func;
                var dir;
                switch (jQuery(this).attr("class")) {
                  case "mergeLeft":
                    dir = true;
                    func = "merge" + me.getScope(this);
                    break;

                  case "mergeRight":
                    dir = false;
                    func = "merge" + me.getScope(this);
                    break;

                  case "mergeUp":
                    dir = true;
                    func = "mergeRow" + me.getScope(this);
                    break;

                  case "mergeDown":
                    dir = false;
                    func = "mergeRow" + me.getScope(this);
                    break;

                  case "mergeSplit":
                    dir = me.selectTableCell;
                    func = "splitCell";
                }
                me[func](dir);
                return false;
            });
            jQuery("#tableProperties .headerMenu").click(function() {
                var func = "convert" + me.getScope(this) + "Type";
                me[func]();
                return false;
            });
            jQuery("#tableProperties .addMenu li").mouseover(function() {
                var func;
                var dir;
                switch (jQuery(this).attr("class")) {
                  case "addPre":
                    ws.common.log("pre");
                    dir = true;
                    func = "addNew" + me.getScope(this);
                    break;

                  case "addPost":
                    ws.common.log("post");
                    dir = false;
                    func = "addNew" + me.getScope(this);
                }
                me[func](true, dir);
                return true;
            }).mouseout(function() {
                me.removePreviews();
                return true;
            }).click(function() {
                var func;
                var dir;
                switch (jQuery(this).attr("class")) {
                  case "addPre":
                    dir = true;
                    func = "addNew" + me.getScope(this);
                    break;

                  case "addPost":
                    dir = false;
                    func = "addNew" + me.getScope(this);
                }
                me[func](false, dir);
                return false;
            });
            jQuery("#tableProperties .alignmentMenu li").click(function() {
                var func = "align" + me.getScope(this);
                var dir = jQuery(this).attr("class");
                me[func](dir);
                return false;
            });
            jQuery("#tableProperties .removeMenu").mouseover(function() {
                var func = "highlight" + me.getScope(this) + "ForRemoval";
                me[func]();
                return true;
            }).mouseout(function() {
                me.removeHighlight("highlightTableCellForRemoval");
                return true;
            }).click(function() {
                var func = "remove" + me.getScope(this);
                me[func]();
                return false;
            });
        },
        $table: function() {
            return jQuery(this.selectedTableCell).closest("table.wiki_table");
        },
        selectTableCell: function(node) {
            ws.common.log("selectTableCell", node);
            this.show(tinymce.activeEditor, node);
        },
        unselectTableCell: function() {
            this.hide();
        },
        highlightCell: function(className) {
            if (this.selectedTableCell) jQuery(this.selectedTableCell).addClass(className);
        },
        highlightCellForMerge: function(before) {
            if (this.selectedTableCell) if (before) jQuery(this.selectedTableCell).prev("td,th").addClass("highlightTableCellForMerge"); else jQuery(this.selectedTableCell).next("td,th").addClass("highlightTableCellForMerge");
        },
        highlightCellForRowMerge: function(before) {
            if (this.selectedTableCell) {
                var myPosition = this.getColumnNumber(this.selectedTableCell);
                if (before) this.getColumnInPosition(jQuery(this.selectedTableCell).parent().prev("tr").children("td,th"), myPosition).addClass("highlightTableCellForMerge"); else this.getColumnInPosition(jQuery(this.selectedTableCell).parent().next("tr").children("td,th"), myPosition).addClass("highlightTableCellForMerge");
            }
        },
        convertCells: function(cells, newType) {
            var editorDocument = this.editor.getDoc();
            this.removeHighlight();
            this.editor.undoManager.begin();
            jQuery(cells).each(function(i) {
                var colspan = parseInt(jQuery(this).attr("colspan"));
                var newCell = editorDocument.createElement(newType);
                jQuery(newCell).attr("colspan", colspan);
                jQuery(newCell).html(jQuery(this).html());
                jQuery(this).replaceWith(newCell);
                if (this == this.selectedTableCell) this.selectTableCell(newCell);
            });
            this.editor.undoManager.end();
            this.unselectTableCell();
        },
        convertCellType: function() {
            var newType = jQuery(this.selectedTableCell).is("td") ? "th" : "td";
            this.convertCells(this.selectedTableCell, newType);
        },
        convertColType: function() {
            var cells = this.getColCells(this.getColumnNumber(this.selectedTableCell), false);
            var newType = jQuery(this.selectedTableCell).is("td") ? "th" : "td";
            this.convertCells(cells, newType);
        },
        convertRowType: function() {
            var cells = jQuery(this.selectedTableCell).parent("tr").find("td,th");
            var newType = jQuery(this.selectedTableCell).is("td") ? "th" : "td";
            this.convertCells(cells, newType);
        },
        mergeCell: function(before) {
            if (this.selectedTableCell) {
                var editorDocument = this.editor.getDoc();
                this.removeHighlight();
                this.removePreviews();
                this.editor.undoManager.begin();
                var retainedContent = this.selectedTableCell.innerHTML;
                var colspan = parseInt(jQuery(this.selectedTableCell).attr("colspan") > 1 ? jQuery(this.selectedTableCell).attr("colspan") : 1);
                if (before) jQuery(this.selectedTableCell).prev("td,th").remove(); else jQuery(this.selectedTableCell).next("td,th").remove();
                var type = "td";
                if (jQuery(this.selectedTableCell).is("th")) type = "th";
                var newCell = editorDocument.createElement(type);
                jQuery(newCell).html(jQuery(this.selectedTableCell).html());
                jQuery(newCell).attr("colspan", colspan + 1);
                jQuery(this.selectedTableCell).replaceWith(newCell);
                this.editor.undoManager.end();
                var row = jQuery(newCell).parent("tr").eq(0);
                var newRow = editorDocument.createElement("tr");
                jQuery(newRow).html(jQuery(row).html());
                jQuery(row).after(newRow);
                jQuery(row).remove();
                this.unselectTableCell();
            }
        },
        splitCell: function() {
            if (this.selectedTableCell && jQuery(this.selectedTableCell).attr("colspan") > 1) {
                var type = "td";
                if (jQuery(this.selectedTableCell).is("th")) type = "th";
                var html = "<" + type + ">" + jQuery(this.selectedTableCell).html() + "</" + type + ">";
                var colpad = parseInt(jQuery(this.selectedTableCell).attr("colspan")) - 1;
                for (var i = 0; i < colpad; i++) html += "<td>" + this.emptyCellContents + "</td>";
                this.removeHighlight();
                this.removePreviews();
                this.editor.undoManager.begin();
                jQuery(this.selectedTableCell).replaceWith(html);
                this.editor.undoManager.end();
                this.unselectTableCell();
            }
        },
        highlightTable: function(className) {
            if (this.selectedTableCell) this.$table().find("td,th").each(function(i) {
                jQuery(this).addClass(className);
            });
        },
        highlightSelectedTable: function() {
            this.highlightTable("highlightTableCell");
        },
        highlightTableForRemoval: function() {
            this.highlightTable("highlightTableCellForRemoval");
        },
        highlightSelectedRow: function() {
            this.highlightRow("highlightTableCell");
        },
        highlightRowForRemoval: function() {
            this.highlightRow("highlightTableCellForRemoval");
        },
        highlightRow: function(className) {
            if (this.selectedTableCell) jQuery(this.selectedTableCell).parent("tr").eq(0).find("td,th").each(function(i) {
                jQuery(this).addClass(className);
            });
        },
        getColumnNumber: function(tableCell) {
            var position = 0;
            var prevCells = jQuery(tableCell).prevAll("td,th");
            for (var i = 0; i < prevCells.length; i++) position += parseInt(jQuery(prevCells[i]).attr("colspan") > 1 ? jQuery(prevCells[i]).attr("colspan") : 1);
            return position;
        },
        getColumnInPosition: function(columns, position) {
            for (var i = 0; i < columns.length; i++) if (this.getColumnNumber(columns[i]) >= position) return columns[i];
        },
        highlightSelectedCol: function() {
            this.highlightCol("highlightTableCell");
        },
        highlightColForRemoval: function() {
            this.highlightCol("highlightTableCellForRemoval");
        },
        highlightCol: function(className) {
            if (this.selectedTableCell) {
                var cells = this.getColCells(this.getColumnNumber(this.selectedTableCell), false);
                jQuery(cells).each(function(i) {
                    jQuery(this).addClass(className);
                });
            }
        },
        removeHighlight: function(className) {
            if (className) this.$table().find("." + className).each(function(i) {
                jQuery(this).removeClass(className);
            }); else this.$table().find(".highlightTableCell,.highlightTableCellForRemoval,.highlightTableCellForMerge").each(function(i) {
                jQuery(this).removeClass("highlightTableCell").removeClass("highlightTableCellForRemoval").removeClass("highlightTableCellForMerge");
            });
        },
        addNewRow: function(preview, before) {
            if (this.selectedTableCell) {
                var cellCount = 0;
                var cells = jQuery(this.selectedTableCell).parent("tr").eq(0).find("td,th");
                for (var i = 0; i < cells.length; i++) cellCount += parseInt(jQuery(cells[i]).attr("colspan") > 1 ? jQuery(cells[i]).attr("colspan") : 1);
                if (preview) var rowHtml = '<tr class="tablePreview"><td colspan="' + cellCount + '">' + this.emptyCellContents + "</td></tr>"; else {
                    var rowHtml = "<tr>";
                    for (var i = 0; i < cellCount; i++) rowHtml += "<td>" + this.emptyCellContents + "</td>";
                    rowHtml += "</tr>";
                    this.removeHighlight();
                    this.removePreviews();
                    this.editor.undoManager.begin();
                }
                if (before) jQuery(this.selectedTableCell).parent("tr").eq(0).before(rowHtml); else jQuery(this.selectedTableCell).parent("tr").eq(0).after(rowHtml);
                if (!preview) {
                    this.editor.undoManager.end();
                    this.unselectTableCell();
                }
            }
        },
        addNewCol: function(preview, before) {
            if (this.selectedTableCell) {
                if (preview) {
                    var tdHtml = '<td class="tablePreview">&nbsp;&nbsp;&nbsp;&nbsp;</td>';
                    var thHtml = '<th class="tablePreview">&nbsp;&nbsp;&nbsp;&nbsp;</th>';
                } else {
                    var tdHtml = "<td>" + this.emptyCellContents + "</td>";
                    var thHtml = "<th>" + this.emptyCellContents + "</th>";
                    this.removeHighlight();
                    this.removePreviews();
                    this.editor.undoManager.begin();
                }
                var colNumber = this.getColumnNumber(this.selectedTableCell);
                if (!before) {
                    var colspan = parseInt(jQuery(this.selectedTableCell).attr("colspan") > 1 ? jQuery(this.selectedTableCell).attr("colspan") : 1);
                    colNumber = colNumber + colspan - 1;
                }
                var cells = this.getColCells(colNumber, true);
                var me = this;
                jQuery(cells).each(function(i) {
                    var html = me.isHeaderRow(i) ? thHtml : tdHtml;
                    if (before) jQuery(this).before(html); else jQuery(this).after(html);
                });
                if (!preview) {
                    this.editor.undoManager.end();
                    this.unselectTableCell();
                }
            }
        },
        removeTable: function() {
            if (this.selectedTableCell) {
                this.removeHighlight();
                this.editor.undoManager.begin();
                this.$table().remove();
                this.editor.undoManager.end();
                this.unselectTableCell();
            }
        },
        removeCol: function() {
            if (this.selectedTableCell) {
                var cells = this.getColCells(this.getColumnNumber(this.selectedTableCell), false);
                this.removeHighlight();
                this.editor.undoManager.begin();
                jQuery(cells).each(function(i) {
                    jQuery(this).remove();
                });
                this.editor.undoManager.end();
                this.unselectTableCell();
            }
        },
        removeRow: function() {
            if (this.selectedTableCell) {
                this.removeHighlight();
                this.editor.undoManager.begin();
                var row = jQuery(this.selectedTableCell).parent("tr").eq(0).remove();
                this.editor.undoManager.end();
                this.unselectTableCell();
            }
        },
        alignCell: function(alignment) {
            if (jQuery(this.selectedTableCell).is("td")) {
                this.removeHighlight();
                this.editor.undoManager.begin();
                jQuery(this.selectedTableCell).css("text-align", alignment);
                this.editor.undoManager.end();
                this.unselectTableCell();
            }
        },
        alignRow: function(alignment) {
            var cells = jQuery(this.selectedTableCell).parent("tr").eq(0).find("td,th");
            this.removeHighlight();
            this.editor.undoManager.begin();
            jQuery(cells).each(function(i) {
                if (jQuery(this).is("td")) jQuery(this).css("text-align", alignment);
            });
            this.editor.undoManager.end();
            this.unselectTableCell();
        },
        alignCol: function(alignment) {
            var cells = this.getColCells(this.getColumnNumber(this.selectedTableCell), false);
            this.removeHighlight();
            this.editor.undoManager.begin();
            jQuery(cells).each(function(i) {
                if (jQuery(this).is("td")) jQuery(this).css("text-align", alignment);
            });
            this.editor.undoManager.end();
            this.unselectTableCell();
        },
        alignTable: function(alignment) {
            var cells = this.$table().find("td,th");
            this.removeHighlight();
            this.editor.undoManager.begin();
            jQuery(cells).each(function(i) {
                if (jQuery(this).is("td")) jQuery(this).css("text-align", alignment);
            });
            this.editor.undoManager.end();
            this.unselectTableCell();
        },
        getColCells: function(position, visualColumnMode) {
            if (this.selectedTableCell) {
                var rows = this.$table().find("tr");
                var results = new Array();
                for (var i = 0; i < rows.length; i++) {
                    var thisPosition = 0;
                    var cells = jQuery(rows[i]).children();
                    var realCells = 0;
                    for (var j = 0; j < cells.length; j++) {
                        realCells += parseInt(jQuery(cells[j]).attr("colspan") > 1 ? jQuery(cells[j]).attr("colspan") : 1);
                        if (realCells > position) {
                            results[results.length] = cells[j];
                            break;
                        } else if (realCells > position && visualColumnMode) {
                            results[results.length] = cells[j - 1];
                            break;
                        }
                    }
                }
                return results;
            }
        },
        removePreviews: function() {
            this.$table().find(".tablePreview").each(function(i) {
                jQuery(this).remove();
            });
        },
        isHeaderRow: function(rowIdx) {
            return _(this.$table().find("tr").eq(rowIdx).children()).all(function(elem) {
                return jQuery(elem).is("th");
            });
        }
    });
    tinymce.PluginManager.add("wstableoverlay", wikispaces.plugins.TableOverlay);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.Table", {
        plugin: null,
        init: function(ed) {
            var me = this;
            ed.plugins.wspopup.register({
                wsname: "tablePopupContents",
                title: "Insert Table",
                width: 280,
                height: 100,
                wsselection: 0,
                onShow: function(o) {
                    me.onShow(o);
                },
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
        },
        setPlugin: function(plugin) {
            this.plugin = plugin;
        },
        onShow: function(o) {
            this.setPlugin(o.plugin);
        },
        uiSetup: function(popup) {
            var me = this;
            jQuery("#addTableButton").click(function() {
                me.plugin.addTable(document.insertTableForm.rows.value, document.insertTableForm.cols.value);
                popup.close();
            });
            jQuery("#tableCancelLink").click(function() {
                popup.close();
                return false;
            });
            jQuery("#tableCloseButton").click(function() {
                popup.close();
                return false;
            });
        }
    });
    tinymce.PluginManager.add("wstablepopup", wikispaces.popups.Table);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.ToolbarScrollPlugin", {
        init: function(ed, url) {
            var plugin = this;
            ed.onInit.add(function(ed) {
                jQuery(".mceExternalToolbar").before('<div id="mceToolbarAnchor">');
                jQuery(window).scroll(plugin.moveScroller);
                plugin.moveScroller();
            });
        },
        moveScroller: function() {
            var toolbar = jQuery(".mceExternalToolbar");
            var toolbarHeight = toolbar.height();
            var visibleTop = _(jQuery(".navbar-fixed-top")).reduce(function(memo, elem) {
                return memo + jQuery(elem).outerHeight();
            }, 0);
            if (jQuery(window).scrollTop() > jQuery("#mceToolbarAnchor").offset().top - toolbarHeight - visibleTop) toolbar.css({
                position: "fixed",
                top: visibleTop
            }); else toolbar.css({
                position: "absolute",
                top: "-" + (toolbarHeight + 4) + "px"
            });
            if (jQuery("#menu_wsMainEditor_wsMainEditor_wssave_menu").is(":visible")) {
                var refObject = jQuery("#wsMainEditor_wssave_action");
                jQuery("#menu_wsMainEditor_wsMainEditor_wssave_menu").css({
                    left: Math.min(refObject.offset().left, jQuery(window).scrollLeft() + jQuery(window).width() - jQuery("#menu_wsMainEditor_wsMainEditor_wssave_menu").width() - 3) + "px",
                    top: refObject.offset().top + refObject.outerHeight() + "px"
                });
            }
            if (jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu").is(":visible")) {
                var refObject = jQuery("#wsMainEditor_formatlistbox");
                jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu").css({
                    left: refObject.offset().left + "px",
                    top: refObject.offset().top + refObject.outerHeight() + "px"
                });
            }
        },
        getInfo: function() {
            return {
                longname: "Wikispaces toolbar scroll",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.PluginManager.add("wstoolbarscroll", wikispaces.plugins.ToolbarScrollPlugin);
})(tinymce, jQuery);

(function(tinymce) {
    var Dispatcher = tinymce.util.Dispatcher;
    tinymce.UndoManager = function(editor) {
        var self, onAdd, onUndo, onRedo;
        function getContent() {
            return tinymce.trim(editor.getContent({
                format: "raw",
                no_events: 1
            }).replace(/<span[^>]+data-mce-bogus[^>]+>[\u200B\uFEFF]+<\/span>/g, "")).replace(/(?:&nbsp;)+$/g, "");
        }
        self = {
            typing: false,
            onAdd: new Dispatcher(self),
            onUndo: new Dispatcher(self),
            onRedo: new Dispatcher(self),
            undoData: [],
            currentLevel: null,
            redoData: [],
            nestLevel: 0,
            getLevels: function() {
                var undo = [];
                var redo = [];
                jQuery.each(this.undoData, function() {
                    undo.push(this.content);
                });
                jQuery.each(this.redoData, function() {
                    redo.push(this.content);
                });
                return [ undo, this.currentLevel.content, redo ];
            },
            begin: function() {
                this.add();
                ++this.nestLevel;
            },
            end: function() {
                --this.nestLevel;
                this.add();
            },
            add: function(level) {
                return tinymce.mainEditor.plugins.wsundomain.add(editor, level);
            },
            remove: function() {
                return tinymce.mainEditor.plugins.wsundomain.remove(editor);
            },
            undo: function() {
                return tinymce.mainEditor.plugins.wsundomain.undo();
            },
            redo: function() {
                return tinymce.mainEditor.plugins.wsundomain.redo();
            },
            clear: function() {
                return tinymce.mainEditor.plugins.wsundomain.clear();
            },
            hasUndo: function() {
                return tinymce.mainEditor.plugins.wsundomain.hasUndo();
            },
            hasRedo: function() {
                return tinymce.mainEditor.plugins.wsundomain.hasRedo();
            },
            updateButtonState: function() {
                return tinymce.mainEditor.plugins.wsundomain.updateButtonState();
            },
            subAdd: function(level) {
                if (this.nestLevel > 0) return null;
                self.typing = false;
                var i, settings = editor.settings, lastLevel;
                level = level || {};
                level.content = getContent();
                if (self.currentLevel && self.currentLevel.content == level.content) return null;
                if (settings.custom_undo_redo_levels) if (self.redoData.length + self.undoData.length > settings.custom_undo_redo_levels + 1) self.dropOldestUndo();
                level.bookmark = editor.selection.getBookmark(2, true);
                self.clearRedo();
                self.undoData.push(self.currentLevel);
                self.currentLevel = level;
                self.onAdd.dispatch(self, level);
                editor.isNotDirty = 0;
                return level;
            },
            subRemove: function() {
                if (this.nestLevel > 0) return null;
                return self.undoData.pop();
            },
            beforeChange: function() {
                if (self.currentLevel) self.currentLevel.beforeBookmark = editor.selection.getBookmark(2, true);
            },
            clearRedo: function() {
                self.redoData = [];
            },
            dropOldestUndo: function() {
                return self.undoData.shift();
            },
            subUndo: function() {
                if (self.typing) self.add();
                if (!self.subHasUndo()) return null;
                self.redoData.push(self.currentLevel);
                self.currentLevel = self.undoData.pop();
                editor.setContent(self.currentLevel.content, {
                    format: "raw",
                    no_events: true
                });
                editor.selection.moveToBookmark(self.currentLevel.beforeBookmark);
                self.onUndo.dispatch(self, self.currentLevel);
                return self.currentLevel;
            },
            subRedo: function() {
                if (!self.subHasRedo()) return null;
                self.undoData.push(self.currentLevel);
                self.currentLevel = self.redoData.pop();
                editor.setContent(self.currentLevel.content, {
                    format: "raw",
                    no_events: true
                });
                editor.selection.moveToBookmark(self.currentLevel.bookmark);
                self.onRedo.dispatch(self, self.currentLevel);
                return self.currentLevel;
            },
            subClear: function() {
                self.undoData = [];
                self.currentLevel = {
                    content: getContent(),
                    bookmark: editor.selection.getBookmark(2, true)
                };
                self.redoData = [];
                self.typing = false;
            },
            subHasUndo: function() {
                return self.undoData.length > 0 || self.typing;
            },
            subHasRedo: function() {
                return self.redoData.length > 0;
            }
        };
        self.onAdd.add(function(undoman, level) {
            return editor.onChange.dispatch(editor, level, undoman);
        });
        self.onUndo.add(function(undoman, level) {
            editor.onUndo.dispatch(editor, level, undoman);
            return editor.onChange.dispatch(editor, level, undoman);
        });
        self.onRedo.add(function(undoman, level) {
            editor.onRedo.dispatch(editor, level, undoman);
            return editor.onChange.dispatch(editor, level, undoman);
        });
        editor.onBeforeExecCommand.add(function(ed, cmd, ui, val, args) {
            if ("Undo" != cmd && "Redo" != cmd && "mceRepaint" != cmd && (!args || !args.skip_undo)) self.beforeChange();
        });
        editor.onExecCommand.add(function(ed, cmd, ui, val, args) {
            if ("Undo" != cmd && "Redo" != cmd && "mceRepaint" != cmd && (!args || !args.skip_undo)) self.add();
        });
        editor.onSaveContent.add(function() {
            self.add();
        });
        editor.dom.bind(editor.dom.getRoot(), "dragend", function() {
            self.add();
        });
        editor.dom.bind(editor.getDoc(), tinymce.isGecko ? "blur" : "focusout", function(e) {
            if (!editor.removed && self.typing) self.add();
        });
        editor.onKeyUp.add(function(editor, e) {
            var keyCode = e.keyCode;
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || 45 == keyCode || 13 == keyCode || e.ctrlKey) self.add();
        });
        editor.onKeyDown.add(function(editor, e) {
            var keyCode = e.keyCode;
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || 45 == keyCode) {
                if (self.typing) self.add();
                return;
            }
            if ((keyCode < 16 || keyCode > 20) && 224 != keyCode && 91 != keyCode && !self.typing) {
                self.beforeChange();
                self.add();
                self.typing = true;
            }
        });
        editor.onMouseDown.add(function(editor, e) {
            if (self.typing) self.add();
        });
        editor.addShortcut("ctrl+z", "undo_desc", "Undo");
        editor.addShortcut("ctrl+y", "redo_desc", "Redo");
        return self;
    };
    tinymce.create("wikispaces.plugins.UndoPlugin", {
        init: function(ed) {
            ed.onNodeChange.add(function(editor) {
                editor.undoManager.updateButtonState();
            });
            ed.onDeactivate.add(function(editor) {
                if (editor.initialized && editor.undoManager.typing) editor.undoManager.add();
            });
            ed.onInit.add(function(editor) {
                editor.undoManager.subClear();
                tinymce.mainEditor.plugins.wsundomain.removeEditor(editor);
            });
            ed.onKeyDown.add(function(editor, e) {
                if (16 == e.keyCode || 17 == e.keyCode || 18 == e.keyCode) return;
                editor.undoManager.updateButtonState();
            });
        }
    });
    tinymce.PluginManager.add("wsundo", wikispaces.plugins.UndoPlugin);
})(tinymce);

(function(tinymce) {
    tinymce.create("wikispaces.plugins.UndoMainPlugin", {
        undoData: [],
        redoData: [],
        init: function(ed) {
            this.editor = ed;
        },
        add: function(editor, level) {
            level = editor.undoManager.subAdd(level);
            if (!level) return null;
            this.clearRedo();
            var settings = this.editor.settings;
            if (settings.custom_undo_redo_levels && this.undoData.length > settings.custom_undo_redo_levels) this.undoData.shift().undoManager.dropOldestUndo();
            this.undoData.push(editor);
            this.updateButtonState();
            return level;
        },
        remove: function(myEditor) {
            if (0 == this.undoData.length) return null;
            var editor = this.undoData.pop();
            if (editor != myEditor) {
                this.undoData.push(editor);
                return null;
            }
            var level = editor.undoManager.subRemove();
            if (!level) this.undoData.push(editor);
            return level;
        },
        undo: function() {
            if (tinymce.activeEditor.undoManager.typing) {
                this.add(tinymce.activeEditor);
                tinymce.activeEditor.undoManager.typing = 0;
            }
            if (this.undoData.length <= 0) return;
            var editor = this.undoData.pop();
            if (editor.destroyed) return this.undo();
            this.redoData.push(editor);
            editor.focus();
            var ret = editor.undoManager.subUndo();
            this.updateButtonState();
            return ret;
        },
        redo: function() {
            if (!this.hasRedo()) return;
            var editor = this.redoData.pop();
            this.undoData.push(editor);
            editor.focus();
            var ret = editor.undoManager.subRedo();
            this.updateButtonState();
            return ret;
        },
        clear: function() {
            this.undoData = [];
            this.redoData = [];
            jQuery.each(tinymce.editors, function() {
                if (this.initialized) this.undoManager.subClear();
            });
            this.updateButtonState();
        },
        clearRedo: function() {
            this.redoData = [];
            jQuery.each(tinymce.editors, function() {
                if (this.initialized) this.undoManager.clearRedo();
            });
            this.updateButtonState();
        },
        hasUndo: function() {
            return this.undoData.length > 0 || tinymce.activeEditor.initialized && tinymce.activeEditor.undoManager.typing;
        },
        hasRedo: function() {
            return this.redoData.length > 0;
        },
        updateButtonState: function() {
            var controlManager = this.editor.controlManager;
            controlManager.setDisabled("undo", !this.hasUndo());
            controlManager.setDisabled("redo", !this.hasRedo());
        },
        removeEditor: function(editor) {
            var offset;
            jQuery.each([ this.undoData, this.redoData ], function() {
                offset = 0;
                for (var i = 0; i < this.length; ++i) if (this[i] == editor) ++offset; else this[i - offset] = this[i];
                this.length -= offset;
            });
            this.updateButtonState();
        }
    });
    tinymce.PluginManager.add("wsundomain", wikispaces.plugins.UndoMainPlugin);
})(tinymce);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.WidgetPlugin", {
        init: function(ed, url) {
            var plugin = this;
            plugin.editor = ed;
            ed.addCommand("wsWidget", function() {
                plugin.openWidget();
            });
            ed.addButton("wswidget", {
                title: "Embed Widget",
                label: "Widget",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsWidget");
                }
            });
            ed.onNodeChange.add(function(ed, cm, n, co) {
                if ("visual" != ed.plugins.wscommon.getOption("mode")) {
                    ed.theme.controlManager().setActive("wswidget", false);
                    return;
                }
                ed.theme.controlManager().setDisabled("wswidget", ed.plugins.wscommon.isCommentEditor());
                var placeholder = plugin.findWidgetPlaceholder(n);
                ed.theme.controlManager().setActive("wswidget", !!placeholder);
                if (placeholder) tinymce.mainEditor.plugins.wswidgetoverlay.show(ed, placeholder); else tinymce.mainEditor.plugins.wswidgetoverlay.hide();
            });
            ed.onDblClick.add(function(ed, e) {
                var placeholder = null;
                if (placeholder = plugin.findWidgetPlaceholder(e.target)) plugin.openWidget(placeholder);
            });
            ed.onKeyPress.addToTop(function(ed, e) {
                if (13 == e.keyCode) {
                    var sel = ed.selection.getNode();
                    var nearestPre = jQuery(sel).closest("pre,code");
                    if (nearestPre.length) {
                        var needsDouble = false;
                        if (tinymce.isWebKit) {
                            if ("\n" != nearestPre.text().substr(-1)) needsDouble = true;
                            ed.selection.setContent('\n<span id="wsHold"></span>');
                        } else ed.selection.setContent('<br/><span id="wsHold">﻿</span>');
                        ed.plugins.wscommon.cursorToAndRemoveElement(jQuery("#wsHold", ed.getDoc()).get(0));
                        if (needsDouble && "\n" == nearestPre.text().substr(-1)) {
                            ed.selection.setContent('\n<span id="wsHold"></span>');
                            ed.plugins.wscommon.cursorToAndRemoveElement(jQuery("#wsHold", ed.getDoc()).get(0));
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                }
            });
            ed.plugins.wscommon.disableUntilLibsLoad(ed, "wswidget");
        },
        getInfo: function() {
            return {
                longname: "Wikispaces widgets",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        openWidget: function(placeholder) {
            if (!placeholder) placeholder = this.findWidgetPlaceholder(this.editor.selection.getNode());
            if (jQuery(placeholder).is(".WikiMediaToc, .WikiMediaTocFlat")) return;
            var mediaString = "";
            if (jQuery(placeholder).is(".WikiAnchor")) mediaString = "#" + jQuery(placeholder).attr("id").match(/@@([^@]+)$/)[1]; else mediaString = jQuery(placeholder).attr("id");
            this.selectedPlaceholder = placeholder;
            ws.common.track("Editor", "Open Media Tool");
            tinymce.mainEditor.plugins.wspopup.show("mediaTool", {
                plugin: this,
                mediaString: mediaString
            });
        },
        insertWidget: function(embed, mediaType) {
            ws.common.track("Editor", "Add Media", mediaType);
            if (this.selectedPlaceholder) {
                var updatedEmbed = jQuery(embed).attr({
                    style: jQuery(this.selectedPlaceholder).attr("style"),
                    align: jQuery(this.selectedPlaceholder).attr("align")
                });
                jQuery(this.selectedPlaceholder).replaceWith(updatedEmbed);
                tinymce.mainEditor.plugins.wswidgetoverlay.hide();
            } else this.editor.wsselection.setContent(embed);
        },
        findWidgetPlaceholder: function(elem) {
            if (jQuery(elem).is("img.WikiMedia") && !jQuery(elem).hasClass("WikiMediaFile") || jQuery(elem).hasClass("WikiAnchor")) return elem; else return null;
        },
        insertCharacter: function(html, text) {
            ws.common.track("Editor", "Add Character", html);
            tinymce.activeEditor.wsselection.setContent(html);
        },
        insertToc: function(flat) {
            ws.common.track("Editor", "Insert Toc", flat);
            if (flat) tinymce.activeEditor.wsselection.setContent('<img id="wikitext@@toc@@flat" class="NewWikiMedia WikiMedia WikiMediaTocFlat" title="Table of Contents" src="' + window.location.protocol + "//www." + wikispaces_domain + '/site/embedthumbnail/toc/flat?w=100&h=16"/>', "h1,h2,h3,h4,h5,h6"); else tinymce.activeEditor.wsselection.setContent('<img id="wikitext@@toc@@normal" class="NewWikiMedia WikiMedia WikiMediaToc" title="Table of Contents" src="' + window.location.protocol + "//www." + wikispaces_domain + '/site/embedthumbnail/toc/normal?w=225&h=100"/>', "h1,h2,h3,h4,h5,h6");
        },
        insertReference: function() {
            var refEditor = tinymce.mainEditor.plugins.wsreference.insertReferenceAtSelection();
            tinymce.mainEditor.focus();
            setTimeout(function() {
                jQuery.scrollTo(refEditor.getContentAreaContainer(), {
                    axis: "y",
                    duration: 500
                });
                refEditor.focus();
                refEditor.wsselection.selectAll();
            }, 100);
        },
        insertReferences: function() {
            ws.common.track("Editor", "Insert References");
            tinymce.mainEditor.wsselection.setContent("\n&lt;references/&gt;");
        },
        insertCode: function() {
            var editor = tinymce.activeEditor;
            var code = editor.dom.encode(document.codeMediaForm.code.value);
            code = code.replace(/\r\n|\n|\r/g, "<br/>");
            var format = editor.dom.encode(document.codeMediaForm.format.value);
            if (!format) format = "text";
            ws.common.track("Editor", "Add Code", format);
            editor.wsselection.setContent('<pre id="wsTempPre" class="' + format + '">' + code + "</pre><br/>");
            var pre = jQuery("#wsTempPre", editor.getDoc());
            var parentBlock = pre.closest("p,div,h1,h2,h3,h4,h5,h6");
            if (parentBlock.length) editor.dom.split(parentBlock.get(0), pre.get(0));
            pre = jQuery("#wsTempPre", editor.getDoc());
            if (pre.nextAll("p,div,h1,h2,h3,h4,h5,h6").length) {
                editor.selection.select(pre.nextAll("p,div,h1,h2,h3,h4,h5,h6").get(0), true);
                editor.selection.collapse(true);
            }
            pre.removeAttr("id");
            document.codeMediaForm.reset();
            editor.onNeedsResize.dispatch();
        },
        insertAnchor: function(anchorText) {
            var escapedAnchor = jQuery("<div>").text(anchorText).html();
            escapedAnchor = escapedAnchor.replace(/"/g, "&quot;");
            tinymce.activeEditor.wsselection.setContent('<img src="/i/anchor.gif" class="WikiAnchor"  alt="Anchor"  id="wikitext@@anchor@@' + escapedAnchor + '" title="Anchor: ' + escapedAnchor + '"/>');
            ws.common.track("Editor", "Add Anchor", anchorText);
            return true;
        }
    });
    tinymce.PluginManager.add("wswidget", wikispaces.plugins.WidgetPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.popups.Widget", {
        previousSection: "wikispaces",
        currentMenu: "wikispaces",
        currentSection: "wikispaces",
        editor: null,
        plugin: null,
        COMMAND_URL_PARAM: "wikispacesCommandUrl",
        customPlugins: [],
        init: function(ed) {
            var me = this;
            me.editor = ed;
            ed.plugins.wspopup.register({
                wsname: "mediaTool",
                title: "Widgets",
                width: 680,
                height: 420,
                wsselection: 0,
                onShow: function(o) {
                    me.onShow(o);
                },
                uiSetup: function(popup) {
                    me.uiSetup(popup);
                }
            });
            ed.plugins.wspopup.register({
                wsname: "mediaPreview",
                title: "Widget Preview",
                width: 340,
                height: 340,
                uiSetup: function(popup) {
                    jQuery("#closePreviewButton").click(function() {
                        popup.close();
                    });
                }
            });
            this.registerPlugin({
                options: {
                    id: "glogster",
                    name: "Glogster",
                    type: "media",
                    category: "poster",
                    logo: "/i/icon_16_glogster.png",
                    url: "http://edu.glogster.com/?page=wiki_spaces&wikiaction=login",
                    homepage_url: "http://edu.glogster.com",
                    terms_url: "http://edu.glogster.com/terms-of-use"
                }
            });
            this.registerPlugin({
                options: {
                    id: "dogobooks",
                    name: "Dogo Books",
                    type: "media",
                    category: "education",
                    logo: "/i/icon_16_dogobooks.png",
                    url: "http://wikispaces.dogobooks.com",
                    homepage_url: "http://www.dogobooks.com",
                    terms_url: "http://www.dogobooks.com/pages/terms-and-conditions-dogobooks"
                }
            });
            this.registerPlugin({
                options: {
                    id: "dogonews",
                    name: "Dogo News",
                    type: "media",
                    category: "education",
                    logo: "/i/icon_16_dogonews.png",
                    url: "http://wikispaces.dogonews.com",
                    homepage_url: "http://www.dogonews.com",
                    terms_url: "http://www.dogonews.com/pages/terms-and-conditions"
                }
            });
            this.registerPlugin({
                options: {
                    id: "geogebratube",
                    name: "GeoGebraTube",
                    type: "media",
                    category: "education",
                    logo: "http://www.geogebra.org/static/images/ggb-logo-16x16-transparent.png",
                    url: "http://www.geogebratube.org/widgetprovider/index/widgettype/wikispaces",
                    homepage_url: "http://www.geogebratube.org/",
                    terms_url: "http://www.geogebra.org/cms/en/tos"
                }
            });
            this.registerPlugin({
                options: {
                    id: "quizlet-search",
                    name: "Quizlet",
                    type: "media",
                    category: "education",
                    logo: "/i/quizlet16.png",
                    url: "https://quizlet.com/widget/show",
                    homepage_url: "http://quizlet.com/",
                    terms_url: "http://quizlet.com/tos"
                }
            });
        },
        setPlugin: function(plugin) {
            this.plugin = plugin;
        },
        onShow: function(o) {
            this.setPlugin(o.plugin);
            this.resetMediaForms();
            if (o.plugin) {
                if (o.plugin.editor.plugins.wsreference) jQuery("#referenceMediaMenuEntry").show(); else jQuery("#referenceMediaMenuEntry").hide();
                if (wikispaces_isMain && "www" == wikispaces_spaceName) jQuery("#includeTagCloudMediaMenuEntry, #includeEditorsMediaMenuEntry, #includeNavbarMediaMenuEntry, #includePageListMediaMenuEntry, #includeWikiListMediaMenuEntry").hide();
            }
            jQuery("#mediaDiv form").attr("action", ws.common.pathFor("page", "embedmedia", wikispaces_page) + "?mode=" + encodeURIComponent(this.editor.plugins.wscommon.getOption("mode")) + "&editorVersion=3");
            var match;
            if (o.mediaString && (match = o.mediaString.match(/^#(.+)/))) {
                jQuery("#anchorName").val(match[1]);
                jQuery("#anchorMediaMenuEntry").click();
            } else if (o.mediaString) this.loadMedia(o.mediaString); else this.setMediaMenu("wikispaces");
        },
        loadMedia: function(mediaString) {
            document.genericMediaForm.media.value = mediaString;
            document.genericMediaForm.submit();
        },
        addWidget: function(embed, mediaType) {
            this.plugin.insertWidget(embed, mediaType);
            jQuery("#mediaDiv .cancelMediaLink").eq(0).click();
        },
        setMediaError: function(error) {
            jQuery("#mediaError").show().text(error);
        },
        resetMediaForms: function() {
            jQuery("#mediaDiv .mediaForm").each(function() {
                this.reset();
            });
            jQuery("#mediaDiv .s2_autocompletePage").not("#includePageMediaMenu input").val(wikispaces_page).select2("data", {
                id: "page:" + wikispaces_page,
                text: wikispaces_page
            });
            jQuery(".s2_autocompleteLink").select2("data", {
                id: "",
                text: ""
            });
            if (wikispaces_isMain && "www" == wikispaces_spaceName) jQuery("#mediaDiv .s2_autocompletePage").not("#includePageMediaMenu input").attr("readonly", "readonly").select2("disable");
            jQuery("#mediaDiv .s2_autocompleteWiki").select2("data", {
                id: wikispaces_wikiName,
                text: wikispaces_wikiText
            });
            jQuery("#mediaError").hide().html("");
        },
        setMediaPreview: function(preview) {
            this.editor.plugins.wspopup.show("mediaPreview");
            jQuery("#mediaPreviewArea").html(preview);
        },
        startMediaSpinner: function() {
            this.previousSection = this.currentSection;
            this.setMediaMenu("spinner");
            jQuery("#mediaError").hide().html("");
        },
        stopMediaSpinner: function() {
            this.setMediaMenu(this.previousSection);
        },
        valuesChanged: function() {
            jQuery("input").change();
        },
        setMediaMenu: function(menu) {
            ws.common.log("setMediaMenu", menu);
            var isMenu = false;
            if (1 == jQuery("#" + menu + "MediaMenuEntry").parents("#mediaMenu").length) {
                jQuery("#" + this.currentMenu + "MediaMenuEntry").removeClass("selected");
                jQuery("#" + menu + "MediaMenuEntry").addClass("selected");
                this.currentMenu = menu;
                isMenu = true;
            }
            if ("showcustom" == menu) menu = "custom";
            if (!document.getElementById(menu + "MediaMenu")) menu = "wikispaces";
            jQuery("#" + this.currentSection + "MediaMenu").hide();
            var newMediaMenu = jQuery("#" + menu + "MediaMenu").show();
            this.currentSection = menu;
            var pluginIframe = newMediaMenu.find("iframe.pluginIframe");
            if (pluginIframe.length && pluginIframe.data("src") && "/s/blank.html" == pluginIframe.attr("src")) {
                pluginIframe.attr("src", pluginIframe.data("src"));
                pluginIframe.data("src", "");
            }
            if (isMenu && "custom" != menu || "wikispaces" == menu || "spinner" == menu || "flickr" == menu || "gabbly" == menu || "yackpack" == menu || "bittybrowser" == menu || "toc" == menu || "reference" == menu || "facebooklike" == menu || "googleplusone" == menu || "digg" == menu || "reddit" == menu || "anchor" == menu || "include" == menu.substring(0, 7) || jQuery("#" + menu + "MediaMenu").is(".hideTextMediaInstructions")) jQuery(document.otherMediaForm).hide(); else jQuery(document.otherMediaForm).show();
            if ("spinner" != menu) document.otherMediaForm.mediaType.value = menu;
            jQuery("#" + menu + "MediaMenu").find('input[type="text"],textarea').eq(0).focus();
            this.editor.plugins.wspopup.resize("mediaTool");
        },
        submitYackpack: function() {
            var channel = document.yackpackMediaForm.channel.value;
            var url = "http://www.yackpack.com/walkietalkie/?" + encodeURIComponent(channel);
            document.otherMediaForm.embedText.value = url;
            document.otherMediaForm.save.click();
        },
        submitBittyBrowser: function() {
            var url = document.bittybrowserMediaForm.url.value;
            document.otherMediaForm.embedText.value = "bitty browser" + "\n" + 'website: "' + url + '"';
            document.otherMediaForm.save.click();
        },
        embedGabbly: function() {
            var url = location.protocol + "//" + location.host + "/" + wikispaces_page;
            document.otherMediaForm.embedText.value = "<iframe src='http://cw.gabbly.com/gabbly/cw.jsp?e=1&t=" + encodeURIComponent(url) + "' scrolling='no' style='width:300px; height:250px;' frameborder='0'></iframe>";
            document.otherMediaForm.save.click();
        },
        embedFacebookLike: function() {
            var url = location.protocol + "//" + location.host + "/" + wikispaces_page;
            document.otherMediaForm.embedText.value = '<iframe src="//www.facebook.com/plugins/like.php?href=' + encodeURIComponent(url) + '&amp;send=false&amp;layout=standard&amp;width=450&amp;show_faces=true&amp;action=like&amp;colorscheme=light&amp;font&amp;height=80&amp;appId=XXX" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:450px; height:80px;" allowTransparency="true"></iframe>';
            document.otherMediaForm.save.click();
        },
        embedGooglePlusOne: function() {
            document.otherMediaForm.embedText.value = '<g:plusone annotation="inline"></g:plusone>';
            document.otherMediaForm.save.click();
        },
        embedDigg: function() {
            var url = location.protocol + "//" + location.host + "/" + wikispaces_page;
            document.otherMediaForm.embedText.value = '<a class="DiggThisButton DiggMedium" src="http://digg.com/submit?url=' + encodeURIComponent(url) + '"></a>';
            document.otherMediaForm.save.click();
        },
        embedReddit: function() {
            document.otherMediaForm.embedText.value = '<script type="text/javascript" src="http://www.reddit.com/static/button/button1.js"></script>';
            document.otherMediaForm.save.click();
        },
        uiSetup: function(popup) {
            var me = this;
            var closePopup = function() {
                var editor = tinymce.activeEditor;
                popup.close();
                return false;
            };
            jQuery("#widgetCloseButton").click(closePopup);
            jQuery("#mediaDiv").on("click", "ul li", function() {
                var id = this.id;
                var menu = id.substring(0, id.indexOf("MediaMenuEntry"));
                if ("spinner" != me.currentMenu) {
                    me.setMediaMenu(menu);
                    popup.resize();
                }
                return false;
            });
            jQuery("#tocMediaForm #tocSubmitButton").click(function() {
                me.plugin.insertToc();
                return closePopup();
            });
            jQuery("#tocMediaForm #flatSubmitButton").click(function() {
                me.plugin.insertToc(true);
                return closePopup();
            });
            jQuery("#referenceMediaForm").submit(function(e) {
                me.plugin.insertReference();
                e.preventDefault();
                e.stopPropagation();
                return closePopup();
            });
            jQuery("#referencesMediaForm").submit(function(e) {
                me.plugin.insertReferences();
                e.preventDefault();
                e.stopPropagation();
                return closePopup();
            });
            jQuery("#anchorMediaForm").submit(function(e) {
                var name = jQuery("#anchorName").val();
                if (name.match(/^[^\]\|]+$/)) {
                    me.plugin.insertAnchor(name);
                    e.preventDefault();
                    e.stopPropagation();
                    return closePopup();
                } else {
                    if (!name) alert("Please enter a name for the anchor."); else alert('Anchors may not contain the characters "|" or "]".');
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            });
            jQuery("#mediaDiv .mediaForm").submit(function() {
                me.startMediaSpinner();
            });
            jQuery("#bittybrowserMediaForm").submit(function() {
                me.submitBittyBrowser();
            });
            jQuery("#gabblyMediaForm").submit(function(e) {
                me.embedGabbly();
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            jQuery("#yackpackMediaForm").submit(function(e) {
                me.submitYackpack();
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            jQuery("#codeMediaForm").submit(function(e) {
                if (jQuery(tinymce.activeEditor.selection.getNode()).closest("pre").length) {
                    alert("You cannot insert a code block inside another code block");
                    me.stopMediaSpinner();
                } else {
                    me.plugin.insertCode(document.codeMediaForm.code.value, document.codeMediaForm.format.value);
                    closePopup();
                }
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            jQuery("#facebooklikeMediaForm").submit(function(e) {
                me.embedFacebookLike();
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            jQuery("#googleplusoneMediaForm").submit(function(e) {
                me.embedGooglePlusOne();
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            jQuery("#diggMediaForm").submit(function(e) {
                me.embedDigg();
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            jQuery("#redditMediaForm").submit(function(e) {
                me.embedReddit();
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            jQuery("#includeCharMediaMenu td").hover(function() {
                if (!jQuery(this).hasClass("empty")) jQuery(this).addClass("hl");
            }, function() {
                if (!jQuery(this).hasClass("empty")) jQuery(this).removeClass("hl");
            });
            jQuery("#includeCharMediaMenu td").click(function() {
                if (!jQuery(this).hasClass("empty")) {
                    me.plugin.insertCharacter(jQuery(this).html(), jQuery(this).text());
                    closePopup();
                }
            });
            jQuery("#mediaDiv .cancelMediaLink").click(closePopup);
            ws.select2.tagEdit(jQuery("#mediaDiv #includePageListMediaMenu .tagFilter"), {
                minimumInputLength: 0,
                maximumSelectionSize: 5,
                placeholder: "Filter by tag"
            });
            jQuery("#rssDescInput").change(function() {
                if (this.checked) {
                    jQuery("#rssDescRow input").prop("disabled", false);
                    jQuery("#rssDescRow th").removeClass("disabled");
                } else {
                    jQuery("#rssDescRow input").prop("disabled", true);
                    jQuery("#rssDescRow th").addClass("disabled");
                }
            });
            ws.select2.wikiAndObject(jQuery(".s2_autocompleteWiki"), jQuery(".s2_autocompleteLink"), "P");
            ws.select2.object(jQuery(".s2_autocompletePage"));
            jQuery.each(this.customPlugins, function() {
                var plugin = this;
                if ("media" == plugin.options.type) {
                    var a = jQuery("<a>").attr("href", "#widget-" + plugin.options.id).text(plugin.options.name).css("background-image", "url(" + plugin.options.logo + ")");
                    var li = jQuery("<li>").attr("id", plugin.options.id + "MediaMenuEntry").append(a);
                    jQuery("#" + plugin.options.category + "MediaMenu ul li:last").before(li);
                    var commandUrl = document.location.protocol + "//" + document.location.host + ws.common.pathFor("site", "editorplugin", plugin.options.id);
                    var url = ws.common.addUriParams(plugin.options.url, [ [ me.COMMAND_URL_PARAM, commandUrl ] ]);
                    var div = jQuery("<div>").attr("id", plugin.options.id + "MediaMenu").addClass("hideTextMediaInstructions").addClass("mediaInstructions").hide().html("<div>" + '<iframe class="pluginIframe" frameborder="0" ' + 'src="/s/blank.html"' + 'data-src="' + url + '" ' + 'id="' + plugin.options.id + '-pluginIframe" ' + 'name="' + plugin.options.id + '-pluginIframe"></iframe>' + '<p class="mediaInstructionsTerms">' + "The content above is provided by " + '<a href="' + plugin.options.homepage_url + '" target="_blank">' + plugin.options.homepage_url + "</a> and is governed by their " + '<a href="' + plugin.options.terms_url + '" target="_blank">terms of service</a>.' + "</p></div>");
                    jQuery("#mediaDiv").find(".mediaInstructions:last").after(div);
                }
            });
        },
        runCustomPluginCommand: function(command, id, values) {
            switch (command) {
              case "cancel":
                jQuery("#mediaDiv .cancelMediaLink").click();
                break;

              case "preview":
                this.setMediaPreview(values.content);
                break;

              case "submit":
                document.otherMediaForm.embedText.value = values.content;
                document.otherMediaForm.mediaType.value = id;
                document.otherMediaForm.save.click();
                break;

              default:
                alert("The " + id + " plugin requested an invalid operation.");
            }
        },
        registerPlugin: function(customPlugin) {
            this.customPlugins[this.customPlugins.length] = customPlugin;
        }
    });
    tinymce.PluginManager.add("wswidgetpopup", wikispaces.popups.Widget);
})(tinymce, jQuery);

(function(tinymce) {
    var DOM = tinymce.DOM;
    tinymce.create("wikispaces.themes.WikispacesTheme", {
        init: function(ed, url) {
            var t = this;
            t.editor = ed;
            var states = [ "Bold", "Italic", "Underline", "InsertUnorderedList", "InsertOrderedList" ];
            var s = ed.settings;
            ed.onInit.add(function() {
                for (var i = 49; i <= 57; i++) delete ed.shortcuts["ctrl,,," + i];
                ed.plugins.wscommon.resizeToolbar();
                jQuery(window).resize(function() {
                    ed.plugins.wscommon.resizeToolbar();
                });
                _.delay(function() {
                    jQuery(window).scrollLeft(0);
                }, 1e3);
                ed.onNodeChange.add(function(ed, cm, n, co) {
                    if ("visual" == ed.plugins.wscommon.getOption("mode")) {
                        tinymce.each(states, function(c) {
                            t.controlManager().get(c.toLowerCase()).setDisabled(ed.wsselection && ed.wsselection.withinCode());
                            t.controlManager().get(c.toLowerCase()).setActive(ed.queryCommandState(c));
                        });
                        var hp = t.getHeaderParent(n);
                        t.controlManager().get("formatlistbox").select(hp ? hp.nodeName.toLowerCase() : "p");
                    }
                    if (t.controlManager().get("insertunorderedlist").isActive() && t.controlManager().get("insertorderedlist").isActive()) {
                        var closest = jQuery(n).closest("ul,ol");
                        if (closest.is("ul")) t.controlManager().get("insertorderedlist").setActive(false); else t.controlManager().get("insertunorderedlist").setActive(false);
                    }
                });
                if ("plain" == ed.plugins.wscommon.getOption("mode") && ed.plugins.wstext) {
                    ed.plugins.wstext.flipToText(jQuery("#wsMainEditor").val());
                    ws.common.track("Editor", "Start", "Text");
                } else ws.common.track("Editor", "Start", "Visual");
                if ("wsMainEditor" == ed.id) jQuery("#wsMainEditor_container .mceIframeContainer").click(function(e) {
                    var selSpan = jQuery("<span>", ed.getDoc()).appendTo(tinymce.mainEditor.getBody());
                    tinymce.mainEditor.plugins.wscommon.cursorToAndRemoveElement(selSpan);
                    jQuery(".WikiOverlay").hide();
                });
                if (tinymce.isIE) ed.dom.bind(ed.getDoc(), "controlselect", function(e) {
                    if (!jQuery(e.srcElement).is("img,pre")) return;
                    ed.onClick.dispatch(ed, e);
                });
            });
            var selectionOnKeyDown = false;
            ed.onKeyDown.add(function(ed, e) {
                if (e.ctrlKey || e.altKey) return;
                if ("9" == e.keyCode) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (8 == e.keyCode || 46 == e.keyCode) selectionOnKeyDown = !ed.selection.isCollapsed();
            });
            ed.onKeyUp.add(function(ed, e) {
                if ((8 == e.keyCode || 46 == e.keyCode) && selectionOnKeyDown) ed.undoManager.add();
            });
            if (tinymce.isWebKit) ed.onKeyUp.add(function(ed, e) {
                if ((8 == e.keyCode || 46 == e.keyCode) && selectionOnKeyDown && "" == jQuery.trim(jQuery(ed.getBody()).text()) && ed.dom.isBlock(jQuery(ed.getBody()).children().get(0))) {
                    ed.undoManager.begin();
                    jQuery(ed.getDoc().body).children().remove();
                    var span = jQuery("<span>", ed.getDoc()).appendTo(ed.getDoc().body).after("<br/>");
                    ed.plugins.wscommon.cursorToAndRemoveElement(span);
                    ed.undoManager.end();
                    ed.undoManager.remove();
                }
            });
            ed.onActivate.add(function(ed, oed) {
                t.controlManager().editor = ed;
                jQuery(ed.getContentAreaContainer()).addClass("active_editor");
            });
            ed.onDeactivate.add(function(ed) {
                if (!ed.initialized) return;
                if (jQuery(ed.getContainer()).is(":visible")) ed.selection.collapse();
                jQuery(ed.getContentAreaContainer()).removeClass("active_editor");
            });
            ed.onModeSwitch = new tinymce.util.Dispatcher(ed);
            ed.onModeSwitch.add(function(mode) {
                tinymce.each(states, function(c) {
                    t.controlManager().get(c.toLowerCase()).setActive(false);
                });
                if ("plain" == mode) jQuery("#switchEditorModes span.mceText").text("Visual Editor").attr("title", "Visual Editor"); else jQuery("#switchEditorModes span.mceText").text("WikiText Editor").attr("title", "WikiText Editor");
                t.showToolSet();
            });
            ed.setClean = function() {
                this.startContent = tinymce.trim(this.getContent({
                    format: "raw",
                    no_events: 1
                }));
            };
            ed.addCommand("wsInsertHorizontalRule", function() {
                if (tinymce.isWebKit) ed.execCommand("InsertHtml", false, "<hr>"); else ed.execCommand("InsertHorizontalRule");
            });
            ed.wsExecCommand = function(cmd, ui, val, a) {
                switch (cmd) {
                  case "Bold":
                  case "Italic":
                  case "Underline":
                  case "wsFormatBlock":
                  case "wsInsertHorizontalRule":
                  case "wsInsertOrderedList":
                  case "wsInsertUnorderedList":
                  case "wslink":
                  case "wsimage":
                  case "wsTable":
                  case "wsWidget":
                  case "wsStyle":
                  case "preview":
                  case "endPreview":
                    if ("plain" == ed.plugins.wscommon.getOption("mode")) {
                        this.execCommand(cmd + "Text", ui, val, a);
                        break;
                    }

                  default:
                    this.execCommand(cmd, ui, val, a);
                }
            };
        },
        controlManager: function() {
            return tinymce.mainEditor.controlManager;
        },
        getHeaderParent: function(node) {
            var parents = this.editor.dom.getParents(node);
            for (i = 0; i < parents.length; i++) if (parents[i].nodeName.toLowerCase().match(/h\d/)) return parents[i];
        },
        showToolSet: function(name) {
            var tools = jQuery("#wsMainEditor_tools1 td > *:first-child");
            switch (name) {
              case "preview":
                tools.css("visibility", "hidden");
                jQuery("#wsMainEditor_wssave_action").css("visibility", "visible");
                jQuery("#wsMainEditor_wssave_open").css("visibility", "visible");
                jQuery("#wsMainEditor_wsendpreview").css("visibility", "visible");
                jQuery("#wsMainEditor_wsendpreview").css(jQuery.browser.msie && jQuery.browser.version >= 8 ? {
                    left: -100,
                    top: 5
                } : {
                    right: 170,
                    top: 28
                });
                if (jQuery.browser.webkit) jQuery("#wsMainEditor_wsendpreview").parent().css("position", "");
                break;

              default:
                tools.css("visibility", "visible");
                jQuery("#wsMainEditor_wsendpreview").css("visibility", "hidden");
                if ("plain" == this.editor.plugins.wscommon.getOption("mode")) {
                    jQuery("#wsMainEditor_wscomment").css("visibility", "hidden");
                    jQuery("#wsMainEditor_undo").css("visibility", "hidden");
                    jQuery("#wsMainEditor_redo").css("visibility", "hidden");
                }
            }
        },
        renderUI: function(o) {
            var t = this;
            var ed = t.editor;
            var cf = ed.controlManager;
            var editorContainer = DOM.insertAfter(DOM.create("div", {
                id: ed.id + "_container",
                "class": "mceEditor " + ed.settings.skin + "Skin"
            }), o.targetNode);
            var toolbarContainer = DOM.add(editorContainer, "div", {
                id: ed.id + "_external",
                "class": "mceExternalToolbar toolbarLayer"
            });
            var blocker = DOM.create("div", {
                id: ed.id + "_overlay",
                "class": "wsPopupModalBlocker blockerLayer",
                style: "display: block !important; "
            });
            jQuery(".commentContainer").before(blocker);
            t.toolbar = cf.createToolbar("tools1");
            t.toolbar.add(cf.createButton("bold", {
                title: "Bold",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("Bold");
                    ws.common.track("Editor", "Bold");
                }
            }));
            t.toolbar.add(cf.createButton("italic", {
                title: "Italic",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("Italic");
                    ws.common.track("Editor", "Italic");
                }
            }));
            t.toolbar.add(cf.createButton("underline", {
                title: "Underline",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("Underline");
                    ws.common.track("Editor", "Underline");
                }
            }));
            t.toolbar.add(cf.createControl("wsstyle"));
            t.toolbar.add(cf.createSeparator());
            var flb = cf.createListBox("formatlistbox", {
                title: "Format",
                onselect: function(v) {
                    tinymce.activeEditor.wsExecCommand("wsFormatBlock", false, v);
                    ws.common.track("Editor", "Select Font", v);
                    jQuery("#wsMainEditor_formatlistbox").removeClass("mceListBoxSelected");
                }
            });
            flb.onRenderMenu.add(function(c, m) {
                m.onShowMenu.add(function() {
                    tinymce.activeEditor.wsselection.save(2);
                    if (!m.alreadyRendered) {
                        m.alreadyRendered = true;
                        function getStyles(elm) {
                            if (document.defaultView && document.defaultView.getComputedStyle) return document.defaultView.getComputedStyle(elm, ""); else if (elm.currentStyle) return elm.currentStyle;
                        }
                        function setStyles(baseStyles, styles, elm) {
                            if (document.defaultView && document.defaultView.getComputedStyle) for (var i = 0; i < styles.length; i++) {
                                var rule = styles[i];
                                var val = styles.getPropertyValue(rule);
                                var baseVal = baseStyles.getPropertyValue(rule);
                                if (val && val != baseVal) jQuery(elm).css(rule, val);
                            } else for (var rule in styles) {
                                rule = rule.replace(/\-(\w)/g, function(strMatch, p1) {
                                    return p1.toUpperCase();
                                });
                                var val = styles[rule];
                                var baseVal = baseStyles[rule];
                                if (val && val != baseVal) jQuery(elm).css(rule, val);
                            }
                        }
                        jQuery(document.body).append('<div class="wiki" style="display: none;" id="styleHolder"><h1>h1</h1><h2>h2</h2><h3>h3</h3><h4>h4</h4><h5>h5</h5><h6>h6</h6><span>span</span></div>');
                        jQuery("#styleHolder").children().each(function() {
                            var elm;
                            if ("span" == this.nodeName.toLowerCase()) elm = jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu .toolbar_formatmenu_normal .mceText"); else elm = jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu .toolbar_formatmenu_" + this.nodeName.toLowerCase() + " .mceText");
                            var baseStyles = getStyles(jQuery("#styleHolder").get(0));
                            var styles = getStyles(this);
                            setStyles(baseStyles, styles, elm.get(0));
                            elm.css("white-space", "nowrap");
                        });
                    }
                });
                m.onHideMenu.add(function() {
                    tinymce.activeEditor.wsselection.restore();
                    setTimeout(function() {
                        tinymce.activeEditor.focus();
                    }, 100);
                });
                m.settings.max_height = 185;
            });
            flb.add("1. Heading", "h1", {
                "class": "toolbar_formatmenu_h1"
            });
            flb.add("2. Heading", "h2", {
                "class": "toolbar_formatmenu_h2"
            });
            flb.add("3. Heading", "h3", {
                "class": "toolbar_formatmenu_h3"
            });
            flb.add("4. Heading", "h4", {
                "class": "toolbar_formatmenu_h4"
            });
            flb.add("5. Heading", "h5", {
                "class": "toolbar_formatmenu_h5"
            });
            flb.add("6. Heading", "h6", {
                "class": "toolbar_formatmenu_h6"
            });
            flb.add("Normal", "p", {
                "class": "toolbar_formatmenu_normal"
            });
            t.toolbar.add(flb);
            flb.originalShow = flb.showMenu;
            flb.showMenu = function() {
                var scrollTop = jQuery(window).scrollTop();
                flb.originalShow();
                jQuery(window).scrollTop(scrollTop);
                jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu tr.mceFirst td").css("height", 0);
                jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu tr.mceFirst td a").html("").css({
                    position: "relative",
                    height: 0,
                    padding: 0
                });
                jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu_co").css("height", "auto").css("width", "auto");
                jQuery("#menu_wsMainEditor_wsMainEditor_formatlistbox_menu").css({
                    borderBottom: "1px solid #d4d0c9",
                    borderRight: "1px solid #d4d0c9"
                }).appendTo(document.body);
                ed.plugins.wstoolbarscroll.moveScroller();
                var item = tinymce.DOM.select("a", "menu_" + flb.menu.id)[1];
                if (jQuery(item).is(":visible")) item.focus();
                flb.menu._focusIdx = 1;
            };
            t.toolbar.add(cf.createSeparator());
            t.toolbar.add(cf.createButton("insertorderedlist", {
                title: "Numbered List",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsInsertOrderedList");
                    ws.common.track("Editor", "Add Ordered List");
                }
            }));
            t.toolbar.add(cf.createButton("insertunorderedlist", {
                title: "Bulleted List",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsInsertUnorderedList");
                    ws.common.track("Editor", "Add Unordered List");
                }
            }));
            t.toolbar.add(cf.createButton("hr", {
                title: "Insert Horizontal Rule",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("wsInsertHorizontalRule");
                    ws.common.track("Editor", "Add Horizontal Rule");
                }
            }));
            t.toolbar.add(cf.createSeparator());
            t.toolbar.add(cf.createControl("wslink"));
            t.toolbar.add(cf.createControl("wsimage"));
            t.toolbar.add(cf.createControl("wswidget"));
            t.toolbar.add(cf.createControl("wstable"));
            t.toolbar.add(cf.createControl("wscomment"));
            t.toolbar.add(cf.createSeparator());
            t.toolbar.add(cf.createButton("undo", {
                title: "Undo",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("Undo");
                    ws.common.track("Editor", "Undo");
                }
            }));
            t.toolbar.add(cf.createButton("redo", {
                title: "Redo",
                onclick: function() {
                    tinymce.activeEditor.wsExecCommand("Redo");
                    ws.common.track("Editor", "Redo");
                }
            }));
            t.toolbar.add(cf.createSeparator());
            t.toolbar.add(cf.createButton("wspreview", {
                title: "Preview",
                label: "Preview",
                "class": "mceButtonNotReallyLabeled mceButtonGroup mceButtonGroupLeft",
                onclick: function() {
                    tinymce.mainEditor.wsExecCommand("preview", false, false, {
                        skip_undo: true
                    });
                    ws.common.track("Editor", "Preview");
                }
            }));
            t.toolbar.add(cf.createButton("wsendpreview", {
                title: "Continue Editing",
                label: "Continue Editing",
                "class": "continueBtn mceButtonNotReallyLabeled",
                "class": "continueBtn",
                onclick: function() {
                    tinymce.mainEditor.wsExecCommand("endPreview", false, false, {
                        skip_undo: true
                    });
                }
            }));
            t.toolbar.add(cf.createControl("wscancel"));
            var saveControl = cf.createControl("wssave");
            t.toolbar.add(saveControl);
            t.toolbar.renderTo(toolbarContainer);
            jQuery("#pageEditor").addClass("defaultSkin");
            jQuery("#wsMainEditor_external").prependTo("#pageEditor");
            jQuery("#wsMainEditor_wssave_action").addClass("mceButton mceButtonNotReallyLabeled mceButtonGroup mceButtonGroupRight mceButtonPrimary");
            jQuery("#wsMainEditor_formatlistbox_open").click(function(e) {
                return false;
            }).on("mousedown", function(e) {
                flb.showMenu();
                return false;
            });
            t.preventMenuCloseHoverButton = false;
            t.preventMenuCloseHoverMenu = false;
            t.preventMenuCloseClick = false;
            function showSaveMenu() {
                if (jQuery("#menu_wsMainEditor_wsMainEditor_wssave_menu").is(":visible")) return;
                saveControl.showMenu();
            }
            function hideSaveMenu() {
                if (t.preventMenuCloseHoverButton || t.preventMenuCloseHoverMenu || t.preventMenuCloseClick) return;
                saveControl.hideMenu();
            }
            jQuery(document).on("mouseenter", "#menu_wsMainEditor_wsMainEditor_wssave_menu", function() {
                t.preventMenuCloseHoverMenu = true;
            }).on("mouseleave", "#menu_wsMainEditor_wsMainEditor_wssave_menu", function() {
                t.preventMenuCloseHoverMenu = false;
                setTimeout(hideSaveMenu, 500);
            });
            jQuery(toolbarContainer).find("#wsMainEditor_wssave_open, #wsMainEditor_wssave").removeAttr("title");
            jQuery(toolbarContainer).find("#wsMainEditor_wssave_open .mceOpen").click(function(e) {
                t.preventMenuCloseClick = !t.preventMenuCloseClick;
                showSaveMenu();
                e.preventDefault();
                return false;
            }).hoverIntent({
                sensitivity: 3,
                interval: 200,
                over: function() {
                    t.preventMenuCloseHoverButton = true;
                    showSaveMenu();
                },
                timeout: 500,
                out: function() {
                    t.preventMenuCloseHoverButton = false;
                    hideSaveMenu();
                }
            });
            jQuery(toolbarContainer).prepend('<table style="width: 100%; border-collapse: collapse; background: transparent;" ><tr style="height: 21px;">' + '<td style="width:10px; background: url(/i/window-bar-nl.png) no-repeat left bottom; padding: 0;"><img src="/i/c.gif" width="10" height="21" alt="" /></td>' + '<td style="width:75%; background: url(/i/window-bar-n.png) repeat-x left bottom; padding: 0;"></td>' + '<td style="width:23px; background: url(/i/window-bar-yl.png) no-repeat left bottom; padding: 0;"><img src="/i/c.gif" width="23" height="21" alt="" /></td>' + '<td style="width:25%; background: url(/i/window-bar-m.png) repeat-x left bottom; padding: 0; text-align: right;"><span id="autosaveStatus"></span></td>' + '<td style="width:10px; background: url(/i/window-bar-mr.png) no-repeat left bottom; padding: 0;"><img src="/i/c.gif" width="10" height="21" alt="" /></td>' + "</tr></table>");
            jQuery("#wsMainEditor_external").css({
                MozUserSelect: "none",
                KhtmlUserSelect: "None",
                cursor: "default"
            }).on("selectstart", function() {
                return false;
            });
            var iframeContainer = DOM.add(editorContainer, "div", {
                "class": "mceIframeContainer editorLayer active_editor",
                style: "position: relative;"
            });
            var sizeContainer = DOM.add(editorContainer, "div", {
                style: "display: none;"
            });
            return {
                iframeContainer: iframeContainer,
                editorContainer: ed.id + "_container",
                sizeContainer: sizeContainer,
                deltaHeight: 0
            };
        },
        getInfo: function() {
            return {
                longname: "Wikispaces theme",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.ThemeManager.add("wikispaces", wikispaces.themes.WikispacesTheme);
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM;
    tinymce.create("wikispaces.themes.SubEditorTheme:wikispaces.themes.WikispacesTheme", {
        renderUI: function(o) {
            var t = this;
            var ed = t.editor;
            var editorContainer = DOM.insertAfter(DOM.create("div", {
                id: ed.id + "_container",
                "class": "mceEditor " + ed.settings.skin + "Skin editorLayer",
                style: "position: relative; "
            }), o.targetNode);
            var iframeContainer = DOM.add(editorContainer, "div", {
                "class": "mceIframeContainer editorLayer",
                style: "position: relative;"
            });
            var sizeContainer = DOM.add(editorContainer, "div", {
                style: "display: none;"
            });
            return {
                iframeContainer: iframeContainer,
                editorContainer: ed.id + "_container",
                sizeContainer: sizeContainer,
                deltaHeight: 0
            };
        },
        getInfo: function() {
            return {
                longname: "Wikispaces subeditor theme",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.ThemeManager.add("subeditor", wikispaces.themes.SubEditorTheme);
})(tinymce);

(function(tinymce) {
    var DOM = tinymce.DOM;
    tinymce.create("wikispaces.themes.ReferenceTheme:wikispaces.themes.WikispacesTheme", {
        renderUI: function(o) {
            var t = this;
            var ed = t.editor;
            var cf = ed.controlManager;
            var refId = ed.getParam("reference_reference_id");
            var editorContainer = DOM.insertAfter(DOM.create("div", {
                id: ed.id + "_container",
                "class": "mceEditor " + ed.settings.skin + "Skin editorLayer referenceEditor",
                style: "position: relative; margin-top: 5px; "
            }), o.targetNode);
            var iframeContainer = DOM.add(editorContainer, "div", {
                "class": "mceIframeContainer editorLayer",
                style: "position: relative;"
            });
            var toolbarContainer = DOM.add(editorContainer, "div", {
                id: ed.id + "_external",
                "class": "toolbarLayer"
            });
            t.toolbar = cf.createToolbar("tools1");
            t.toolbar.add(cf.createButton("wsremovereference", {
                title: "Remove Reference",
                label: "Remove Reference",
                "class": "wsbtn",
                onclick: function() {
                    tinymce.mainEditor.plugins.wsreference.toggleReference(refId);
                }
            }));
            t.toolbar.add(cf.createButton("wsgotoreference", {
                title: "Show Citation",
                label: "Show Citation",
                "class": "wsbtn",
                onclick: function() {
                    var cite = jQuery(tinymce.mainEditor.getDoc()).find("#citation-" + refId);
                    var citeOffset = ed.plugins.wscommon.absoluteOffset(cite.get(0)).top;
                    var animateCounter = 0;
                    var animateCitation = function() {
                        if (animateCounter++ > 2) return;
                        cite.animate({
                            opacity: "0.1"
                        }, 500, "swing", function() {
                            cite.animate({
                                opacity: "1.0"
                            }, 500, "swing", animateCitation);
                        });
                    };
                    jQuery(window).scrollTo(citeOffset - 55, {
                        axis: "y",
                        duration: 500,
                        onAfter: animateCitation
                    });
                }
            }));
            t.toolbar.renderTo(toolbarContainer);
            jQuery(toolbarContainer).find("td:first-child").attr("width", 5);
            jQuery(toolbarContainer).find("td:nth-child(2)").attr("width", 140);
            jQuery(toolbarContainer).find("td:nth-child(3)").attr("width", 120);
            var sizeContainer = DOM.add(editorContainer, "div", {
                style: "display: none;"
            });
            return {
                iframeContainer: iframeContainer,
                editorContainer: ed.id + "_container",
                sizeContainer: sizeContainer,
                deltaHeight: 0
            };
        },
        getInfo: function() {
            return {
                longname: "Wikispaces reference theme",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                version: "0.1"
            };
        }
    });
    tinymce.ThemeManager.add("reference", wikispaces.themes.ReferenceTheme);
})(tinymce);

(function(tinymce) {
    tinymce.create("wikispaces.plugins.ImageTextPlugin:wikispaces.plugins.ImagePlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.addCommand("wsimageText", function() {
                tinymce.mainEditor.plugins.wspopup.show("imageTool", {
                    plugin: plugin
                });
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces image text",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        insertImageInEditorCallback: function(objectType, imageName, mediaType, url, location, context, img) {
            var form = document.forms["imageToolForm"];
            var embedContext = context;
            if (context && this.isLocalContext(context)) embedContext = "";
            if ("audio" == mediaType || "video" == mediaType) this.editor.wsselection.setContent('[[media type="' + objectType + '" key="' + embedContext + imageName + '"]]'); else {
                var sizeString = "";
                if ("image" == mediaType && img.width > 800) {
                    var newHeight = Math.floor(800 / img.width * img.height);
                    sizeString = ' width="800" height="' + newHeight + '"';
                }
                if ("image" == mediaType) objectType = "image";
                this.editor.wsselection.setContent("[[" + objectType + ":" + (url ? url : embedContext + imageName) + sizeString + "]]");
            }
        }
    });
    tinymce.PluginManager.add("wsimagetext", wikispaces.plugins.ImageTextPlugin);
})(tinymce);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.LinkTextPlugin:wikispaces.plugins.LinkPlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.addCommand("wslinkText", function() {
                tinymce.mainEditor.plugins.wspopup.show("linkTool", {
                    plugin: plugin
                });
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces link (text)",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        setupForms: function() {
            this.editor.wsselection.restore(true);
            this.editor.plugins.wstext.expandSelectionToTag("[[", "", "]]");
            var selected = jQuery.trim(this.editor.plugins.wstext.getSelectedText());
            if (selected) this.editor.plugins.wslinkpopup.prefill(this.parseLink(selected));
        },
        parseLink: function(link) {
            var newWindow = "";
            var text = "";
            var pieces = null;
            if (pieces = link.match(/^\[\[(@)?((?:[a-zA-Z0-9.+-]+:\/\/|mailto:).*?)(?:\|(.*))?\]\]$/i)) {
                var extLink = "";
                var email = "";
                if (pieces[1]) newWindow = pieces[1];
                if (pieces[3]) text = pieces[3];
                if (pieces[2]) {
                    extLink = pieces[2];
                    var matches = null;
                    if (matches = extLink.match(/^mailto:(.+)/i)) email = matches[1];
                    if (!text) text = extLink;
                }
                return {
                    linkText: text,
                    extLink: extLink,
                    mailTo: email,
                    targetNew: newWindow
                };
            } else if (pieces = link.match(/\[\[(@)?(?:([a-z0-9-]+):)?(?:([a-z0-9-]+)[:\/])?([^|\[\]\{\}\$#@\\]+)(?:\#([A-Za-z][-A-Za-z0-9_ ]*))?(?:\|([^\[\]\xff]+))?\]\]/)) {
                var wikiName = "";
                var pageName = "";
                var anchor = "";
                var objectClass = "page";
                if (pieces[1]) newWindow = pieces[1];
                if (pieces[2] && pieces[3]) {
                    objectClass = pieces[2];
                    wikiName = pieces[3];
                } else if (pieces[2]) if ("doc" == pieces[2] || "file" == pieces[2]) objectClass = pieces[2]; else wikiName = pieces[2];
                if (pieces[4]) pageName = pieces[4];
                if (match = pageName.match(/^[\/:](.*)/)) {
                    wikiName = wikispaces_wikiName;
                    pageName = match[1];
                }
                if (pieces[5]) anchor = pieces[5];
                if (pieces[6]) text = pieces[6];
                if (!text) if (wikiName && wikiName != wikispaces_wikiName) text = wikiName + " / " + pageName; else text = pageName;
                return {
                    linkText: text,
                    objectClass: objectClass,
                    pageName: pageName,
                    wikiName: wikiName,
                    anchor: anchor,
                    targetNew: newWindow
                };
            } else return {
                linkText: link
            };
        },
        insertLinkFromComponents: function(components) {
            var newW = "";
            if (components.targetNew) newW = "@";
            if (components.pageName) {
                var linkPrefix = "page" == components.objectClass ? "" : components.objectClass + ":";
                var link = linkPrefix + (components.wikiName == wikispaces_wikiName ? "" : components.wikiName + ":") + components.pageName;
                this.editor.wsselection.setContent("[[" + newW + link + (components.anchor ? components.anchor : "") + (components.linkText == link ? "" : "|" + components.linkText) + "]] ");
                ws.common.track("Editor", "Add Link", components.wikiName + ":" + link);
            } else if (components.mailTo) {
                var url = "mailto:" + encodeURI(components.mailTo).replace(/%25/g, "%");
                this.editor.wsselection.setContent("[[" + newW + url + (url == components.linkText ? "" : "|" + components.linkText) + "]] ");
                ws.common.track("Editor", "Add Link", url);
            } else {
                var url = encodeURI(components.url).replace(/%25/g, "%");
                this.editor.wsselection.setContent("[[" + newW + url + (url == components.linkText ? "" : "|" + components.linkText) + "]] ");
                ws.common.track("Editor", "Add Link", url);
            }
            return true;
        },
        removeLink: function() {
            ws.common.track("Editor", "Remove Link");
            if (this.editor.plugins.wstext.expandSelectionToTag("[[", "", "]]")) {
                var text = this.editor.plugins.wstext.getSelectedText();
                if ("[[code]]" != text && !text.match(/^\[\[media /) && !text.match(/^\[\[file /) && !text.match(/^\[\[image /) && !text.match(/^\[\[include /)) {
                    var match = text.match(/(\s*)\[\[([^\]]*)\]\](\s*)/);
                    text = match[1] + match[2] + match[3];
                    this.editor.plugins.wstext.insertInEditor(text);
                    return;
                }
            }
            alert("Please put your cursor inside of the link wikitext to remove it.");
        }
    });
    tinymce.PluginManager.add("wslinktext", wikispaces.plugins.LinkTextPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.PreviewTextPlugin:wikispaces.plugins.PreviewPlugin", {
        init: function(ed, url) {
            this.editor = ed;
            var plugin = this;
            ed.addCommand("previewText", function() {
                plugin.showPreview();
            });
            ed.addCommand("endPreviewText", function() {
                plugin.hidePreview();
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces preview text",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        hideEditor: function() {
            jQuery("#plainTextEditor").hide();
        },
        showEditor: function() {
            jQuery("#plainTextEditor").show();
        }
    });
    tinymce.PluginManager.add("wspreviewtext", wikispaces.plugins.PreviewTextPlugin);
})(tinymce, jQuery);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.StyleTextPlugin:wikispaces.plugins.StylePlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.addCommand("wsStyleText", function() {
                var text = plugin.editor.plugins.wstext.getSelectedText();
                tinymce.mainEditor.plugins.wspopup.show("stylePopupContents", {
                    plugin: plugin,
                    text: text
                });
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces style text",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        setSpanText: function(o) {
            if (!o.text) return;
            var styleMatch = o.text.match(/^<span\s+.*?style="([\s\S]*?)"[\s\S]*<\/span>$/i);
            if (styleMatch && 2 == styleMatch.length) {
                var styleText = styleMatch[1];
                var lines = styleText.split(";");
                for (var i = 0; i < lines.length; i++) {
                    var linePieces = lines[i].split(":");
                    var attribute = jQuery.trim(linePieces[0]);
                    var value = jQuery.trim(linePieces[1]);
                    if (attribute && value) {
                        this.setSpanTextValue(attribute, value);
                        document["styleForm"].removeStyleButton.disabled = false;
                    }
                }
            }
        },
        applyStyle: function() {
            ws.common.track("Editor", "Apply Style");
            var styleString = jQuery.trim(document["styleForm"].styleText.value);
            if (styleString.length > 0) {
                var selectedText = this.editor.plugins.wstext.getSelectedText();
                var matchedText = selectedText.match(/^<span [\s\S]*?>([\s\S]*)<\/span>$/i);
                if (matchedText && 2 == matchedText.length) selectedText = matchedText[1];
                var myField = document.getElementById("textEditor");
                myField.focus();
                this.editor.plugins.wstext.insertInEditor('<span style="' + styleString + '">' + selectedText + "</span>");
            } else this.removeStyle();
            return false;
        },
        removeStyle: function() {
            ws.common.track("Editor", "Remove Style");
            var selectedText = this.editor.plugins.wstext.getSelectedText();
            var matchedText = selectedText.match(/^<span [\s\S]*?>([\s\S]*)<\/span>$/i);
            if (matchedText && 2 == matchedText.length) this.editor.plugins.wstext.insertInEditor(matchedText[1]);
        },
        getUsedColors: function() {
            var colors = new Array();
            var content = this.editor.plugins.wstext.getContent();
            var matches = content.match(/style=\"[^\"]*?color:\s*.*?[;\"]/gi);
            if (matches) for (var i = 0; i < matches.length; i++) {
                var matches2 = matches[i].match(/color:\s*(.*?)[;\"]/i);
                colors[colors.length] = new RGBColor(matches2[1]).toHex().toUpperCase();
            }
            return colors;
        }
    });
    tinymce.PluginManager.add("wsstyletext", wikispaces.plugins.StyleTextPlugin);
})(tinymce, jQuery);

(function(tinymce) {
    tinymce.create("wikispaces.plugins.TableTextPlugin:wikispaces.plugins.TablePlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.addCommand("wsTableText", function() {
                tinymce.mainEditor.plugins.wspopup.show("tablePopupContents", {
                    plugin: plugin
                });
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces table text",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        addTable: function(tableRows, tableCols) {
            ws.common.track("Editor", "Add Table", tableRows + "x" + tableCols);
            var result = "";
            for (var rows = 0; rows < tableRows; rows++) {
                result += "\n||";
                for (cols = 0; cols < tableCols; cols++) result += " ||";
            }
            result += "\n";
            this.editor.wsselection.setContent(result);
        }
    });
    tinymce.PluginManager.add("wstabletext", wikispaces.plugins.TableTextPlugin);
})(tinymce);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.TextPlugin", {
        init: function(ed, url) {
            var plugin = this;
            plugin.editor = ed;
            ed.addCommand("wstext", function() {
                if ("visual" == ed.plugins.wscommon.getOption("mode")) plugin.switchToTextEditor(); else {
                    if (jQuery("#previewBox").length) ed.execCommand("endPreviewText");
                    plugin.switchToVisualEditor();
                }
            });
            ed.addCommand("BoldText", function() {
                plugin.wrapTextEditorSelection("**");
            });
            ed.addCommand("ItalicText", function() {
                plugin.wrapTextEditorSelection("//");
            });
            ed.addCommand("UnderlineText", function() {
                plugin.wrapTextEditorSelection("__");
            });
            ed.addCommand("wsFormatBlockText", function(ui, val) {
                var wrap = "";
                if ("h1" == val) wrap = "="; else if ("h2" == val) wrap = "=="; else if ("h3" == val) wrap = "==="; else if ("h4" == val) wrap = "===="; else if ("h5" == val) wrap = "====="; else if ("h6" == val) wrap = "======";
                if (wrap) if (plugin.getSelectedText()) plugin.insertInEditor("\n" + wrap + plugin.getSelectedText() + wrap + "\n"); else {
                    var texteditor = document.getElementById("textEditor");
                    plugin.prepareSelection(texteditor);
                    var cursorPos = texteditor.sel_start + wrap.length + 1;
                    plugin.insertInEditor("\n" + wrap + wrap + "\n");
                    plugin.setSelectionRange(texteditor, cursorPos, cursorPos);
                }
                document.getElementById("textEditor").focus();
            });
            ed.addCommand("wsInsertOrderedListText", function() {
                plugin.addListInTextEditor("#");
            });
            ed.addCommand("wsInsertUnorderedListText", function() {
                plugin.addListInTextEditor("*");
            });
            ed.addCommand("wsInsertHorizontalRuleText", function() {
                plugin.insertInEditor("\n----\n");
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces text",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        flipToText: function(textContent) {
            this.editor.undoManager.clear();
            jQuery("#plainTextEditor").show();
            jQuery("#textEditor").show().val(textContent);
            jQuery("html, body").animate({
                scrollTop: 0
            }, "fast");
            jQuery("#wsMainEditor_container").css("position", "static");
            this.editor.plugins.wscommon.setOption("mode", "plain");
            this.editor.onModeSwitch.dispatch("plain");
            jQuery(this.editor.getContentAreaContainer()).hide();
            setTimeout(function() {
                jQuery("#textEditor").focus();
            }, 500);
            if (tinymce.isIE) {
                function explicitTextAreaWidth() {
                    jQuery("#textEditor").css("width", jQuery("#textEditor").parent().width() - 10);
                }
                explicitTextAreaWidth();
                jQuery(window).resize(explicitTextAreaWidth);
            }
            this.setClean();
        },
        switchToTextEditor: function() {
            var me = this;
            var content = this.editor.plugins.wscommon.fullContent(true);
            this.convertContent(content, "plain", function(text) {
                me.flipToText(text);
            }, function() {
                me.switchToTextEditor();
            });
            ws.common.track("Editor", "Switch Mode To", "Text");
        },
        switchToVisualEditor: function() {
            var me = this;
            this.convertContent(this.editor.plugins.wstext.getContent(), "visual", function(html) {
                jQuery("#plainTextEditor").hide();
                jQuery(me.editor.getContentAreaContainer()).show();
                jQuery("html, body").animate({
                    scrollTop: 0
                }, "fast");
                me.editor.plugins.wscommon.setOption("mode", "visual");
                me.editor.onModeSwitch.dispatch("visual");
                me.editor.setContent(html, {
                    load: true
                });
                me.editor.undoManager.clear();
                me.editor.onNeedsResize.dispatch();
                setTimeout(function() {
                    me.editor.onNeedsResize.dispatch();
                }, 1e3);
                me.editor.wsselection.ensureCursor();
                me.editor.focus();
                jQuery("#wsMainEditor_container").css("position", "relative");
            }, function() {
                me.switchToVisualEditor();
            });
            ws.common.track("Editor", "Switch Mode To", "Visual");
        },
        convertContent: function(content, mode, callback, reloadCallback) {
            var me = this;
            var spinner = jQuery("<div></div>").attr("id", "textSpinner").addClass("wikispaces_content").addClass("mceToolbar spinner").css({
                textAlign: "center"
            }).html('Loading <img src="/i/spinner.gif" alt="" width="18" height="18" style="padding-top: 9px; vertical-align: -4px;"/>');
            jQuery(".mceToolbar").hide();
            jQuery(me.editor.plugins.wscommon.editorToolbar()).append(spinner);
            var errorFunction = function(request, textStatus, errorThrown) {
                ws.session.reloadSession(reloadCallback, 3e3, function() {
                    me.editor.plugins.wscommon.sessionReloadFailed();
                    jQuery(".mceToolbar.spinner").remove();
                    jQuery(".mceToolbar").show();
                });
            };
            jQuery.ajax({
                url: ws.common.pathFor("page", "convert", wikispaces_page),
                type: "POST",
                async: false,
                cache: false,
                data: {
                    content: content,
                    mode: mode
                },
                dataType: "xml",
                global: false,
                error: errorFunction,
                success: function(xml, textStatus, request) {
                    ws.session.reloadSessionSuccess();
                    var jConvert = jQuery(xml).find("convert");
                    if (jConvert.length) callback(jConvert.text());
                    jQuery(".mceToolbar.spinner").remove();
                    jQuery(".mceToolbar").show();
                }
            });
        },
        editorTextArea: function() {
            return jQuery("#textEditor").get(0);
        },
        getContent: function() {
            return jQuery("#textEditor").val();
        },
        isDirty: function() {
            return this.getContent() != this.cleanContent;
        },
        setClean: function() {
            this.cleanContent = this.getContent();
        },
        insertInEditor: function(myValue) {
            var myField = document.getElementById("textEditor");
            myField.focus();
            if (document.selection) {
                sel = document.selection.createRange();
                sel.text = myValue;
                sel.select();
            } else if (myField.selectionStart || "0" == myField.selectionStart) {
                var startPos = myField.selectionStart;
                var endPos = myField.selectionEnd;
                var scrollTop = myField.scrollTop;
                jQuery(myField).val(myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length));
                myField.scrollTop = scrollTop;
                if (startPos == endPos) this.setSelectionRange(myField, startPos + myValue.length, startPos + myValue.length); else this.setSelectionRange(myField, startPos, startPos + myValue.length);
                this.editor.wsselection.saveOver();
            } else myField.value += myValue;
        },
        setSelectionRange: function(element, start, end) {
            if (element.setSelectionRange) return element.setSelectionRange(start, end);
            var range = element.createTextRange();
            range.collapse(true);
            range.moveEnd("character", end);
            range.moveStart("character", start);
            range.select();
        },
        wrapTextEditorSelection: function(wrapWith) {
            var selectedText = this.getSelectedText();
            var originalLength = selectedText.length;
            selectedText = selectedText.replace(/^\s+/, "");
            var lpad = originalLength - selectedText.length;
            selectedText = selectedText.replace(/\s+$/, "");
            var rpad = originalLength - lpad - selectedText.length;
            var insertText = "";
            if (selectedText.substring(0, wrapWith.length) == wrapWith && selectedText.substring(selectedText.length - wrapWith.length, selectedText.length) == wrapWith) insertText = selectedText.substring(wrapWith.length, selectedText.length - wrapWith.length); else insertText = wrapWith + selectedText + wrapWith;
            for (var i = 0; i < lpad; i++) insertText = " " + insertText;
            for (var i = 0; i < rpad; i++) insertText += " ";
            var texteditor = document.getElementById("textEditor");
            this.prepareSelection(texteditor);
            var currentStart = texteditor.sel_start;
            var currentEnd = texteditor.sel_end;
            var length = insertText.length;
            this.insertInEditor(insertText);
            if (currentStart == currentEnd) this.setSelectionRange(texteditor, currentStart + length / 2, currentStart + length / 2); else this.setSelectionRange(texteditor, currentStart, length + currentStart);
            this.editor.wsselection.saveOver();
            texteditor.focus();
        },
        getSelectedText: function() {
            var myField = document.getElementById("textEditor");
            if (myField) {
                this.prepareSelection(myField);
                return myField.sel_text ? myField.sel_text : "";
            }
            return "";
        },
        prepareSelection: function(textarea) {
            textarea.sel_text = "";
            textarea.sel_text_pre = "";
            textarea.sel_text_post = "";
            textarea.sel_start = 0;
            textarea.sel_end = 0;
            textarea.focus();
            if ("number" == typeof textarea.selectionStart) {
                textarea.sel_start = textarea.selectionStart;
                textarea.sel_end = textarea.selectionEnd;
            } else if (document.selection) {
                var range = document.selection.createRange();
                if (range.parentElement() != textarea) return;
                var range_all = range.duplicate();
                range_all.moveToElementText(textarea);
                range_all.setEndPoint("EndToEnd", range);
                var sel_end = range_all.text.length;
                var sel_start = sel_end - range.text.length;
                var value = textarea.value;
                for (var i = sel_end - 1; i >= sel_start; --i) if ("\n" == value.charAt(i)) --sel_end;
                for (var i = sel_start - 1; i >= 0; --i) if ("\n" == value.charAt(i)) {
                    --sel_end;
                    --sel_start;
                }
                textarea.sel_start = sel_start;
                textarea.sel_end = sel_end;
            }
            var jValue = jQuery(textarea).val();
            textarea.sel_text = jValue.substring(textarea.sel_start, textarea.sel_end);
            textarea.sel_text_pre = jValue.substring(0, textarea.sel_start);
            textarea.sel_text_post = jValue.substring(textarea.sel_end);
        },
        expandSelectionToLine: function() {
            var myField = document.getElementById("textEditor");
            this.prepareSelection(myField);
            var newStart;
            var jValue = jQuery(myField).val();
            for (var i = myField.sel_start - 1; i >= 0; i--) if ("\n" == jValue.charAt(i)) {
                newStart = i + 1;
                break;
            }
            for (i = myField.sel_end; i < jValue.length && "\n" != jValue.charAt(i); i++) ;
            this.setSelectionRange(myField, newStart, i);
            return true;
        },
        expandSelectionToTag: function(tagPrefix, tagName, tagSuffix) {
            var currentSelection = this.getSelectedText().replace(/^\s+/, "").replace(/\s+$/, "");
            if (currentSelection) {
                if (currentSelection.substring(0, tagName.length + tagPrefix.length) == tagPrefix + tagName && currentSelection.substring(currentSelection.length - tagSuffix.length, currentSelection.length) == tagSuffix) return true;
                return false;
            }
            var myField = document.getElementById("textEditor");
            this.prepareSelection(myField);
            var openingTagsFound = 0;
            var closingTagsFound = 0;
            var startFrom = myField.sel_start - 1;
            if (startFrom < 0) startFrom = 0;
            var newStart = null;
            var jValue = jQuery(myField).val();
            for (var i = startFrom; i >= 0; i--) if (jValue.substr(i, tagPrefix.length + tagName.length) == tagPrefix + tagName) {
                if (0 == closingTagsFound) {
                    newStart = i;
                    break;
                }
                closingTagsFound--;
            } else if (jValue.substr(i, tagPrefix.length) == tagPrefix) return false; else if (jValue.substr(i, tagSuffix.length) == tagSuffix) if (myField.sel_start - i >= tagSuffix.length) closingTagsFound++;
            if (null == newStart) return false;
            startFrom = myField.sel_end - (tagSuffix.length - 1);
            if (startFrom < 0) startFrom = 0;
            if (startFrom < newStart + tagPrefix.length + tagName.length) startFrom = newStart + tagPrefix.length + tagName.length;
            for (var i = startFrom; i < jValue.length - 1; i++) if (jValue.substr(i, tagSuffix.length) == tagSuffix) {
                if (0 == openingTagsFound) {
                    this.setSelectionRange(myField, newStart, i + tagSuffix.length);
                    this.editor.wsselection.saveOver();
                    return true;
                }
                openingTagsFound--;
            } else if (jValue.substr(i, tagPrefix.length) == tagPrefix) openingTagsFound++;
            return false;
        },
        addListInTextEditor: function(prefix) {
            if (!this.getSelectedText()) this.expandSelectionToLine();
            var myField = document.getElementById("textEditor");
            this.prepareSelection(myField);
            var text = myField.sel_text;
            var result = "";
            var unlistMode = true;
            var lines = text.split("\n");
            for (var i = 0; i < lines.length; i++) {
                var matches;
                if (matches = lines[i].match(/^(\#|\*|\>)+\s(.*)$/i)) {
                    if (matches[1].charAt(0) != prefix) unlistMode = false;
                    result += "\n" + prefix + " " + matches[2];
                } else {
                    unlistMode = false;
                    result += "\n" + prefix + " " + lines[i];
                }
            }
            if (0 == myField.sel_text_pre.length || "\n" == myField.sel_text_pre.charAt(myField.sel_text_pre.length - 1)) result = result.substring(1, result.length);
            if (unlistMode) {
                var text = myField.sel_text;
                result = "";
                var lines = text.split("\n");
                for (var i = 0; i < lines.length; i++) if (matches = lines[i].match(/^(\#|\*|\>)+\s(.*)$/i)) result += matches[2] + "\n";
                if ("\n" != myField.sel_text.charAt(myField.sel_text.length - 1)) result = result.substring(0, result.length - 1);
            }
            this.insertInEditor(result);
        }
    });
    tinymce.PluginManager.add("wstext", wikispaces.plugins.TextPlugin);
})(tinymce, jQuery);

(function(tinymce) {
    tinymce.create("wikispaces.plugins.WidgetTextPlugin:wikispaces.plugins.WidgetPlugin", {
        init: function(ed, url) {
            var plugin = this;
            this.editor = ed;
            ed.addCommand("wsWidgetText", function() {
                ws.common.track("Editor", "Open Media Tool");
                var mediaString = "";
                if (ed.plugins.wstext.expandSelectionToTag("[[", "media", "]]")) mediaString = "wikitext@@media@@" + ed.plugins.wstext.getSelectedText().match(/\[\[media (.*)\]\]/)[1]; else if (ed.plugins.wstext.expandSelectionToTag("[[", "rss", "]]")) mediaString = "wikitext@@rss@@" + ed.plugins.wstext.getSelectedText().match(/\[\[rss (.*)\]\]/)[1]; else if (ed.plugins.wstext.expandSelectionToTag("[[", "", "]]")) mediaString = ed.plugins.wstext.getSelectedText().match(/^\[\[(#.+)\]\]/)[1];
                tinymce.mainEditor.plugins.wspopup.show("mediaTool", {
                    plugin: plugin,
                    mediaString: mediaString
                });
            });
        },
        getInfo: function() {
            return {
                longname: "Wikispaces widgets text",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        insertWidget: function(embed, mediaType) {
            ws.common.track("Editor", "Add Media", mediaType);
            this.editor.wsselection.setContent(embed);
        },
        insertCharacter: function(html, text) {
            ws.common.track("Editor", "Add Character", html);
            this.editor.wsselection.setContent(text);
        },
        insertReference: function() {
            ws.common.track("Editor", "Insert Reference");
            this.editor.wsselection.setContent("<ref></ref>");
        },
        insertReferences: function() {
            ws.common.track("Editor", "Insert References");
            this.editor.wsselection.setContent("\n<references/>");
        },
        insertToc: function(flat) {
            ws.common.track("Editor", "Insert Toc", flat);
            if (flat) this.editor.wsselection.setContent("\n[[toc|flat]]"); else this.editor.wsselection.setContent("\n[[toc]]");
        },
        insertCode: function(code, format) {
            if (!format) format = "text";
            ws.common.track("Editor", "Add Code", format);
            this.editor.wsselection.setContent('\n[[code format="' + format + '"]]\n' + code + "\n[[code]]\n");
        },
        insertAnchor: function(anchorText) {
            ws.common.track("Editor", "Add Anchor", anchorText);
            this.editor.wsselection.setContent("[[#" + anchorText + "]]");
            return true;
        }
    });
    tinymce.PluginManager.add("wswidgettext", wikispaces.plugins.WidgetTextPlugin);
})(tinymce);

(function(tinymce, jQuery) {
    tinymce.create("wikispaces.plugins.WidgetOverlay:wikispaces.plugins.ImageOverlay", {
        getInfo: function() {
            return {
                longname: "Wikispaces widget overlay",
                author: "Tangient LLC",
                authorurl: "http://wikispaces.com",
                infourl: "http://wikispaces.com",
                version: "0.1"
            };
        },
        init: function(ed, url) {
            var plugin = this;
            ed.onInit.add(function(editor) {
                var initFunc = function(editor) {
                    editor.onClick.add(function(editor, e) {
                        var widget = editor.plugins.wswidget.findWidgetPlaceholder(e.target);
                        if (widget) plugin.show(editor, widget); else plugin.hide();
                    });
                };
                editor.onInitSubEditor.add(initFunc);
                initFunc(editor);
            });
            this.overlayInit(ed, url);
        },
        show: function(editor, media) {
            this.parent(editor, media);
            if (jQuery(media).hasClass("WikiAnchor")) {
                var anchorName = jQuery(media).attr("id").match(/@@([^@]+)$/)[1];
                jQuery("#mediaAnchorName").text(ws.common.truncify(anchorName, 40));
                jQuery("#mediaEdit").show();
                jQuery("#mediaAppearance").hide();
                jQuery("#mediaAnchorNameSection").show();
            } else if (jQuery(media).is(".WikiMediaToc, .WikiMediaTocFlat")) {
                jQuery("#mediaEdit").hide();
                jQuery("#mediaAppearance").hide();
                jQuery("#mediaAnchorNameSection").hide();
            } else if (jQuery(media).is(".WikiMediaRss, .WikiMediaInclude")) {
                jQuery("#mediaEdit").show();
                jQuery("#mediaAppearance").hide();
                jQuery("#mediaAnchorNameSection").hide();
            } else {
                jQuery("#mediaEdit").show();
                jQuery("#mediaAppearance").show();
                jQuery("#mediaAnchorNameSection").hide();
            }
            this.repositionAndShow();
        },
        overlayContent: function() {
            return ws.editor.content.loadContent("mediaProperties");
        },
        refreshAlignment: function() {
            jQuery("#mediaAlign a").removeClass("buttonSelected");
            switch (this.currentAlignment()) {
              case "left":
                jQuery("#mediaAlignLeft").addClass("buttonSelected");
                break;

              case "center":
                jQuery("#mediaAlignCenter").addClass("buttonSelected");
                break;

              case "right":
                jQuery("#mediaAlignRight").addClass("buttonSelected");
            }
        },
        setup: function() {
            var me = this;
            jQuery("#mediaAlignLeft").click(function() {
                me.setImageAlignment("left");
                return false;
            });
            jQuery("#mediaAlignCenter").click(function() {
                me.setImageAlignment("center");
                return false;
            });
            jQuery("#mediaAlignRight").click(function() {
                me.setImageAlignment("right");
                return false;
            });
            jQuery("#mediaAlignNone").click(function() {
                me.setImageAlignment("");
                return false;
            });
            jQuery("#mediaSizeDown").click(function() {
                me.adjustImageSize(-.1);
                return false;
            });
            jQuery("#mediaSizeUp").click(function() {
                me.adjustImageSize(.1);
                return false;
            });
            jQuery("#mediaSizeOriginal").click(function() {
                me.adjustImageSize(0, true);
                return false;
            });
            jQuery("#mediaSizeFit").click(function() {
                me.adjustImageSize(0, false, true);
                return false;
            });
            jQuery("#mediaEditLink").click(function() {
                me.editor.plugins.wswidget.openWidget(me.img);
                me.hide();
                return false;
            });
            jQuery("#mediaRemoveLink").click(function() {
                me.editor.undoManager.add();
                me.editor.dom.remove(me.img);
                me.hide();
                return false;
            });
        },
        toggleFitImage: function() {
            if (jQuery(this.img).width() > 800) jQuery("#mediaSizeFit").show(); else jQuery("#mediaSizeFit").hide();
        }
    });
    tinymce.PluginManager.add("wswidgetoverlay", wikispaces.plugins.WidgetOverlay);
})(tinymce, jQuery);

(function() {
    tinymce.create("tinymce.plugins.Autoresize", {
        init: function(ed, url) {
            ed.onNeedsResize = new tinymce.util.Dispatcher(ed);
            ed.onNeedsResize.add(this.fitEditor);
            ed.onSetContent.add(this.fitEditor);
            ed.onChange.add(this.fitEditor);
            ed.onKeyDown.add(this.fitEditor);
            ed.onInit.add(this.fitEditor);
            ed.onPaste.add(function() {
                _.delay(function() {
                    ed.onNeedsResize.dispatch();
                }, 200);
            });
            ed.onNeedsResize.dispatch();
        },
        fitEditor: function() {
            editorID = this.id;
            var tble, frame, doc, docHeight, frameHeight;
            frame = document.getElementById(editorID + "_ifr");
            if (null != frame) {
                if (frame.contentDocument) doc = frame.contentDocument; else if (frame.contentWindow) doc = frame.contentWindow.document; else if (frame.document) doc = frame.document;
                if (null == doc) return;
                doc.body.style.overflow = "hidden";
                tble = frame.parentNode.parentNode.parentNode.parentNode;
                tble.style.height = "auto";
                frameHeight = parseInt(frame.style.height);
                if (tinymce.isWebKit || jQuery.browser.mozilla) docHeight = jQuery(doc.body).height(); else docHeight = parseInt(doc.body.scrollHeight);
                var buffer = tinymce.isWebKit ? 0 : 50;
                if (docHeight + buffer > frameHeight) frame.style.height = docHeight + buffer + "px"; else if (docHeight + buffer < frameHeight) frame.style.height = Math.max(docHeight + buffer, 100) + "px";
                jQuery(frame).parent().css("width", "100%");
                jQuery(frame).scrollTo(0);
            }
        }
    });
    tinymce.PluginManager.add("autoresize", tinymce.plugins.Autoresize);
})();

(function() {
    tinymce.create("tinymce.plugins.Rgbcolor", {
        init: function(ed, url) {}
    });
    tinymce.PluginManager.add("rgbcolor", tinymce.plugins.Rgbcolor);
})();

function RGBColor(color_string) {
    this.ok = false;
    if ("#" == color_string.charAt(0)) color_string = color_string.substr(1, 6);
    color_string = color_string.replace(/ /g, "");
    color_string = color_string.toLowerCase();
    var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
    };
    for (var key in simple_colors) if (color_string == key) color_string = simple_colors[key];
    var color_defs = [ {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: [ "rgb(123, 234, 45)", "rgb(255,234,245)" ],
        process: function(bits) {
            return [ parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3]) ];
        }
    }, {
        re: /^(\w{2})(\w{2})(\w{2})$/,
        example: [ "#00ff00", "336699" ],
        process: function(bits) {
            return [ parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16) ];
        }
    }, {
        re: /^(\w{1})(\w{1})(\w{1})$/,
        example: [ "#fb0", "f0f" ],
        process: function(bits) {
            return [ parseInt(bits[1] + bits[1], 16), parseInt(bits[2] + bits[2], 16), parseInt(bits[3] + bits[3], 16) ];
        }
    } ];
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
    this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
    this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
    this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    };
    this.toHex = function() {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (1 == r.length) r = "0" + r;
        if (1 == g.length) g = "0" + g;
        if (1 == b.length) b = "0" + b;
        return "#" + r + g + b;
    };
    this.getHelpXML = function() {
        var examples = new Array();
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) examples[examples.length] = example[j];
        }
        for (var sc in simple_colors) examples[examples.length] = sc;
        var xml = document.createElement("ul");
        xml.setAttribute("id", "rgbcolor-examples");
        for (var i = 0; i < examples.length; i++) try {
            var list_item = document.createElement("li");
            var list_color = new RGBColor(examples[i]);
            var example_div = document.createElement("div");
            example_div.style.cssText = "margin: 3px; " + "border: 1px solid black; " + "background:" + list_color.toHex() + "; " + "color:" + list_color.toHex();
            example_div.appendChild(document.createTextNode("test"));
            var list_item_value = document.createTextNode(" " + examples[i] + " -> " + list_color.toRGB() + " -> " + list_color.toHex());
            list_item.appendChild(example_div);
            list_item.appendChild(list_item_value);
            xml.appendChild(list_item);
        } catch (e) {}
        return xml;
    };
}